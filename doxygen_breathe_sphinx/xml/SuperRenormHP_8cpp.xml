<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="SuperRenormHP_8cpp" kind="file" language="C++">
    <compoundname>SuperRenormHP.cpp</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Super Renormalizable Higgs Portal DM specific module functions for DarkBit</para>
<para><hruler/>
</para>
<para>Authors (add name and date if you modify):</para>
<para><simplesect kind="author"><para>IÃ±igo Saez Casares (<ulink url="mailto:inigo.saez_casares@ens-paris-saclay.fr">inigo.saez_casares@ens-paris-saclay.fr</ulink>) </para>
</simplesect>
<simplesect kind="date"><para>2019 December</para>
</simplesect>
<hruler/>
 </para>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">//<sp/><sp/><sp/>GAMBIT:<sp/>Global<sp/>and<sp/>Modular<sp/>BSM<sp/>Inference<sp/>Tool</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/>*********************************************</highlight></codeline>
<codeline lineno="16"><highlight class="comment"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="comment">//<sp/>TODO:<sp/>Temporarily<sp/>disabled<sp/>until<sp/>project<sp/>is<sp/>ready</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="19"><highlight class="comment">#include<sp/>&lt;algorithm&gt;</highlight></codeline>
<codeline lineno="20"><highlight class="comment">#include<sp/>&lt;cmath&gt;</highlight></codeline>
<codeline lineno="21"><highlight class="comment">#include<sp/>&lt;math.h&gt;</highlight></codeline>
<codeline lineno="22"><highlight class="comment">#include<sp/>&lt;type_traits&gt;</highlight></codeline>
<codeline lineno="23"><highlight class="comment">#include<sp/>&lt;vector&gt;</highlight></codeline>
<codeline lineno="24"><highlight class="comment">#include<sp/>&lt;string&gt;</highlight></codeline>
<codeline lineno="25"><highlight class="comment">#include<sp/>&lt;iostream&gt;</highlight></codeline>
<codeline lineno="26"><highlight class="comment">#include<sp/>&lt;fstream&gt;</highlight></codeline>
<codeline lineno="27"><highlight class="comment">#include<sp/>&lt;functional&gt;</highlight></codeline>
<codeline lineno="28"><highlight class="comment"></highlight></codeline>
<codeline lineno="29"><highlight class="comment">#include<sp/>&lt;gsl/gsl_math.h&gt;</highlight></codeline>
<codeline lineno="30"><highlight class="comment">#include<sp/>&lt;gsl/gsl_errno.h&gt;</highlight></codeline>
<codeline lineno="31"><highlight class="comment">#include<sp/>&lt;gsl/gsl_rng.h&gt;</highlight></codeline>
<codeline lineno="32"><highlight class="comment">#include<sp/>&lt;gsl/gsl_monte_plain.h&gt;</highlight></codeline>
<codeline lineno="33"><highlight class="comment">#include<sp/>&lt;gsl/gsl_monte_vegas.h&gt;</highlight></codeline>
<codeline lineno="34"><highlight class="comment">#include<sp/>&lt;gsl/gsl_integration.h&gt;</highlight></codeline>
<codeline lineno="35"><highlight class="comment">#include<sp/>&lt;gsl/gsl_min.h&gt;</highlight></codeline>
<codeline lineno="36"><highlight class="comment">#include<sp/>&lt;gsl/gsl_interp.h&gt;</highlight></codeline>
<codeline lineno="37"><highlight class="comment">#include<sp/>&lt;gsl/gsl_spline.h&gt;</highlight></codeline>
<codeline lineno="38"><highlight class="comment">#include<sp/>&lt;gsl/gsl_sf_bessel.h&gt;</highlight></codeline>
<codeline lineno="39"><highlight class="comment"></highlight></codeline>
<codeline lineno="40"><highlight class="comment">#include<sp/>&quot;gambit/Elements/gambit_module_headers.hpp&quot;</highlight></codeline>
<codeline lineno="41"><highlight class="comment">#include<sp/>&quot;gambit/Elements/spectrum_helpers.hpp&quot;</highlight></codeline>
<codeline lineno="42"><highlight class="comment">#include<sp/>&quot;gambit/Utils/util_functions.hpp&quot;</highlight></codeline>
<codeline lineno="43"><highlight class="comment">#include<sp/>&quot;gambit/Utils/ascii_table_reader.hpp&quot;</highlight></codeline>
<codeline lineno="44"><highlight class="comment">#include<sp/>&quot;gambit/Utils/numerical_constants.hpp&quot;</highlight></codeline>
<codeline lineno="45"><highlight class="comment">#include<sp/>&quot;gambit/Utils/statistics.hpp&quot;</highlight></codeline>
<codeline lineno="46"><highlight class="comment">#include<sp/>&quot;gambit/DarkBit/DarkBit_rollcall.hpp&quot;</highlight></codeline>
<codeline lineno="47"><highlight class="comment">#include<sp/>&quot;gambit/DarkBit/DarkBit_utils.hpp&quot;</highlight></codeline>
<codeline lineno="48"><highlight class="comment"></highlight></codeline>
<codeline lineno="49"><highlight class="comment">namespace<sp/>Gambit</highlight></codeline>
<codeline lineno="50"><highlight class="comment">{</highlight></codeline>
<codeline lineno="51"><highlight class="comment"><sp/><sp/>namespace<sp/>DarkBit</highlight></codeline>
<codeline lineno="52"><highlight class="comment"><sp/><sp/>{</highlight></codeline>
<codeline lineno="53"><highlight class="comment"></highlight></codeline>
<codeline lineno="55"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline lineno="56"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/>General<sp/>Functions<sp/>and<sp/>Classes<sp/>for<sp/>Higgs<sp/>Portal<sp/>DM<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline lineno="57"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline lineno="59"><highlight class="comment"></highlight></codeline>
<codeline lineno="60"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>\brief<sp/>Supporting<sp/>classes<sp/>and<sp/>functions<sp/>for<sp/>the<sp/>Higgs<sp/>Portal<sp/>DM<sp/>module.</highlight></codeline>
<codeline lineno="61"><highlight class="comment"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="62"><highlight class="comment"></highlight></codeline>
<codeline lineno="63"><highlight class="comment"><sp/><sp/><sp/><sp/>//-------------<sp/>Numerical<sp/>constants<sp/>and<sp/>other<sp/>useful<sp/>things<sp/>-------------//</highlight></codeline>
<codeline lineno="64"><highlight class="comment"></highlight></codeline>
<codeline lineno="65"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>masses</highlight></codeline>
<codeline lineno="66"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Mp<sp/>=<sp/>Gambit::m_planck;<sp/>//<sp/>Planck<sp/>mass<sp/>[GeV]</highlight></codeline>
<codeline lineno="67"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>me<sp/>=<sp/>Gambit::m_electron*1e9;<sp/>//<sp/>electron<sp/>mass<sp/>[eV]</highlight></codeline>
<codeline lineno="68"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>mH<sp/>=<sp/>125.1*1e9;<sp/>//<sp/>Higgs<sp/>boson<sp/>mass<sp/>[eV]<sp/>(PDG<sp/>2019)</highlight></codeline>
<codeline lineno="69"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>mT<sp/>=<sp/>172.9*1e9;<sp/>//<sp/>top<sp/>quark<sp/>mass<sp/>[eV]<sp/>(PDG<sp/>2019)</highlight></codeline>
<codeline lineno="70"><highlight class="comment"></highlight></codeline>
<codeline lineno="71"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>mathematical<sp/>constants</highlight></codeline>
<codeline lineno="72"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>pi=Gambit::pi;</highlight></codeline>
<codeline lineno="73"><highlight class="comment"></highlight></codeline>
<codeline lineno="74"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>physical<sp/>constants</highlight></codeline>
<codeline lineno="75"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>alphaEM<sp/>=<sp/>Gambit::alpha_EM;<sp/>//<sp/>fine<sp/>structure<sp/>constant</highlight></codeline>
<codeline lineno="76"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>alphaS<sp/>=<sp/>pi;<sp/>//<sp/>strong<sp/>coupling<sp/>constant,<sp/>don&apos;t<sp/>use<sp/>this<sp/>(take<sp/>from<sp/>spectrum)</highlight></codeline>
<codeline lineno="77"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>v<sp/>=<sp/>246e9;<sp/>//<sp/>electroweak<sp/>vev<sp/>[eV]</highlight></codeline>
<codeline lineno="78"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>hbar_GeV<sp/>=<sp/>Gambit::hbar;<sp/>//<sp/>reduced<sp/>Planck<sp/>constant<sp/>[GeV.s]</highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>hbar_eV<sp/>=<sp/>Gambit::hbar*1e9;<sp/>//<sp/>reduced<sp/>Planck<sp/>constant<sp/>[eV.s]</highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>hbar_cgs<sp/>=<sp/>1.054571818e-27;<sp/>//<sp/>reduced<sp/>Planck<sp/>constant<sp/>[cgs]</highlight></codeline>
<codeline lineno="81"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>cs<sp/>=<sp/>Gambit::s2cm;<sp/>//<sp/>speed<sp/>of<sp/>light<sp/>[cm/s]</highlight></codeline>
<codeline lineno="82"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>kb<sp/>=<sp/>Gambit::K2eV;<sp/>//<sp/>Boltzmann<sp/>constant<sp/>[eV/K]</highlight></codeline>
<codeline lineno="83"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>G_cgs<sp/>=<sp/>6.674e-8;<sp/>//<sp/>Gravitational<sp/>constant<sp/>[cmÂ³/g/sÂ²]</highlight></codeline>
<codeline lineno="84"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>G_SI<sp/>=<sp/>6.674e-11;<sp/>//<sp/>Gravitational<sp/>constant<sp/>[mÂ³/kg/sÂ²]</highlight></codeline>
<codeline lineno="85"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Mpc_2_km<sp/>=<sp/>3.0857e19;<sp/>//<sp/>Mpc<sp/>to<sp/>km</highlight></codeline>
<codeline lineno="86"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>kg_2_GeV<sp/>=<sp/>1.7827e27;<sp/>//<sp/>kg<sp/>to<sp/>GeV</highlight></codeline>
<codeline lineno="87"><highlight class="comment"></highlight></codeline>
<codeline lineno="88"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>cosmological<sp/>constants</highlight></codeline>
<codeline lineno="89"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>s0(2891);<sp/>//<sp/>current<sp/>entropy<sp/>density<sp/>[1/cmÂ³]</highlight></codeline>
<codeline lineno="90"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>const<sp/>double<sp/>rhoC(4.84e3);<sp/>//<sp/>current<sp/>critical<sp/>density<sp/>[eV/cmÂ³]</highlight></codeline>
<codeline lineno="91"><highlight class="comment"></highlight></codeline>
<codeline lineno="92"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>astrophysical<sp/>constants</highlight></codeline>
<codeline lineno="93"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>r0(26.2225e21);<sp/>//<sp/>Sun&apos;s<sp/>distance<sp/>from<sp/>the<sp/>galactic<sp/>center<sp/>[cm]</highlight></codeline>
<codeline lineno="94"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Rsun(5.9598e10);<sp/>//<sp/>Solar<sp/>radius<sp/>[cm]</highlight></codeline>
<codeline lineno="95"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>L0<sp/>=<sp/>2.388672e45;<sp/>//<sp/>solar<sp/>photon<sp/>luminosity<sp/>[eV/s]</highlight></codeline>
<codeline lineno="96"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>rho0(0.3e9);<sp/>//<sp/>local<sp/>DM<sp/>density<sp/>(Milky<sp/>Way)<sp/>[eV/cmÂ³]</highlight></codeline>
<codeline lineno="97"><highlight class="comment"></highlight></codeline>
<codeline lineno="98"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>other<sp/>constants</highlight></codeline>
<codeline lineno="99"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>C(50./27.);<sp/>//<sp/>loop<sp/>function<sp/>from<sp/>the<sp/>decay<sp/>of<sp/>the<sp/>Higgs<sp/>boson<sp/>into<sp/>two<sp/>photons</highlight></codeline>
<codeline lineno="100"><highlight class="comment"></highlight></codeline>
<codeline lineno="101"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>Minimum<sp/>finite<sp/>result<sp/>returnable<sp/>from<sp/>log(double<sp/>x);</highlight></codeline>
<codeline lineno="102"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>logmin<sp/>=<sp/>log(std::numeric_limits&lt;double&gt;::min());</highlight></codeline>
<codeline lineno="103"><highlight class="comment"></highlight></codeline>
<codeline lineno="104"><highlight class="comment"></highlight></codeline>
<codeline lineno="105"><highlight class="comment"></highlight></codeline>
<codeline lineno="106"><highlight class="comment"></highlight></codeline>
<codeline lineno="108"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Support<sp/>class<sp/>to<sp/>handle<sp/>Solar<sp/>models<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline lineno="110"><highlight class="comment"></highlight></codeline>
<codeline lineno="111"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>gsl<sp/>error<sp/>handler</highlight></codeline>
<codeline lineno="112"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>handler_Ls<sp/>(const<sp/>char<sp/>*<sp/>reason,<sp/>const<sp/>char<sp/>*<sp/>file,<sp/>int<sp/>line,<sp/>int<sp/>gsl_errno)</highlight></codeline>
<codeline lineno="113"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="114"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(gsl_errno<sp/>==<sp/>15)</highlight></codeline>
<codeline lineno="115"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="116"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>throw<sp/>gsl_errno;</highlight></codeline>
<codeline lineno="117"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="118"><highlight class="comment"></highlight></codeline>
<codeline lineno="119"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(gsl_errno<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="120"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="121"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>&quot;gsl:<sp/>&quot;<sp/>&lt;&lt;<sp/>file<sp/>&lt;&lt;<sp/>&quot;:&quot;<sp/>&lt;&lt;<sp/>line<sp/>&lt;&lt;<sp/>&quot;:<sp/>ERROR:<sp/>&quot;<sp/>&lt;&lt;<sp/>reason<sp/>&lt;&lt;<sp/>&quot;<sp/>and<sp/><sp/>gsl_errno<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>gsl_errno<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline lineno="122"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>&quot;it<sp/>seems<sp/>like<sp/>you<sp/>are<sp/>trying<sp/>to<sp/>scan<sp/>DM<sp/>masses<sp/>&lt;=<sp/>0.5eV,<sp/>solar<sp/>neutrino<sp/>likelihoods<sp/>only<sp/>work<sp/>for<sp/>DM<sp/>masses<sp/>&gt;<sp/>mMin<sp/>=<sp/>0.5eV!&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline lineno="123"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cerr<sp/>&lt;&lt;<sp/>&quot;if<sp/>you<sp/>want<sp/>to<sp/>change<sp/>the<sp/>value<sp/>of<sp/>mMin,<sp/>you<sp/>can<sp/>do<sp/>it<sp/>from<sp/>DarkBit/src/SuperRenormHP.cpp<sp/>and<sp/>recompute<sp/>the<sp/>interpolation<sp/>tables(delete<sp/>the<sp/>existing<sp/>one<sp/>and<sp/>it<sp/>will<sp/>be<sp/>done<sp/>automatically),<sp/>but<sp/>be<sp/>careful<sp/>to<sp/>check<sp/>to<sp/>convergence<sp/>with<sp/>the<sp/>new<sp/>values!<sp/>you<sp/>may<sp/>have<sp/>to<sp/>increase<sp/>the<sp/>number<sp/>of<sp/>points<sp/>in<sp/>the<sp/>interpolation<sp/>routine&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline lineno="124"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="125"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>else<sp/>{<sp/>std::cerr<sp/>&lt;&lt;<sp/>&quot;gsl:<sp/>&quot;<sp/>&lt;&lt;<sp/>file<sp/>&lt;&lt;<sp/>&quot;:&quot;<sp/>&lt;&lt;<sp/>line<sp/>&lt;&lt;<sp/>&quot;:<sp/>ERROR:<sp/>&quot;<sp/>&lt;&lt;<sp/>reason<sp/>&lt;&lt;<sp/>&quot;<sp/>and<sp/><sp/>gsl_errno<sp/>=<sp/>&quot;<sp/>&lt;&lt;<sp/>gsl_errno<sp/>&lt;&lt;<sp/>std::endl;<sp/>abort();<sp/>}</highlight></codeline>
<codeline lineno="126"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="127"><highlight class="comment"></highlight></codeline>
<codeline lineno="128"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>da<sp/>=<sp/>1.66053906660e-24;<sp/>//<sp/>dalton<sp/>to<sp/>g</highlight></codeline>
<codeline lineno="129"><highlight class="comment"></highlight></codeline>
<codeline lineno="130"><highlight class="comment"></highlight></codeline>
<codeline lineno="131"><highlight class="comment"><sp/><sp/><sp/><sp/>class<sp/>StellarModel</highlight></codeline>
<codeline lineno="132"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="133"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>public<sp/>:</highlight></codeline>
<codeline lineno="134"><highlight class="comment"></highlight></codeline>
<codeline lineno="135"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>StellarModel<sp/>(std::string<sp/>datafile);</highlight></codeline>
<codeline lineno="136"><highlight class="comment"></highlight></codeline>
<codeline lineno="137"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>sigmaL<sp/>(double<sp/>const&amp;<sp/>w,<sp/>double<sp/>const&amp;<sp/>r);</highlight></codeline>
<codeline lineno="138"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>getQuantity<sp/>(std::string<sp/>const&amp;<sp/>quantity,<sp/>double<sp/>const&amp;<sp/>r);</highlight></codeline>
<codeline lineno="139"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>L_integrated<sp/>(double<sp/>const&amp;<sp/>mS);</highlight></codeline>
<codeline lineno="140"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void<sp/>Ls_interpolate<sp/>();</highlight></codeline>
<codeline lineno="141"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>Ls<sp/>(double<sp/>const&amp;<sp/>mS,<sp/>double<sp/>const&amp;<sp/>theta);</highlight></codeline>
<codeline lineno="142"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>PhiB8<sp/>(double<sp/>const&amp;<sp/>mS,<sp/>double<sp/>const&amp;<sp/>theta);</highlight></codeline>
<codeline lineno="143"><highlight class="comment"></highlight></codeline>
<codeline lineno="144"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>~StellarModel();</highlight></codeline>
<codeline lineno="145"><highlight class="comment"></highlight></codeline>
<codeline lineno="146"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>private<sp/>:</highlight></codeline>
<codeline lineno="147"><highlight class="comment"></highlight></codeline>
<codeline lineno="148"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>m_nbins;</highlight></codeline>
<codeline lineno="149"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>std::vector&lt;std::string&gt;<sp/>m_names<sp/>=<sp/>{&quot;Mass&quot;,<sp/>&quot;Radius&quot;,<sp/>&quot;Temp&quot;,<sp/>&quot;Rho&quot;,<sp/>&quot;Pres&quot;,<sp/>&quot;Lumi&quot;,<sp/>&quot;H1&quot;,<sp/>&quot;He4&quot;,<sp/>&quot;He3&quot;,<sp/>&quot;C12&quot;,<sp/>&quot;C13&quot;,<sp/>&quot;N14&quot;,<sp/>&quot;N15&quot;,<sp/>&quot;O16&quot;,<sp/>&quot;O17&quot;,<sp/>&quot;O18&quot;,<sp/>&quot;Ne&quot;,<sp/>&quot;Na&quot;,<sp/>&quot;Mg&quot;,<sp/>&quot;Al&quot;,<sp/>&quot;Si&quot;,<sp/>&quot;P&quot;,<sp/>&quot;S&quot;,<sp/>&quot;Cl&quot;,<sp/>&quot;Ar&quot;,<sp/>&quot;K&quot;,<sp/>&quot;Ca&quot;,<sp/>&quot;Sc&quot;,<sp/>&quot;Ti&quot;,<sp/>&quot;V&quot;,<sp/>&quot;Cr&quot;,<sp/>&quot;Mn&quot;,<sp/>&quot;Fe&quot;,<sp/>&quot;Co&quot;,<sp/>&quot;Ni&quot;};</highlight></codeline>
<codeline lineno="150"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>std::vector&lt;std::string&gt;<sp/>m_elements<sp/>=<sp/>{&quot;H1&quot;,<sp/>&quot;He4&quot;,<sp/>&quot;He3&quot;,<sp/>&quot;C12&quot;,<sp/>&quot;C13&quot;,<sp/>&quot;N14&quot;,<sp/>&quot;N15&quot;,<sp/>&quot;O16&quot;,<sp/>&quot;O17&quot;,<sp/>&quot;O18&quot;,<sp/>&quot;Ne&quot;,<sp/>&quot;Na&quot;,<sp/>&quot;Mg&quot;,<sp/>&quot;Al&quot;,<sp/>&quot;Si&quot;,<sp/>&quot;P&quot;,<sp/>&quot;S&quot;,<sp/>&quot;Cl&quot;,<sp/>&quot;Ar&quot;,<sp/>&quot;K&quot;,<sp/>&quot;Ca&quot;,<sp/>&quot;Sc&quot;,<sp/>&quot;Ti&quot;,<sp/>&quot;V&quot;,<sp/>&quot;Cr&quot;,<sp/>&quot;Mn&quot;,<sp/>&quot;Fe&quot;,<sp/>&quot;Co&quot;,<sp/>&quot;Ni&quot;};</highlight></codeline>
<codeline lineno="151"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Ionisation<sp/>of<sp/>species<sp/>i<sp/>assuming<sp/>full<sp/>ionisation.</highlight></codeline>
<codeline lineno="152"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>std::vector&lt;double&gt;<sp/>m_Z<sp/>=<sp/>{1.0,<sp/>2.0,<sp/>2.0,<sp/>6.0,<sp/>6.0,<sp/>7.0,<sp/>7.0,<sp/>8.0,<sp/>8.0,<sp/>8.0,<sp/>10.0,<sp/>11.0,<sp/>12.0,<sp/>13.0,<sp/>14.0,<sp/>15.0,<sp/>16.0,<sp/>17.0,<sp/>18.0,<sp/>19.0,<sp/>20.0,<sp/>21.0,<sp/>22.0,<sp/>23.0,<sp/>24.0,<sp/>25.0,<sp/>26.0,<sp/>27.0,<sp/>28.0};</highlight></codeline>
<codeline lineno="153"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Atomic<sp/>weight<sp/>of<sp/>species<sp/>i<sp/>(exact<sp/>weight<sp/>if<sp/>isotope<sp/>is<sp/>known<sp/>OR<sp/>estimate<sp/>from<sp/>average<sp/>solar<sp/>abundance<sp/>from<sp/>data<sp/>if<sp/>available<sp/>OR<sp/>estimate<sp/>from<sp/>natural<sp/>terrestrial<sp/>abundance).</highlight></codeline>
<codeline lineno="154"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>std::vector&lt;double&gt;<sp/>m_A<sp/>=<sp/>{1.007825,<sp/>4.002603,<sp/>3.016029,<sp/>12.000000,<sp/>13.003355,<sp/>14.003074,<sp/>15.000109,<sp/>15.994915,<sp/>16.999132,<sp/>17.999160,<sp/>20.1312812,<sp/>22.989769,<sp/>24.3055,<sp/>26.9815385,<sp/>28.085,<sp/>30.973762,<sp/>32.0675,<sp/>35.4515,<sp/>36.275403,<sp/>39.0983,<sp/>40.078,<sp/>44.955908,<sp/>47.867,<sp/>50.9415,<sp/>51.9961,<sp/>54.938044,<sp/>55.845,<sp/>58.933194,<sp/>58.6934};</highlight></codeline>
<codeline lineno="155"><highlight class="comment"></highlight></codeline>
<codeline lineno="156"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ASCIItableReader<sp/>m_model;</highlight></codeline>
<codeline lineno="157"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::map&lt;std::string,<sp/>gsl_spline*&gt;<sp/>m_interp;</highlight></codeline>
<codeline lineno="158"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::map&lt;std::string,<sp/>gsl_interp_accel*&gt;<sp/>m_acc;</highlight></codeline>
<codeline lineno="159"><highlight class="comment"></highlight></codeline>
<codeline lineno="160"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gsl_spline<sp/>*<sp/>m_Ls_interp;</highlight></codeline>
<codeline lineno="161"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gsl_interp_accel<sp/>*<sp/>m_Ls_accel;</highlight></codeline>
<codeline lineno="162"><highlight class="comment"></highlight></codeline>
<codeline lineno="163"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>std::vector&lt;std::string&gt;<sp/>m_quantities<sp/>=<sp/>{&quot;Temp&quot;,<sp/>&quot;wp&quot;,<sp/>&quot;ne&quot;,<sp/>&quot;SumNz&quot;};</highlight></codeline>
<codeline lineno="164"><highlight class="comment"></highlight></codeline>
<codeline lineno="165"><highlight class="comment"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="166"><highlight class="comment"></highlight></codeline>
<codeline lineno="167"><highlight class="comment"><sp/><sp/><sp/><sp/>StellarModel::StellarModel<sp/>(std::string<sp/>datafile)</highlight></codeline>
<codeline lineno="168"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="169"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>m_model<sp/>=<sp/>ASCIItableReader(datafile);</highlight></codeline>
<codeline lineno="170"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>m_model.setcolnames(m_names);</highlight></codeline>
<codeline lineno="171"><highlight class="comment"></highlight></codeline>
<codeline lineno="172"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>m_nbins<sp/>=<sp/>m_model[&quot;Mass&quot;].size();</highlight></codeline>
<codeline lineno="173"><highlight class="comment"></highlight></codeline>
<codeline lineno="174"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;double&gt;<sp/>T,<sp/>wp,<sp/>ne,<sp/>SumNz;</highlight></codeline>
<codeline lineno="175"><highlight class="comment"></highlight></codeline>
<codeline lineno="176"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>sumz,<sp/>temp,<sp/>sumz2;</highlight></codeline>
<codeline lineno="177"><highlight class="comment"></highlight></codeline>
<codeline lineno="178"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;m_nbins;<sp/>++i)</highlight></codeline>
<codeline lineno="179"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="180"><highlight class="comment"></highlight></codeline>
<codeline lineno="181"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sumz<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="182"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sumz2<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="183"><highlight class="comment"></highlight></codeline>
<codeline lineno="184"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>j=0;<sp/>j&lt;m_elements.size();<sp/>++j)</highlight></codeline>
<codeline lineno="185"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="186"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sumz<sp/>+=<sp/>m_Z[j]*m_model[m_elements[j]][i]/m_A[j]/da*m_model[&quot;Rho&quot;][i];</highlight></codeline>
<codeline lineno="187"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sumz2<sp/>+=<sp/>m_Z[j]*m_Z[j]*m_model[m_elements[j]][i]/m_A[j]/da*m_model[&quot;Rho&quot;][i];</highlight></codeline>
<codeline lineno="188"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="189"><highlight class="comment"></highlight></codeline>
<codeline lineno="190"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp<sp/>=<sp/>m_model[&quot;Temp&quot;][i]*kb;</highlight></codeline>
<codeline lineno="191"><highlight class="comment"></highlight></codeline>
<codeline lineno="192"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T.push_back(temp);</highlight></codeline>
<codeline lineno="193"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wp.push_back(sqrt(4*pi*alphaEM*sumz*cs*cs*cs*hbar_eV*hbar_eV*hbar_eV/me));</highlight></codeline>
<codeline lineno="194"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ne.push_back(sumz);</highlight></codeline>
<codeline lineno="195"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SumNz.push_back(sumz2);</highlight></codeline>
<codeline lineno="196"><highlight class="comment"></highlight></codeline>
<codeline lineno="197"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="198"><highlight class="comment"></highlight></codeline>
<codeline lineno="199"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>std::map&lt;std::string,<sp/>std::vector&lt;double&gt;&gt;<sp/>quantities;</highlight></codeline>
<codeline lineno="200"><highlight class="comment"></highlight></codeline>
<codeline lineno="201"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>quantities[&quot;Temp&quot;]<sp/>=<sp/>T;</highlight></codeline>
<codeline lineno="202"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>quantities[&quot;wp&quot;]<sp/>=<sp/>wp;</highlight></codeline>
<codeline lineno="203"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>quantities[&quot;ne&quot;]<sp/>=<sp/>ne;</highlight></codeline>
<codeline lineno="204"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>quantities[&quot;SumNz&quot;]<sp/>=<sp/>SumNz;</highlight></codeline>
<codeline lineno="205"><highlight class="comment"></highlight></codeline>
<codeline lineno="206"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>*<sp/>rr<sp/>=<sp/>m_model[&quot;Radius&quot;].data();</highlight></codeline>
<codeline lineno="207"><highlight class="comment"></highlight></codeline>
<codeline lineno="208"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(auto<sp/>it=m_quantities.begin();<sp/>it!=m_quantities.end();<sp/>++it)</highlight></codeline>
<codeline lineno="209"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="210"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_interp[*it]<sp/>=<sp/>gsl_spline_alloc(gsl_interp_cspline,<sp/>m_nbins);</highlight></codeline>
<codeline lineno="211"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_acc[*it]<sp/>=<sp/>gsl_interp_accel_alloc();</highlight></codeline>
<codeline lineno="212"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gsl_spline_init(m_interp[*it],<sp/>rr,<sp/>quantities[*it].data(),<sp/>m_nbins);</highlight></codeline>
<codeline lineno="213"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="214"><highlight class="comment"></highlight></codeline>
<codeline lineno="215"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>Ls_interpolate();</highlight></codeline>
<codeline lineno="216"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="217"><highlight class="comment"></highlight></codeline>
<codeline lineno="218"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>function<sp/>returning<sp/>the<sp/>interpolated<sp/>quantities<sp/>(Temp,<sp/>wp,<sp/>ne<sp/>SumNz)<sp/>at<sp/>a<sp/>given<sp/>radius<sp/>r<sp/>inside<sp/>the<sp/>Sun</highlight></codeline>
<codeline lineno="219"><highlight class="comment"><sp/><sp/><sp/><sp/>double<sp/>StellarModel::getQuantity<sp/>(std::string<sp/>const&amp;<sp/>quantity,<sp/>double<sp/>const&amp;<sp/>r)</highlight></codeline>
<codeline lineno="220"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="221"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>gsl_spline_eval(m_interp[quantity],<sp/>r,<sp/>m_acc[quantity]);</highlight></codeline>
<codeline lineno="222"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="223"><highlight class="comment"></highlight></codeline>
<codeline lineno="224"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>function<sp/>to<sp/>compute<sp/>the<sp/>damping<sp/>rate<sp/>of<sp/>longitudinal<sp/>photons<sp/>inside<sp/>the<sp/>Sun<sp/>(inverse<sp/>bremsstrahlung)</highlight></codeline>
<codeline lineno="225"><highlight class="comment"><sp/><sp/><sp/><sp/>double<sp/>StellarModel::sigmaL<sp/>(double<sp/>const&amp;<sp/>w,<sp/>double<sp/>const&amp;<sp/>r)</highlight></codeline>
<codeline lineno="226"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="227"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>result<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="228"><highlight class="comment"></highlight></codeline>
<codeline lineno="229"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>temp<sp/>=<sp/>getQuantity(&quot;Temp&quot;,<sp/>r),<sp/>ne<sp/>=<sp/>getQuantity(&quot;ne&quot;,<sp/>r),<sp/>wp<sp/>=<sp/>getQuantity(&quot;wp&quot;,<sp/>r);</highlight></codeline>
<codeline lineno="230"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>D<sp/>=<sp/>64*pow(pi,<sp/>2)*pow(alphaEM,<sp/>3)*ne*getQuantity(&quot;SumNz&quot;,<sp/>r);</highlight></codeline>
<codeline lineno="231"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>N<sp/>=<sp/>3*sqrt(2*pi*temp)*pow(me,<sp/>3./2.)*pow(w,<sp/>3);</highlight></codeline>
<codeline lineno="232"><highlight class="comment"></highlight></codeline>
<codeline lineno="233"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>x<sp/>=<sp/>w/2./temp;</highlight></codeline>
<codeline lineno="234"><highlight class="comment"></highlight></codeline>
<codeline lineno="235"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>tries<sp/>to<sp/>use<sp/>the<sp/>gsl_sf_bessel_K0<sp/>and<sp/>sinh<sp/>functions<sp/>(fails<sp/>if<sp/>x<sp/>is<sp/>too<sp/>big)</highlight></codeline>
<codeline lineno="236"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>try</highlight></codeline>
<codeline lineno="237"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="238"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>F<sp/>=<sp/>gsl_sf_bessel_K0(x)*sinh(x);</highlight></codeline>
<codeline lineno="239"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>+=<sp/>D/N*F*pow(cs,<sp/>6)*pow(hbar_eV,<sp/>6);</highlight></codeline>
<codeline lineno="240"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="241"><highlight class="comment"></highlight></codeline>
<codeline lineno="242"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>uses<sp/>a<sp/>first<sp/>order<sp/>development<sp/>at<sp/>high<sp/>x<sp/>instead<sp/>of<sp/>the<sp/>full<sp/>functions</highlight></codeline>
<codeline lineno="243"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>catch<sp/>(int<sp/>gsl_errno)</highlight></codeline>
<codeline lineno="244"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="245"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>F<sp/>=<sp/>sqrt(pi/2./x)*(1-(1/8./x));</highlight></codeline>
<codeline lineno="246"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>+=<sp/>D/N*F*pow(cs,<sp/>6)*pow(hbar_eV,<sp/>6);</highlight></codeline>
<codeline lineno="247"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="248"><highlight class="comment"></highlight></codeline>
<codeline lineno="249"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(w<sp/>&gt;<sp/>wp)<sp/>{<sp/>result<sp/>+=<sp/>8*pi*pow(alphaEM,<sp/>2)*ne*sqrt(1-pow(wp/w,<sp/>2))/pow(me,<sp/>3)/3.*pow(cs,<sp/>3)*pow(hbar_eV,<sp/>3);<sp/>}</highlight></codeline>
<codeline lineno="250"><highlight class="comment"></highlight></codeline>
<codeline lineno="251"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>result;</highlight></codeline>
<codeline lineno="252"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="253"><highlight class="comment"></highlight></codeline>
<codeline lineno="254"><highlight class="comment"><sp/><sp/><sp/><sp/>StellarModel::~StellarModel()</highlight></codeline>
<codeline lineno="255"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="256"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(auto<sp/>it=m_quantities.begin();<sp/>it!=m_quantities.end();<sp/>++it)</highlight></codeline>
<codeline lineno="257"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="258"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gsl_spline_free<sp/>(m_interp[*it]);</highlight></codeline>
<codeline lineno="259"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gsl_interp_accel_free(m_acc[*it]);</highlight></codeline>
<codeline lineno="260"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="261"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="262"><highlight class="comment"></highlight></codeline>
<codeline lineno="263"><highlight class="comment"><sp/><sp/><sp/><sp/>struct<sp/>my_f_params<sp/>{<sp/>double<sp/>mS;<sp/>StellarModel<sp/>*model;<sp/>};</highlight></codeline>
<codeline lineno="264"><highlight class="comment"></highlight></codeline>
<codeline lineno="265"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>function<sp/>to<sp/>be<sp/>integrated<sp/>for<sp/>mS<sp/>&lt;<sp/>w<sp/>&lt;<sp/>inf<sp/>and<sp/>0<sp/>&lt;<sp/>r<sp/>&lt;<sp/>R0</highlight></codeline>
<codeline lineno="266"><highlight class="comment"><sp/><sp/><sp/><sp/>double<sp/>myF<sp/>(double<sp/>const&amp;<sp/>w,<sp/>double<sp/>const&amp;<sp/>r,<sp/>my_f_params<sp/>*params)</highlight></codeline>
<codeline lineno="267"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="268"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>StellarModel<sp/>*model<sp/>=<sp/>params-&gt;model;</highlight></codeline>
<codeline lineno="269"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>mS<sp/>=<sp/>params-&gt;mS;</highlight></codeline>
<codeline lineno="270"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>N1,<sp/>N2,<sp/>D1,<sp/>D2,<sp/>D3;</highlight></codeline>
<codeline lineno="271"><highlight class="comment"></highlight></codeline>
<codeline lineno="272"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>N1<sp/>=<sp/>pow((w*w-mS*mS),<sp/>3./2.)*w*w;</highlight></codeline>
<codeline lineno="273"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>N2<sp/>=<sp/>w*w*model-&gt;sigmaL(w,<sp/>r);</highlight></codeline>
<codeline lineno="274"><highlight class="comment"></highlight></codeline>
<codeline lineno="275"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>D1<sp/>=<sp/>pow(2*pi,<sp/>3)*alphaEM;</highlight></codeline>
<codeline lineno="276"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>D2<sp/>=<sp/>exp(w/model-&gt;getQuantity(&quot;Temp&quot;,<sp/>r))-1;</highlight></codeline>
<codeline lineno="277"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>D3<sp/>=<sp/>pow(w*model-&gt;sigmaL(w,<sp/>r),<sp/>2)+pow(w*w-pow(model-&gt;getQuantity(&quot;wp&quot;,<sp/>r),<sp/>2),<sp/>2);</highlight></codeline>
<codeline lineno="278"><highlight class="comment"></highlight></codeline>
<codeline lineno="279"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>N1*N2*pow(r,<sp/>2)/D1/D2/D3;</highlight></codeline>
<codeline lineno="280"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="281"><highlight class="comment"></highlight></codeline>
<codeline lineno="282"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>gsl<sp/>integrand<sp/>remapped<sp/>from<sp/>(ms,<sp/>+infinity)<sp/>to<sp/>(0,<sp/>1)</highlight></codeline>
<codeline lineno="283"><highlight class="comment"><sp/><sp/><sp/><sp/>double<sp/>integrand<sp/>(double<sp/>x[],<sp/>size_t<sp/>dim,<sp/>void<sp/>*p)</highlight></codeline>
<codeline lineno="284"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="285"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>struct<sp/>my_f_params<sp/>*params<sp/>=<sp/>(struct<sp/>my_f_params<sp/>*)p;</highlight></codeline>
<codeline lineno="286"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>(void)(dim);</highlight></codeline>
<codeline lineno="287"><highlight class="comment"></highlight></codeline>
<codeline lineno="288"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>mS<sp/>=<sp/>params-&gt;mS;</highlight></codeline>
<codeline lineno="289"><highlight class="comment"></highlight></codeline>
<codeline lineno="290"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>t<sp/>=<sp/>x[0],<sp/>r<sp/>=<sp/>x[1];</highlight></codeline>
<codeline lineno="291"><highlight class="comment"></highlight></codeline>
<codeline lineno="292"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>myF(mS<sp/>+<sp/>(1-t)/t,<sp/>r,<sp/>params)/pow(t,<sp/>2);</highlight></codeline>
<codeline lineno="293"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="294"><highlight class="comment"></highlight></codeline>
<codeline lineno="295"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>mSmax<sp/>=<sp/>1e5;<sp/>//<sp/>maximum<sp/>mass<sp/>up<sp/>to<sp/>which<sp/>Ls<sp/>is<sp/>computed,<sp/>for<sp/>higher<sp/>masses<sp/>Ls<sp/>is<sp/>set<sp/>to<sp/>zero<sp/>manually<sp/>in<sp/>the<sp/>capability<sp/>function</highlight></codeline>
<codeline lineno="296"><highlight class="comment"></highlight></codeline>
<codeline lineno="297"><highlight class="comment"><sp/><sp/><sp/><sp/>double<sp/>StellarModel::L_integrated<sp/>(double<sp/>const&amp;<sp/>mS)</highlight></codeline>
<codeline lineno="298"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="299"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>size_t<sp/>dim<sp/>=<sp/>2,<sp/>calls<sp/>=<sp/>1e5;</highlight></codeline>
<codeline lineno="300"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/><sp/>xl[dim]<sp/>=<sp/>{0,<sp/>0.0006},<sp/>xu[dim]<sp/>=<sp/>{1,<sp/>0.9995};</highlight></codeline>
<codeline lineno="301"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>result,<sp/>abserr;</highlight></codeline>
<codeline lineno="302"><highlight class="comment"></highlight></codeline>
<codeline lineno="303"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>gsl_monte_vegas_state<sp/>*s<sp/>=<sp/>gsl_monte_vegas_alloc(dim);</highlight></codeline>
<codeline lineno="304"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>gsl_monte_vegas_init(s);</highlight></codeline>
<codeline lineno="305"><highlight class="comment"></highlight></codeline>
<codeline lineno="306"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>gsl_rng<sp/>*r<sp/>=<sp/>gsl_rng_alloc(gsl_rng_taus2);</highlight></codeline>
<codeline lineno="307"><highlight class="comment"></highlight></codeline>
<codeline lineno="308"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>gsl_monte_function<sp/>F;</highlight></codeline>
<codeline lineno="309"><highlight class="comment"></highlight></codeline>
<codeline lineno="310"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>my_f_params<sp/>params<sp/>=<sp/>{mS,<sp/>this};</highlight></codeline>
<codeline lineno="311"><highlight class="comment"></highlight></codeline>
<codeline lineno="312"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>F.f<sp/>=<sp/>&amp;integrand;</highlight></codeline>
<codeline lineno="313"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>F.dim<sp/>=<sp/>dim;</highlight></codeline>
<codeline lineno="314"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>F.params<sp/>=<sp/>&amp;params;</highlight></codeline>
<codeline lineno="315"><highlight class="comment"></highlight></codeline>
<codeline lineno="316"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>gsl_monte_vegas_integrate(&amp;F,<sp/>xl,<sp/>xu,<sp/>dim,<sp/>1e4,<sp/>r,<sp/>s,<sp/>&amp;result,<sp/>&amp;abserr);</highlight></codeline>
<codeline lineno="317"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>do</highlight></codeline>
<codeline lineno="318"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="319"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gsl_monte_vegas_integrate<sp/>(&amp;F,<sp/>xl,<sp/>xu,<sp/>dim,<sp/>calls,<sp/>r,<sp/>s,</highlight></codeline>
<codeline lineno="320"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;result,<sp/>&amp;abserr);</highlight></codeline>
<codeline lineno="321"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>mS<sp/>&lt;&lt;<sp/>&quot;<sp/>&quot;<sp/>&lt;&lt;<sp/>result<sp/>&lt;&lt;<sp/>&quot;<sp/>&quot;<sp/>&lt;&lt;<sp/>abserr/result<sp/>&lt;&lt;<sp/>&quot;<sp/>&quot;<sp/>&lt;&lt;<sp/>gsl_monte_vegas_chisq<sp/>(s)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline lineno="322"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="323"><highlight class="comment"><sp/><sp/><sp/><sp/>while<sp/>(<sp/>(fabs<sp/>(gsl_monte_vegas_chisq<sp/>(s)<sp/>-<sp/>1.0)<sp/>&gt;<sp/>0.2)<sp/>or<sp/>(abserr/result<sp/>&gt;<sp/>1e-3));</highlight></codeline>
<codeline lineno="324"><highlight class="comment"></highlight></codeline>
<codeline lineno="325"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;Final:<sp/>&quot;<sp/>&lt;&lt;<sp/>mS<sp/>&lt;&lt;<sp/>&quot;<sp/>&quot;<sp/>&lt;&lt;<sp/>result<sp/>&lt;&lt;<sp/>&quot;<sp/>&quot;<sp/>&lt;&lt;<sp/>abserr/result<sp/>&lt;&lt;<sp/>&quot;<sp/>&quot;<sp/>&lt;&lt;<sp/>gsl_monte_vegas_chisq<sp/>(s)<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline lineno="326"><highlight class="comment"></highlight></codeline>
<codeline lineno="327"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>gsl_monte_vegas_free(s);</highlight></codeline>
<codeline lineno="328"><highlight class="comment"></highlight></codeline>
<codeline lineno="329"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>4*pi*pow(Rsun,<sp/>3)*result/pow(cs,<sp/>3)/pow(hbar_eV,<sp/>4);</highlight></codeline>
<codeline lineno="330"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="331"><highlight class="comment"></highlight></codeline>
<codeline lineno="332"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>StellarModel::Ls_interpolate<sp/>()</highlight></codeline>
<codeline lineno="333"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="334"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int<sp/>nPoints<sp/>=<sp/>100;</highlight></codeline>
<codeline lineno="335"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>mMin<sp/>=<sp/>5e-4,<sp/>mMax<sp/>=<sp/>mSmax;</highlight></codeline>
<codeline lineno="336"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>deltaM<sp/>=<sp/>log10(mMax/mMin)/nPoints;</highlight></codeline>
<codeline lineno="337"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>std::string<sp/>filename<sp/>=<sp/>GAMBIT_DIR<sp/>&quot;/DarkBit/data/SuperRenormHP_Ls.dat&quot;;</highlight></codeline>
<codeline lineno="338"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;double&gt;<sp/>mS,<sp/>Ls;</highlight></codeline>
<codeline lineno="339"><highlight class="comment"></highlight></codeline>
<codeline lineno="340"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>checks<sp/>if<sp/>an<sp/>interpolation<sp/>table<sp/>file<sp/>for<sp/>Ls<sp/>already<sp/>exists<sp/>and<sp/>reads<sp/>it<sp/>if<sp/>that<sp/>is<sp/>the<sp/>case</highlight></codeline>
<codeline lineno="341"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(Utils::file_exists(filename))</highlight></codeline>
<codeline lineno="342"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="343"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ASCIItableReader<sp/>table<sp/>=<sp/>ASCIItableReader(filename);</highlight></codeline>
<codeline lineno="344"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>table.setcolnames({&quot;mS&quot;,<sp/>&quot;Ls&quot;});</highlight></codeline>
<codeline lineno="345"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mS<sp/>=<sp/>table[&quot;mS&quot;];</highlight></codeline>
<codeline lineno="346"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ls<sp/>=<sp/>table[&quot;Ls&quot;];</highlight></codeline>
<codeline lineno="347"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="348"><highlight class="comment"></highlight></codeline>
<codeline lineno="349"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>builds<sp/>an<sp/>interpolation<sp/>table<sp/>for<sp/>Ls<sp/>and<sp/>writes<sp/>it<sp/>in<sp/>a<sp/>file</highlight></codeline>
<codeline lineno="350"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline lineno="351"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="352"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i=0;<sp/>i&lt;=nPoints;<sp/>++i)</highlight></codeline>
<codeline lineno="353"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="354"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mS.push_back(mMin*pow(10,<sp/>deltaM*i));</highlight></codeline>
<codeline lineno="355"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="356"><highlight class="comment"></highlight></codeline>
<codeline lineno="357"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(auto<sp/>it=mS.begin();<sp/>it!=mS.end();<sp/>++it)</highlight></codeline>
<codeline lineno="358"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="359"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ls.push_back(L_integrated(*it));</highlight></codeline>
<codeline lineno="360"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="361"><highlight class="comment"></highlight></codeline>
<codeline lineno="362"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::ofstream<sp/>fout<sp/>(filename.c_str());</highlight></codeline>
<codeline lineno="363"><highlight class="comment"></highlight></codeline>
<codeline lineno="364"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i=0;<sp/>i&lt;mS.size();<sp/>++i)</highlight></codeline>
<codeline lineno="365"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="366"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fout<sp/>&lt;&lt;<sp/>mS[i]<sp/>&lt;&lt;<sp/>&quot;<sp/><sp/>&quot;<sp/>&lt;&lt;<sp/>Ls[i]<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline lineno="367"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="368"><highlight class="comment"></highlight></codeline>
<codeline lineno="369"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fout.clear();<sp/>fout.close();</highlight></codeline>
<codeline lineno="370"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="371"><highlight class="comment"></highlight></codeline>
<codeline lineno="372"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>interpolates<sp/>Ls<sp/>from<sp/>the<sp/>interpolation<sp/>table</highlight></codeline>
<codeline lineno="373"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>m_Ls_interp<sp/>=<sp/>gsl_spline_alloc(gsl_interp_cspline,<sp/>nPoints+1);</highlight></codeline>
<codeline lineno="374"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>m_Ls_accel<sp/>=<sp/>gsl_interp_accel_alloc();</highlight></codeline>
<codeline lineno="375"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>gsl_spline_init(m_Ls_interp,<sp/>mS.data(),<sp/>Ls.data(),<sp/>nPoints+1);</highlight></codeline>
<codeline lineno="376"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="377"><highlight class="comment"></highlight></codeline>
<codeline lineno="378"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>returns<sp/>the<sp/>value<sp/>of<sp/>the<sp/>interpolated<sp/>Ls<sp/>for<sp/>a<sp/>given<sp/>set<sp/>of<sp/>parameters<sp/>(mS,<sp/>theta)</highlight></codeline>
<codeline lineno="379"><highlight class="comment"><sp/><sp/><sp/><sp/>double<sp/>StellarModel::Ls<sp/>(double<sp/>const&amp;<sp/>mS,<sp/>double<sp/>const&amp;<sp/>theta)</highlight></codeline>
<codeline lineno="380"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="381"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>gsl_spline_eval(m_Ls_interp,<sp/>mS,<sp/>m_Ls_accel)*pow(me/v*theta,<sp/>2);</highlight></codeline>
<codeline lineno="382"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="383"><highlight class="comment"></highlight></codeline>
<codeline lineno="385"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Capability<sp/>functions<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//</highlight></codeline>
<codeline lineno="387"><highlight class="comment"></highlight></codeline>
<codeline lineno="388"><highlight class="comment"><sp/><sp/><sp/><sp/>//-------------<sp/>Process<sp/>catalogue<sp/>-------------//</highlight></codeline>
<codeline lineno="389"><highlight class="comment"></highlight></codeline>
<codeline lineno="390"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>TH_ProcessCatalog_SuperRenormHP(DarkBit::TH_ProcessCatalog<sp/>&amp;result)</highlight></codeline>
<codeline lineno="391"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="392"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::TH_ProcessCatalog_SuperRenormHP;</highlight></codeline>
<codeline lineno="393"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>std::vector;</highlight></codeline>
<codeline lineno="394"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>std::string;</highlight></codeline>
<codeline lineno="395"><highlight class="comment"></highlight></codeline>
<codeline lineno="396"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Initialize<sp/>empty<sp/>catalog<sp/>and<sp/>decay<sp/>channel</highlight></codeline>
<codeline lineno="397"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>TH_ProcessCatalog<sp/>catalog;</highlight></codeline>
<codeline lineno="398"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>TH_Process<sp/>process_dec(&quot;S&quot;);</highlight></codeline>
<codeline lineno="399"><highlight class="comment"></highlight></codeline>
<codeline lineno="401"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Import<sp/>particle<sp/>masses<sp/>and<sp/>couplings</highlight></codeline>
<codeline lineno="403"><highlight class="comment"></highlight></codeline>
<codeline lineno="404"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Convenience<sp/>macros</highlight></codeline>
<codeline lineno="405"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>getSMmass(Name,<sp/>spinX2)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline lineno="406"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catalog.particleProperties.insert(std::pair&lt;string,<sp/>TH_ParticleProperty&gt;<sp/>\</highlight></codeline>
<codeline lineno="407"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(Name<sp/>,<sp/>TH_ParticleProperty(SM.get(Par::Pole_Mass,Name),<sp/>spinX2)));</highlight></codeline>
<codeline lineno="408"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>addParticle(Name,<sp/>Mass,<sp/>spinX2)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline lineno="409"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>catalog.particleProperties.insert(std::pair&lt;string,<sp/>TH_ParticleProperty&gt;<sp/>\</highlight></codeline>
<codeline lineno="410"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(Name<sp/>,<sp/>TH_ParticleProperty(Mass,<sp/>spinX2)));</highlight></codeline>
<codeline lineno="411"><highlight class="comment"></highlight></codeline>
<codeline lineno="412"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Import<sp/>Spectrum<sp/>objects</highlight></codeline>
<codeline lineno="413"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Spectrum&amp;<sp/>spec<sp/><sp/>=<sp/>*Dep::SuperRenormHP_spectrum;</highlight></codeline>
<codeline lineno="414"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>SubSpectrum&amp;<sp/>he<sp/>=<sp/>spec.get_HE();</highlight></codeline>
<codeline lineno="415"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>SubSpectrum&amp;<sp/>SM<sp/>=<sp/>spec.get_LE();</highlight></codeline>
<codeline lineno="416"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>SMInputs&amp;<sp/>SMI<sp/><sp/><sp/>=<sp/>spec.get_SMInputs();</highlight></codeline>
<codeline lineno="417"><highlight class="comment"></highlight></codeline>
<codeline lineno="418"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Import<sp/>couplings</highlight></codeline>
<codeline lineno="419"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>theta<sp/>=<sp/>he.get(Par::dimensionless,<sp/>&quot;theta&quot;);</highlight></codeline>
<codeline lineno="420"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>vev<sp/>=<sp/>he.get(Par::mass1,&quot;vev&quot;);</highlight></codeline>
<codeline lineno="421"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>C<sp/>=<sp/>50./27.;<sp/>//<sp/>loop<sp/>factor<sp/>for<sp/>the<sp/>decay<sp/>into<sp/>two<sp/>photons</highlight></codeline>
<codeline lineno="422"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>alpha<sp/>=<sp/>1./SMI.alphainv;<sp/>//<sp/>alpha_EM(mZ)^MSbar<sp/>(5<sp/>active<sp/>flavours)</highlight></codeline>
<codeline lineno="423"><highlight class="comment"></highlight></codeline>
<codeline lineno="424"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Get<sp/>SM<sp/>pole<sp/>masses</highlight></codeline>
<codeline lineno="425"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;e-_1&quot;,<sp/><sp/><sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="426"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;e+_1&quot;,<sp/><sp/><sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="427"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;e-_2&quot;,<sp/><sp/><sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="428"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;e+_2&quot;,<sp/><sp/><sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="429"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;e-_3&quot;,<sp/><sp/><sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="430"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;e+_3&quot;,<sp/><sp/><sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="431"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;Z0&quot;,<sp/><sp/><sp/><sp/><sp/>2)</highlight></codeline>
<codeline lineno="432"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;W+&quot;,<sp/><sp/><sp/><sp/><sp/>2)</highlight></codeline>
<codeline lineno="433"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;W-&quot;,<sp/><sp/><sp/><sp/><sp/>2)</highlight></codeline>
<codeline lineno="434"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;g&quot;,<sp/><sp/><sp/><sp/><sp/><sp/>2)</highlight></codeline>
<codeline lineno="435"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;gamma&quot;,<sp/><sp/>2)</highlight></codeline>
<codeline lineno="436"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;u_3&quot;,<sp/><sp/><sp/><sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="437"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;ubar_3&quot;,<sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="438"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;d_3&quot;,<sp/><sp/><sp/><sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="439"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>getSMmass(&quot;dbar_3&quot;,<sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="440"><highlight class="comment"></highlight></codeline>
<codeline lineno="441"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Pole<sp/>masses<sp/>not<sp/>available<sp/>for<sp/>the<sp/>light<sp/>quarks.</highlight></codeline>
<codeline lineno="442"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;u_1&quot;<sp/><sp/><sp/>,<sp/>SMI.mU,<sp/><sp/>1)<sp/>//<sp/>mu(2<sp/>GeV)^MS-bar,<sp/>not<sp/>pole<sp/>mass</highlight></codeline>
<codeline lineno="443"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;ubar_1&quot;,<sp/>SMI.mU,<sp/><sp/>1)<sp/>//<sp/>mu(2<sp/>GeV)^MS-bar,<sp/>not<sp/>pole<sp/>mass</highlight></codeline>
<codeline lineno="444"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;d_1&quot;<sp/><sp/><sp/>,<sp/>SMI.mD,<sp/><sp/>1)<sp/>//<sp/>md(2<sp/>GeV)^MS-bar,<sp/>not<sp/>pole<sp/>mass</highlight></codeline>
<codeline lineno="445"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;dbar_1&quot;,<sp/>SMI.mD,<sp/><sp/>1)<sp/>//<sp/>md(2<sp/>GeV)^MS-bar,<sp/>not<sp/>pole<sp/>mass</highlight></codeline>
<codeline lineno="446"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;u_2&quot;<sp/><sp/><sp/>,<sp/>SMI.mCmC,1)<sp/>//<sp/>mc(mc)^MS-bar,<sp/>not<sp/>pole<sp/>mass</highlight></codeline>
<codeline lineno="447"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;ubar_2&quot;,<sp/>SMI.mCmC,1)<sp/>//<sp/>mc(mc)^MS-bar,<sp/>not<sp/>pole<sp/>mass</highlight></codeline>
<codeline lineno="448"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;d_2&quot;<sp/><sp/><sp/>,<sp/>SMI.mS,<sp/><sp/>1)<sp/>//<sp/>ms(2<sp/>GeV)^MS-bar,<sp/>not<sp/>pole<sp/>mass</highlight></codeline>
<codeline lineno="449"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;dbar_2&quot;,<sp/>SMI.mS,<sp/><sp/>1)<sp/>//<sp/>ms(2<sp/>GeV)^MS-bar,<sp/>not<sp/>pole<sp/>mass</highlight></codeline>
<codeline lineno="450"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>double<sp/>alpha_s<sp/>=<sp/>SMI.alphaS;<sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>alpha_s(mZ)^MSbar</highlight></codeline>
<codeline lineno="451"><highlight class="comment"></highlight></codeline>
<codeline lineno="452"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Masses<sp/>for<sp/>neutrino<sp/>flavour<sp/>eigenstates.<sp/>Set<sp/>to<sp/>zero.</highlight></codeline>
<codeline lineno="453"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>(presently<sp/>not<sp/>required)</highlight></codeline>
<codeline lineno="454"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;nu_e&quot;,<sp/><sp/><sp/><sp/><sp/>0.0,<sp/>1)</highlight></codeline>
<codeline lineno="455"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;nubar_e&quot;,<sp/><sp/>0.0,<sp/>1)</highlight></codeline>
<codeline lineno="456"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;nu_mu&quot;,<sp/><sp/><sp/><sp/>0.0,<sp/>1)</highlight></codeline>
<codeline lineno="457"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;nubar_mu&quot;,<sp/>0.0,<sp/>1)</highlight></codeline>
<codeline lineno="458"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;nu_tau&quot;,<sp/><sp/><sp/>0.0,<sp/>1)</highlight></codeline>
<codeline lineno="459"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;nubar_tau&quot;,0.0,<sp/>1)</highlight></codeline>
<codeline lineno="460"><highlight class="comment"></highlight></codeline>
<codeline lineno="461"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Higgs-sector<sp/>masses</highlight></codeline>
<codeline lineno="462"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>mS<sp/>=<sp/>spec.get(Par::Pole_Mass,&quot;S&quot;);</highlight></codeline>
<codeline lineno="463"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>mH<sp/>=<sp/>spec.get(Par::Pole_Mass,&quot;h0_1&quot;);</highlight></codeline>
<codeline lineno="464"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;S&quot;,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mS,<sp/>0)<sp/><sp/>//<sp/>Scalar<sp/>DM</highlight></codeline>
<codeline lineno="465"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;h0_1&quot;,<sp/><sp/><sp/><sp/><sp/>mH,<sp/>0)<sp/><sp/>//<sp/>SM-like<sp/>Higgs</highlight></codeline>
<codeline lineno="466"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;pi0&quot;,<sp/><sp/><sp/>meson_masses.pi0,<sp/><sp/><sp/><sp/><sp/><sp/><sp/>0)</highlight></codeline>
<codeline lineno="467"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;pi+&quot;,<sp/><sp/><sp/>meson_masses.pi_plus,<sp/><sp/><sp/>0)</highlight></codeline>
<codeline lineno="468"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;pi-&quot;,<sp/><sp/><sp/>meson_masses.pi_minus,<sp/><sp/>0)</highlight></codeline>
<codeline lineno="469"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;eta&quot;,<sp/><sp/><sp/>meson_masses.eta,<sp/><sp/><sp/><sp/><sp/><sp/><sp/>0)</highlight></codeline>
<codeline lineno="470"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;rho0&quot;,<sp/><sp/>meson_masses.rho0,<sp/><sp/><sp/><sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="471"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;rho+&quot;,<sp/><sp/>meson_masses.rho_plus,<sp/><sp/>1)</highlight></codeline>
<codeline lineno="472"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;rho-&quot;,<sp/><sp/>meson_masses.rho_minus,<sp/>1)</highlight></codeline>
<codeline lineno="473"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>addParticle(&quot;omega&quot;,<sp/>meson_masses.omega,<sp/><sp/><sp/><sp/><sp/>1)</highlight></codeline>
<codeline lineno="474"><highlight class="comment"></highlight></codeline>
<codeline lineno="475"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Get<sp/>rid<sp/>of<sp/>convenience<sp/>macros</highlight></codeline>
<codeline lineno="476"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>#undef<sp/>getSMmass</highlight></codeline>
<codeline lineno="477"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>#undef<sp/>addParticle</highlight></codeline>
<codeline lineno="478"><highlight class="comment"></highlight></codeline>
<codeline lineno="479"><highlight class="comment"></highlight></codeline>
<codeline lineno="480"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>decay<sp/>into<sp/>two<sp/>photons<sp/>(through<sp/>a<sp/>loop<sp/>of<sp/>heavy<sp/>fermions)</highlight></codeline>
<codeline lineno="481"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>gamma_ph<sp/>=<sp/>(theta*theta*alpha*alpha*mS*mS*mS*C*C)/(256.*pi*pi*pi*vev*vev);</highlight></codeline>
<codeline lineno="482"><highlight class="comment"></highlight></codeline>
<codeline lineno="483"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>TH_Channel<sp/>dec_channel_ph(daFunk::vec&lt;string&gt;(&quot;gamma&quot;,<sp/>&quot;gamma&quot;),<sp/>daFunk::cnst(gamma_ph));</highlight></codeline>
<codeline lineno="484"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>process_dec.channelList.push_back(dec_channel_ph);</highlight></codeline>
<codeline lineno="485"><highlight class="comment"></highlight></codeline>
<codeline lineno="486"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>decay<sp/>into<sp/>e+/e-<sp/>pair</highlight></codeline>
<codeline lineno="487"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>me1<sp/>=<sp/>SM.get(Par::Pole_Mass,&quot;e-_1&quot;);</highlight></codeline>
<codeline lineno="488"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>gamma_e1<sp/>=<sp/>(<sp/>mS<sp/>&gt;=<sp/>2*me1<sp/>)<sp/>?<sp/>pow(theta,2)*pow(me1,2)*mS/(8*pi*pow(vev,2))*pow(1<sp/>-<sp/>4*pow(me1,2)/pow(mS,2),<sp/>3./2.)<sp/>:<sp/>0;</highlight></codeline>
<codeline lineno="489"><highlight class="comment"></highlight></codeline>
<codeline lineno="490"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>TH_Channel<sp/>dec_channel_e1(daFunk::vec&lt;string&gt;(&quot;e-_1&quot;,<sp/>&quot;e+_1&quot;),<sp/>daFunk::cnst(gamma_e1));</highlight></codeline>
<codeline lineno="491"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>process_dec.channelList.push_back(dec_channel_e1);</highlight></codeline>
<codeline lineno="492"><highlight class="comment"></highlight></codeline>
<codeline lineno="493"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>decay<sp/>into<sp/>mu+/mu-<sp/>pair</highlight></codeline>
<codeline lineno="494"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>me2<sp/>=<sp/>SM.get(Par::Pole_Mass,&quot;e-_2&quot;);</highlight></codeline>
<codeline lineno="495"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>gamma_e2<sp/>=<sp/>(<sp/>mS<sp/>&gt;=<sp/>2*me2<sp/>)<sp/>?<sp/>pow(theta,2)*pow(me2,2)*mS/(8*pi*pow(vev,2))*pow(1<sp/>-<sp/>4*pow(me2,2)/pow(mS,2),<sp/>3./2.)<sp/>:<sp/>0;</highlight></codeline>
<codeline lineno="496"><highlight class="comment"></highlight></codeline>
<codeline lineno="497"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>TH_Channel<sp/>dec_channel_e2(daFunk::vec&lt;string&gt;(&quot;e-_2&quot;,<sp/>&quot;e+_2&quot;),<sp/>daFunk::cnst(gamma_e2));</highlight></codeline>
<codeline lineno="498"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>process_dec.channelList.push_back(dec_channel_e2);</highlight></codeline>
<codeline lineno="499"><highlight class="comment"></highlight></codeline>
<codeline lineno="501"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Import<sp/>Decay<sp/>information<sp/>//</highlight></codeline>
<codeline lineno="503"><highlight class="comment"></highlight></codeline>
<codeline lineno="504"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Import<sp/>decay<sp/>table<sp/>from<sp/>DecayBit</highlight></codeline>
<codeline lineno="505"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>DecayTable*<sp/>tbl<sp/>=<sp/>&amp;(*Dep::decay_rates);</highlight></codeline>
<codeline lineno="506"><highlight class="comment"></highlight></codeline>
<codeline lineno="507"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Set<sp/>of<sp/>imported<sp/>decays</highlight></codeline>
<codeline lineno="508"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>std::set&lt;string&gt;<sp/>importedDecays;</highlight></codeline>
<codeline lineno="509"><highlight class="comment"></highlight></codeline>
<codeline lineno="510"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Minimum<sp/>branching<sp/>ratio</highlight></codeline>
<codeline lineno="511"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>minBranching<sp/>=<sp/>0.;</highlight></codeline>
<codeline lineno="512"><highlight class="comment"></highlight></codeline>
<codeline lineno="513"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Import<sp/>relevant<sp/>decays<sp/>(only<sp/>Higgs<sp/>and<sp/>subsequent<sp/>decays)</highlight></codeline>
<codeline lineno="514"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>DarkBit_utils::ImportDecays;</highlight></codeline>
<codeline lineno="515"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Notes:<sp/>Virtual<sp/>Higgs<sp/>decays<sp/>into<sp/>offshell<sp/>W+W-<sp/>final<sp/>states<sp/>are<sp/>not</highlight></codeline>
<codeline lineno="516"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>imported.<sp/><sp/>All<sp/>other<sp/>channels<sp/>are<sp/>correspondingly<sp/>rescaled.<sp/><sp/>Decay</highlight></codeline>
<codeline lineno="517"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>into<sp/>SS<sp/>final<sp/>states<sp/>is<sp/>accounted<sp/>for,<sp/>leading<sp/>to<sp/>zero<sp/>photons.</highlight></codeline>
<codeline lineno="518"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>ImportDecays(&quot;h0_1&quot;,<sp/>catalog,<sp/>importedDecays,<sp/>tbl,<sp/>minBranching,<sp/>daFunk::vec&lt;std::string&gt;(&quot;Z0&quot;,<sp/>&quot;W+&quot;,<sp/>&quot;W-&quot;));</highlight></codeline>
<codeline lineno="519"><highlight class="comment"></highlight></codeline>
<codeline lineno="520"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Add<sp/>the<sp/>decay<sp/>process<sp/>to<sp/>the<sp/>catalog</highlight></codeline>
<codeline lineno="521"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>catalog.processList.push_back(process_dec);</highlight></codeline>
<codeline lineno="522"><highlight class="comment"></highlight></codeline>
<codeline lineno="523"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Validate</highlight></codeline>
<codeline lineno="524"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>catalog.validate();</highlight></codeline>
<codeline lineno="525"><highlight class="comment"></highlight></codeline>
<codeline lineno="526"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>catalog;</highlight></codeline>
<codeline lineno="527"><highlight class="comment"><sp/><sp/><sp/><sp/>}<sp/>//<sp/>function<sp/>TH_ProcessCatalog_SuperRenormHP</highlight></codeline>
<codeline lineno="528"><highlight class="comment"></highlight></codeline>
<codeline lineno="529"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>to<sp/>provide<sp/>the<sp/>initial<sp/>energy<sp/>density<sp/>as<sp/>produced<sp/>by<sp/>the<sp/>freeze-in<sp/>mechanism<sp/>(in<sp/>GeV/cm^3)</highlight></codeline>
<codeline lineno="530"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>SuperRenormHP_relic_density<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="531"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="532"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::SuperRenormHP_relic_density;</highlight></codeline>
<codeline lineno="533"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>mS<sp/>=<sp/>*Param[&quot;mS&quot;],<sp/>theta<sp/>=<sp/>*Param[&quot;theta&quot;];</highlight></codeline>
<codeline lineno="534"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>lambda<sp/>=<sp/>*Param[&quot;lambda&quot;];</highlight></codeline>
<codeline lineno="535"><highlight class="comment"></highlight></codeline>
<codeline lineno="536"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>lambda*theta*theta*s0*mS*1e11;</highlight></codeline>
<codeline lineno="537"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="538"><highlight class="comment"></highlight></codeline>
<codeline lineno="539"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>to<sp/>provide<sp/>the<sp/>total<sp/>width<sp/>of<sp/>the<sp/>S<sp/>scalar<sp/>(in<sp/>GeV)</highlight></codeline>
<codeline lineno="540"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>SuperRenormHP_width<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="541"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="542"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::SuperRenormHP_width;</highlight></codeline>
<codeline lineno="543"><highlight class="comment"></highlight></codeline>
<codeline lineno="544"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>0.;</highlight></codeline>
<codeline lineno="545"><highlight class="comment"></highlight></codeline>
<codeline lineno="546"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>std::string<sp/>DM_ID<sp/>=<sp/>*Dep::DarkMatter_ID;</highlight></codeline>
<codeline lineno="547"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>TH_ProcessCatalog<sp/>catalog<sp/>=<sp/>*Dep::TH_ProcessCatalog;</highlight></codeline>
<codeline lineno="548"><highlight class="comment"></highlight></codeline>
<codeline lineno="549"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Check<sp/>whether<sp/>the<sp/>process<sp/>catalog<sp/>has<sp/>the<sp/>decay<sp/>prosses</highlight></codeline>
<codeline lineno="550"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(Dep::TH_ProcessCatalog-&gt;find(DM_ID)<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="551"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="552"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>decay<sp/>S<sp/>-&gt;<sp/>gamma<sp/>gamma</highlight></codeline>
<codeline lineno="553"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>TH_Channel*<sp/>dec_channel_ph<sp/>=<sp/>catalog.getProcess(DM_ID).find({&quot;gamma&quot;,<sp/>&quot;gamma&quot;});</highlight></codeline>
<codeline lineno="554"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dec_channel_ph<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="555"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="556"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>+=<sp/>dec_channel_ph-&gt;genRate-&gt;bind()-&gt;eval();</highlight></codeline>
<codeline lineno="557"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="558"><highlight class="comment"></highlight></codeline>
<codeline lineno="559"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>decay<sp/>S<sp/>-&gt;<sp/>e-_1<sp/>e+_1</highlight></codeline>
<codeline lineno="560"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>TH_Channel*<sp/>dec_channel_e1<sp/>=<sp/>catalog.getProcess(DM_ID).find({&quot;e-_1&quot;,<sp/>&quot;e+_1&quot;});</highlight></codeline>
<codeline lineno="561"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dec_channel_e1<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="562"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="563"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>+=<sp/>dec_channel_e1-&gt;genRate-&gt;bind()-&gt;eval();</highlight></codeline>
<codeline lineno="564"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="565"><highlight class="comment"></highlight></codeline>
<codeline lineno="566"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>decay<sp/>S<sp/>-&gt;<sp/>e-_2<sp/>e+_2</highlight></codeline>
<codeline lineno="567"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>TH_Channel*<sp/>dec_channel_e2<sp/>=<sp/>catalog.getProcess(DM_ID).find({&quot;e-_2&quot;,<sp/>&quot;e+2&quot;});</highlight></codeline>
<codeline lineno="568"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(dec_channel_e2<sp/>!=NULL)</highlight></codeline>
<codeline lineno="569"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="570"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>+=<sp/>dec_channel_e2-&gt;genRate-&gt;bind()-&gt;eval();</highlight></codeline>
<codeline lineno="571"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="572"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="573"><highlight class="comment"></highlight></codeline>
<codeline lineno="574"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="575"><highlight class="comment"></highlight></codeline>
<codeline lineno="576"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>to<sp/>provide<sp/>the<sp/>lifetime<sp/>of<sp/>the<sp/>S<sp/>scalar<sp/>(in<sp/>s)</highlight></codeline>
<codeline lineno="577"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>SuperRenormHP_lifetime<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="578"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="579"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::SuperRenormHP_lifetime;</highlight></codeline>
<codeline lineno="580"><highlight class="comment"></highlight></codeline>
<codeline lineno="581"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>width<sp/>=<sp/>*Dep::DM_width;</highlight></codeline>
<codeline lineno="582"><highlight class="comment"></highlight></codeline>
<codeline lineno="583"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>1/width*hbar_GeV;</highlight></codeline>
<codeline lineno="584"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="585"><highlight class="comment"></highlight></codeline>
<codeline lineno="586"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>RD_oh2_SuperRenormHP<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="587"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="588"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::RD_oh2_SuperRenormHP;</highlight></codeline>
<codeline lineno="589"><highlight class="comment"></highlight></codeline>
<codeline lineno="590"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>RD<sp/>=<sp/>*Dep::DM_relic_density;</highlight></codeline>
<codeline lineno="591"><highlight class="comment"></highlight></codeline>
<codeline lineno="592"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>rhoC_over_h2<sp/>=<sp/>3*pow(100/Mpc_2_km,<sp/>2)*pow(Mp,<sp/>2)/(8*pi)/hbar_GeV/pow(cs,<sp/>3);<sp/>//<sp/>critical<sp/>density<sp/>un<sp/>Gev/cm^3</highlight></codeline>
<codeline lineno="593"><highlight class="comment"></highlight></codeline>
<codeline lineno="594"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>RD/rhoC_over_h2;</highlight></codeline>
<codeline lineno="595"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="596"><highlight class="comment"></highlight></codeline>
<codeline lineno="597"><highlight class="comment"><sp/><sp/><sp/><sp/>//-------------<sp/>Functions<sp/>to<sp/>compute<sp/>stellar<sp/>cooling<sp/>likelihoods<sp/>-------------//</highlight></codeline>
<codeline lineno="598"><highlight class="comment"></highlight></codeline>
<codeline lineno="599"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>to<sp/>compute<sp/>the<sp/>solar<sp/>DM<sp/>luminosity</highlight></codeline>
<codeline lineno="600"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>SuperRenormHP_solar_luminosity<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="601"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="602"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::SuperRenormHP_solar_luminosity;</highlight></codeline>
<codeline lineno="603"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>mS<sp/>=<sp/>*Param[&quot;mS&quot;]*1e9,<sp/>theta<sp/>=<sp/>*Param[&quot;theta&quot;];</highlight></codeline>
<codeline lineno="604"><highlight class="comment"></highlight></codeline>
<codeline lineno="605"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>gsl_error_handler_t<sp/>*old_handler<sp/>=<sp/>gsl_set_error_handler<sp/>(&amp;handler_Ls);</highlight></codeline>
<codeline lineno="606"><highlight class="comment"></highlight></codeline>
<codeline lineno="607"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>StellarModel<sp/>model<sp/>(GAMBIT_DIR<sp/>&quot;/DarkBit/data/SolarModel_AGSS09met.dat&quot;);</highlight></codeline>
<codeline lineno="608"><highlight class="comment"></highlight></codeline>
<codeline lineno="609"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(mS<sp/>&lt;<sp/>mSmax)<sp/>{<sp/>result<sp/>=<sp/>model.Ls(mS,<sp/>theta);<sp/>}</highlight></codeline>
<codeline lineno="610"><highlight class="comment"></highlight></codeline>
<codeline lineno="611"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>else<sp/>{<sp/>result<sp/>=<sp/>0;<sp/>}</highlight></codeline>
<codeline lineno="612"><highlight class="comment"></highlight></codeline>
<codeline lineno="613"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>gsl_set_error_handler<sp/>(old_handler);</highlight></codeline>
<codeline lineno="614"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="615"><highlight class="comment"></highlight></codeline>
<codeline lineno="616"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>to<sp/>compute<sp/>the<sp/>likelihood<sp/>from<sp/>the<sp/>solar<sp/>luminosity<sp/>limit<sp/>(<sp/>L_DM<sp/>&lt;<sp/>0.1*L0<sp/>)<sp/>(conservative<sp/>limit)</highlight></codeline>
<codeline lineno="617"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>calc_lnL_solar_luminosity<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="618"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="619"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::calc_lnL_solar_luminosity;</highlight></codeline>
<codeline lineno="620"><highlight class="comment"></highlight></codeline>
<codeline lineno="621"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>limit<sp/>=<sp/>0.1*L0;</highlight></codeline>
<codeline lineno="622"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Ls<sp/>=<sp/>*Dep::solar_DM_luminosity;</highlight></codeline>
<codeline lineno="623"><highlight class="comment"></highlight></codeline>
<codeline lineno="624"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(Ls<sp/>&gt;<sp/>limit)<sp/>{<sp/>result<sp/>=<sp/>logmin;<sp/>}</highlight></codeline>
<codeline lineno="625"><highlight class="comment"></highlight></codeline>
<codeline lineno="626"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>else<sp/>{<sp/>result<sp/>=<sp/>0;<sp/>}</highlight></codeline>
<codeline lineno="627"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="628"><highlight class="comment"></highlight></codeline>
<codeline lineno="629"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>values<sp/>for<sp/>the<sp/>observed<sp/>and<sp/>SSM<sp/>predicted<sp/>neutrni<sp/>fluxes<sp/>as<sp/>well<sp/>as<sp/>the<sp/>corresponding<sp/>errors<sp/>taken<sp/>from:<sp/>arXiv:1605.06502v2</highlight></codeline>
<codeline lineno="630"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>to<sp/>compute<sp/>the<sp/>predicted<sp/>solar<sp/>neutrino<sp/>flux<sp/>(B8)</highlight></codeline>
<codeline lineno="631"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>SuperRenormHP_solar_neutrino_flux_B8<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="632"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="633"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::SuperRenormHP_solar_neutrino_flux_B8;</highlight></codeline>
<codeline lineno="634"><highlight class="comment"></highlight></codeline>
<codeline lineno="635"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Ls<sp/>=<sp/>*Dep::solar_DM_luminosity;</highlight></codeline>
<codeline lineno="636"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>alpha<sp/>=<sp/>*Param[&quot;alpha&quot;];</highlight></codeline>
<codeline lineno="637"><highlight class="comment"></highlight></codeline>
<codeline lineno="638"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Phi0<sp/>=<sp/>4.95e6;</highlight></codeline>
<codeline lineno="639"><highlight class="comment"></highlight></codeline>
<codeline lineno="640"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>Phi0*pow(1+Ls/L0,<sp/>alpha);</highlight></codeline>
<codeline lineno="641"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="642"><highlight class="comment"></highlight></codeline>
<codeline lineno="643"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>to<sp/>compute<sp/>the<sp/>predicted<sp/>solar<sp/>neutrino<sp/>flux<sp/>(Be7)</highlight></codeline>
<codeline lineno="644"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>SuperRenormHP_solar_neutrino_flux_Be7<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="645"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="646"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::SuperRenormHP_solar_neutrino_flux_Be7;</highlight></codeline>
<codeline lineno="647"><highlight class="comment"></highlight></codeline>
<codeline lineno="648"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Ls<sp/>=<sp/>*Dep::solar_DM_luminosity;</highlight></codeline>
<codeline lineno="649"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>alpha<sp/>=<sp/>*Param[&quot;alpha&quot;];</highlight></codeline>
<codeline lineno="650"><highlight class="comment"></highlight></codeline>
<codeline lineno="651"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Phi0<sp/>=<sp/>4.71e9;</highlight></codeline>
<codeline lineno="652"><highlight class="comment"></highlight></codeline>
<codeline lineno="653"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>Phi0*pow(1+Ls/L0,<sp/>alpha);</highlight></codeline>
<codeline lineno="654"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="655"><highlight class="comment"></highlight></codeline>
<codeline lineno="656"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>to<sp/>compute<sp/>the<sp/>likelihood<sp/>from<sp/>the<sp/>solar<sp/>B8<sp/>neutrino<sp/>flux</highlight></codeline>
<codeline lineno="657"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>calc_lnL_solar_neutrino_B8<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="658"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="659"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::calc_lnL_solar_neutrino_B8;</highlight></codeline>
<codeline lineno="660"><highlight class="comment"></highlight></codeline>
<codeline lineno="661"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>bool<sp/>profile<sp/>=<sp/>runOptions-&gt;getValueOrDef&lt;bool&gt;(false,<sp/>&quot;profile_systematics&quot;);</highlight></codeline>
<codeline lineno="662"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Phi_predicted<sp/>=<sp/>*Dep::solar_neutrino_flux_B8;</highlight></codeline>
<codeline lineno="663"><highlight class="comment"></highlight></codeline>
<codeline lineno="664"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Phi_obs<sp/>=<sp/>5e6;</highlight></codeline>
<codeline lineno="665"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>sigma_obs<sp/>=<sp/>0.03*Phi_obs,<sp/>sigma_theo<sp/>=<sp/>0.14*Phi_predicted;</highlight></codeline>
<codeline lineno="666"><highlight class="comment"></highlight></codeline>
<codeline lineno="667"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>Stats::gaussian_loglikelihood(Phi_predicted,<sp/>Phi_obs,<sp/>sigma_theo,<sp/>sigma_obs,<sp/>profile);</highlight></codeline>
<codeline lineno="668"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="669"><highlight class="comment"></highlight></codeline>
<codeline lineno="670"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>to<sp/>compute<sp/>the<sp/>likelihood<sp/>from<sp/>the<sp/>solar<sp/>Be7<sp/>neutrino<sp/>flux</highlight></codeline>
<codeline lineno="671"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>calc_lnL_solar_neutrino_Be7<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="672"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="673"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::calc_lnL_solar_neutrino_Be7;</highlight></codeline>
<codeline lineno="674"><highlight class="comment"></highlight></codeline>
<codeline lineno="675"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>bool<sp/>profile<sp/>=<sp/>runOptions-&gt;getValueOrDef&lt;bool&gt;(false,<sp/>&quot;profile_systematics&quot;);</highlight></codeline>
<codeline lineno="676"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Phi_predicted<sp/>=<sp/>*Dep::solar_neutrino_flux_Be7;</highlight></codeline>
<codeline lineno="677"><highlight class="comment"></highlight></codeline>
<codeline lineno="678"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>Phi_obs<sp/>=<sp/>4.82e9;</highlight></codeline>
<codeline lineno="679"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>sigma_obs<sp/>=<sp/>0.05*Phi_obs,<sp/>sigma_theo<sp/>=<sp/>0.07*Phi_predicted;</highlight></codeline>
<codeline lineno="680"><highlight class="comment"></highlight></codeline>
<codeline lineno="681"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>Stats::gaussian_loglikelihood(Phi_predicted,<sp/>Phi_obs,<sp/>sigma_theo,<sp/>sigma_obs,<sp/>profile);</highlight></codeline>
<codeline lineno="682"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="683"><highlight class="comment"></highlight></codeline>
<codeline lineno="684"><highlight class="comment"><sp/><sp/><sp/><sp/>//-------------<sp/>Functions<sp/>to<sp/>compute<sp/>short<sp/>range<sp/>forces<sp/>likelihoods<sp/>-------------//</highlight></codeline>
<codeline lineno="685"><highlight class="comment"></highlight></codeline>
<codeline lineno="686"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>to<sp/>provide<sp/>the<sp/>Higgs-Nucleon<sp/>coupling<sp/>constant<sp/>fN,<sp/>such<sp/>as<sp/>described<sp/>in<sp/>arXiv:1306.4710</highlight></codeline>
<codeline lineno="687"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>func_Higgs_Nucleon_coupling_fN<sp/>(Higgs_Nucleon_coupling_fN<sp/>&amp;result)</highlight></codeline>
<codeline lineno="688"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="689"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::func_Higgs_Nucleon_coupling_fN;</highlight></codeline>
<codeline lineno="690"><highlight class="comment"></highlight></codeline>
<codeline lineno="691"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>sigmas<sp/>=<sp/>*Param[&quot;sigmas&quot;]*1e-3,<sp/>sigmal<sp/>=<sp/>*Param[&quot;sigmal&quot;]*1e-3;<sp/>//<sp/>nuclear<sp/>parameters<sp/>in<sp/>GeV<sp/>(model<sp/>input<sp/>in<sp/>MeV)</highlight></codeline>
<codeline lineno="692"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>Spectrum<sp/>SM<sp/>=<sp/>*Dep::SM_spectrum;<sp/>//<sp/>SM<sp/>spectrum<sp/>needed<sp/>to<sp/>get<sp/>light<sp/>quark<sp/>masses</highlight></codeline>
<codeline lineno="693"><highlight class="comment"></highlight></codeline>
<codeline lineno="694"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>z<sp/>=<sp/>1.49;<sp/>//<sp/>isospin<sp/>breaking<sp/>ratio</highlight></codeline>
<codeline lineno="695"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>mu<sp/>=<sp/>SM.get(Par::mass1,<sp/>&quot;u_1&quot;),<sp/>md<sp/>=<sp/>SM.get(Par::mass1,<sp/>&quot;d_1&quot;),<sp/>ms<sp/>=<sp/>SM.get(Par::mass1,<sp/>&quot;d_2&quot;);<sp/>//<sp/>light<sp/>quark<sp/>masses<sp/>[GeV]</highlight></codeline>
<codeline lineno="696"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>mn<sp/>=<sp/>Gambit::m_neutron,<sp/>mp<sp/>=<sp/>Gambit::m_proton;<sp/>//<sp/>nucleon<sp/>masses<sp/>[GeV]</highlight></codeline>
<codeline lineno="697"><highlight class="comment"></highlight></codeline>
<codeline lineno="698"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>intermediate<sp/>quantities</highlight></codeline>
<codeline lineno="699"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>ml<sp/>=<sp/>0.5*(mu+md);</highlight></codeline>
<codeline lineno="700"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>sigma0<sp/>=<sp/>sigmal<sp/>-<sp/>sigmas*(2.*ml/ms);;</highlight></codeline>
<codeline lineno="701"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>y<sp/>=<sp/>1<sp/>-<sp/>sigma0/sigmal;</highlight></codeline>
<codeline lineno="702"><highlight class="comment"></highlight></codeline>
<codeline lineno="703"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;double&gt;<sp/>fu,<sp/>fd,<sp/>fs,<sp/>mN<sp/>=<sp/>{mn,<sp/>mp};</highlight></codeline>
<codeline lineno="704"><highlight class="comment"></highlight></codeline>
<codeline lineno="705"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i(0);<sp/>i&lt;mN.size();<sp/>++i)</highlight></codeline>
<codeline lineno="706"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="707"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fu.push_back(mu/(mu+md)*sigmal/mN[i]*(2*z+y*(1-z))/(1+z));</highlight></codeline>
<codeline lineno="708"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fd.push_back(md/(mu+md)*sigmal/mN[i]*(2-y*(1-z))/(1+z));</highlight></codeline>
<codeline lineno="709"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fs.push_back(ms/(mu+md)*sigmal/mN[i]*y);</highlight></codeline>
<codeline lineno="710"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="711"><highlight class="comment"></highlight></codeline>
<codeline lineno="712"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result.neutron<sp/>=<sp/><sp/>2./9.<sp/>+<sp/>7./9.*(fu[0]+fd[0]+fs[0]);</highlight></codeline>
<codeline lineno="713"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result.proton<sp/><sp/>=<sp/><sp/>2./9.<sp/>+<sp/>7./9.*(fu[1]+fd[1]+fs[1]);</highlight></codeline>
<codeline lineno="714"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="715"><highlight class="comment"></highlight></codeline>
<codeline lineno="716"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>Modified<sp/>Inverse-Square<sp/>Law<sp/>(ISL)<sp/>by<sp/>adding<sp/>a<sp/>new<sp/>Yukawa<sp/>potential<sp/>to<sp/>the<sp/>Newtonian<sp/>gravitational<sp/>potential:<sp/>Vnew(r)<sp/>=<sp/>-(alpha*G*m1*m2)/r<sp/>*<sp/>exp(-r/lambda)</highlight></codeline>
<codeline lineno="717"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>where<sp/>alpha<sp/>is<sp/>the<sp/>strenght<sp/>of<sp/>the<sp/>new<sp/>force<sp/>and<sp/>lambda<sp/>its<sp/>range</highlight></codeline>
<codeline lineno="718"><highlight class="comment"></highlight></codeline>
<codeline lineno="719"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>experimental<sp/>parameters<sp/>from<sp/>Sushkov<sp/>et<sp/>al.<sp/>2011<sp/>arXiv:1108.2547</highlight></codeline>
<codeline lineno="720"><highlight class="comment"><sp/><sp/><sp/><sp/>const<sp/>double<sp/>rhoAu<sp/>=<sp/>19,<sp/>rhoTi<sp/>=<sp/>4.5,<sp/>rhog<sp/>=<sp/>2.6,<sp/>dAu<sp/>=<sp/>700e-8,<sp/>dTi<sp/>=<sp/>100e-8,<sp/>R<sp/>=<sp/>15.6;<sp/>//<sp/>in<sp/>cgs<sp/>units</highlight></codeline>
<codeline lineno="721"><highlight class="comment"></highlight></codeline>
<codeline lineno="722"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>returning<sp/>the<sp/>new<sp/>force<sp/>from<sp/>the<sp/>SuperRenormHP<sp/>model<sp/>for<sp/>the<sp/>experiment<sp/>from<sp/>Shuskov<sp/>et<sp/>al.<sp/>2011</highlight></codeline>
<codeline lineno="723"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>New_Force_Sushkov2011_SuperRenormHP<sp/>(daFunk::Funk<sp/>&amp;result)</highlight></codeline>
<codeline lineno="724"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="725"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::New_Force_Sushkov2011_SuperRenormHP;</highlight></codeline>
<codeline lineno="726"><highlight class="comment"></highlight></codeline>
<codeline lineno="727"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(ModelInUse(&quot;symmetron&quot;))</highlight></codeline>
<codeline lineno="728"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="729"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>powv<sp/>=<sp/>*Param[&quot;vval&quot;],<sp/>powmu<sp/>=<sp/>*Param[&quot;mu&quot;];</highlight></codeline>
<codeline lineno="730"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>vval<sp/>=<sp/>pow(10,<sp/>powv)*Gambit::m_planck_red,<sp/>mu<sp/>=<sp/>pow(10,<sp/>powmu);</highlight></codeline>
<codeline lineno="731"><highlight class="comment"></highlight></codeline>
<codeline lineno="732"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>Rad<sp/>=<sp/>16.5;<sp/>//<sp/>sphere<sp/>radius<sp/>in<sp/>cm</highlight></codeline>
<codeline lineno="733"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>muR<sp/>=<sp/>mu*Rad/Gambit::gev2cm;<sp/>//<sp/>dimensionless<sp/>term</highlight></codeline>
<codeline lineno="734"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>daFunk::Funk<sp/>d<sp/>=<sp/>daFunk::var(&quot;d&quot;);<sp/>//<sp/>separation<sp/>between<sp/>plates</highlight></codeline>
<codeline lineno="735"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>daFunk::Funk<sp/>mux<sp/>=<sp/>d*1e-6/(Gambit::gev2cm*1e-2)*mu+muR;</highlight></codeline>
<codeline lineno="736"><highlight class="comment"></highlight></codeline>
<codeline lineno="737"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>GeV2Newtons<sp/>=<sp/>8.19e5;<sp/>//<sp/>Newton/GeV^2</highlight></codeline>
<codeline lineno="738"><highlight class="comment"></highlight></codeline>
<codeline lineno="739"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>daFunk::Funk<sp/>force<sp/>=<sp/>4.*M_PI*vval*vval*muR/sqrt(2)*tanh(mux/sqrt(2))*pow(1./cosh(mux/sqrt(2)),2.0)<sp/>*<sp/>GeV2Newtons;<sp/>//<sp/>take<sp/>neg<sp/>of<sp/>force??</highlight></codeline>
<codeline lineno="740"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>force;</highlight></codeline>
<codeline lineno="741"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="742"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline lineno="743"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="744"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>double<sp/>alpha<sp/>=<sp/>*Param[&quot;alpha&quot;],<sp/>lambda<sp/>=<sp/>*Param[&quot;lambda&quot;]*1e2;<sp/>//<sp/>lambda<sp/>in<sp/>cm</highlight></codeline>
<codeline lineno="745"><highlight class="comment"></highlight></codeline>
<codeline lineno="746"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>daFunk::Funk<sp/>d<sp/>=<sp/>daFunk::var(&quot;d&quot;);</highlight></codeline>
<codeline lineno="747"><highlight class="comment"></highlight></codeline>
<codeline lineno="748"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>daFunk::Funk<sp/>force<sp/>=<sp/>4*pow(pi,<sp/>2)*G_cgs*R*alpha*pow(lambda,<sp/>3)*exp(-d/lambda)*pow(rhoAu<sp/>+<sp/>(rhoTi-rhoAu)*exp(-dAu/lambda)<sp/>+<sp/>(rhog-rhoTi)*exp(-(dAu+dTi)/lambda),<sp/>2)*1e-5;<sp/>//<sp/>*1e-5<sp/>conversion<sp/>from<sp/>dyn(cgs)<sp/>to<sp/>N<sp/>(SI)</highlight></codeline>
<codeline lineno="749"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>force;</highlight></codeline>
<codeline lineno="750"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="751"><highlight class="comment"></highlight></codeline>
<codeline lineno="752"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="753"><highlight class="comment"></highlight></codeline>
<codeline lineno="754"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>capability<sp/>function<sp/>to<sp/>compute<sp/>the<sp/>likelihood<sp/>from<sp/>Sushkov<sp/>et<sp/>al.<sp/>2011</highlight></codeline>
<codeline lineno="755"><highlight class="comment"><sp/><sp/><sp/><sp/>void<sp/>calc_lnL_ShortRangeForces_Sushkov2011<sp/>(double<sp/>&amp;result)</highlight></codeline>
<codeline lineno="756"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="757"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>using<sp/>namespace<sp/>Pipes::calc_lnL_ShortRangeForces_Sushkov2011;</highlight></codeline>
<codeline lineno="758"><highlight class="comment"></highlight></codeline>
<codeline lineno="759"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>daFunk::Funk<sp/>ForceNew<sp/>=<sp/>*Dep::New_Force_Sushkov2011*1e12;<sp/>//<sp/>new<sp/>force<sp/>in<sp/>pN</highlight></codeline>
<codeline lineno="760"><highlight class="comment"></highlight></codeline>
<codeline lineno="761"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>ASCIItableReader<sp/>data<sp/>=<sp/>ASCIItableReader(GAMBIT_DIR<sp/>&quot;/DarkBit/data/ShortRangeForces/Sushkov2011.dat&quot;);</highlight></codeline>
<codeline lineno="762"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>data.setcolnames({&quot;distance&quot;,<sp/>&quot;Fres&quot;,<sp/>&quot;sigma&quot;,<sp/>&quot;binWidth&quot;});</highlight></codeline>
<codeline lineno="763"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>std::vector&lt;double&gt;<sp/>distance<sp/>=<sp/>data[&quot;distance&quot;];<sp/>//<sp/>[microns]</highlight></codeline>
<codeline lineno="764"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>std::vector&lt;double&gt;<sp/>Fres<sp/>=<sp/>data[&quot;Fres&quot;];<sp/>//<sp/>[pN]</highlight></codeline>
<codeline lineno="765"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>std::vector&lt;double&gt;<sp/>sigma<sp/>=<sp/>data[&quot;sigma&quot;];<sp/>//<sp/>[pN]</highlight></codeline>
<codeline lineno="766"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>static<sp/>std::vector&lt;double&gt;<sp/>width<sp/>=<sp/>data[&quot;binWidth&quot;];<sp/>//<sp/>[microns]</highlight></codeline>
<codeline lineno="767"><highlight class="comment"></highlight></codeline>
<codeline lineno="768"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;boost::shared_ptr&lt;daFunk::FunkBase&gt;&gt;<sp/>ForceNewBinned;</highlight></codeline>
<codeline lineno="769"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;boost::shared_ptr&lt;daFunk::FunkBound&gt;&gt;<sp/>FnewBound;</highlight></codeline>
<codeline lineno="770"><highlight class="comment"></highlight></codeline>
<codeline lineno="771"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>d,<sp/>delta;</highlight></codeline>
<codeline lineno="772"><highlight class="comment"></highlight></codeline>
<codeline lineno="773"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i(0);<sp/>i&lt;distance.size();<sp/>++i)</highlight></codeline>
<codeline lineno="774"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="775"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>d<sp/>=<sp/>distance[i]*1e-4;</highlight></codeline>
<codeline lineno="776"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>delta<sp/>=<sp/>width[i]*1e-4;</highlight></codeline>
<codeline lineno="777"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ForceNewBinned.push_back(ForceNew-&gt;gsl_integration(&quot;d&quot;,<sp/>d-delta/2,<sp/>d+delta/2)/delta);</highlight></codeline>
<codeline lineno="778"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FnewBound.push_back(ForceNewBinned[i]-&gt;bind());</highlight></codeline>
<codeline lineno="779"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="780"><highlight class="comment"></highlight></codeline>
<codeline lineno="781"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;double&gt;<sp/>likelihood;</highlight></codeline>
<codeline lineno="782"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>double<sp/>norm,<sp/>Fnew;</highlight></codeline>
<codeline lineno="783"><highlight class="comment"></highlight></codeline>
<codeline lineno="784"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(size_t<sp/>i(0);<sp/>i&lt;distance.size();<sp/>++i)</highlight></codeline>
<codeline lineno="785"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="786"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>norm<sp/>=<sp/>1.;<sp/>//<sp/>we<sp/>take<sp/>the<sp/>likelihood<sp/>ratio<sp/>to<sp/>avoid<sp/>having<sp/>different<sp/>normalizations<sp/>accross<sp/>the<sp/>parameter<sp/>space;</highlight></codeline>
<codeline lineno="787"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Fnew<sp/>=<sp/>FnewBound[i]-&gt;eval();</highlight></codeline>
<codeline lineno="788"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>likelihood.push_back(<sp/>(Fnew&lt;Fres[i])<sp/>?<sp/>norm<sp/>:<sp/>norm*exp(-pow(Fres[i]-Fnew,<sp/>2)/pow(sigma[i],<sp/>2))<sp/>);</highlight></codeline>
<codeline lineno="789"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="790"><highlight class="comment"></highlight></codeline>
<codeline lineno="791"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>log(*std::min_element(likelihood.begin(),<sp/>likelihood.end()));<sp/>//<sp/>we<sp/>take<sp/>the<sp/>minimum<sp/>likelihood,<sp/>since<sp/>we<sp/>don&apos;t<sp/>have<sp/>the<sp/>correlations<sp/>between<sp/>data<sp/>bins</highlight></codeline>
<codeline lineno="792"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="793"><highlight class="comment"></highlight></codeline>
<codeline lineno="794"><highlight class="comment"><sp/><sp/>}</highlight></codeline>
<codeline lineno="795"><highlight class="comment">}</highlight></codeline>
<codeline lineno="796"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="/home/runner/work/gambit_sphinx/gambit_sphinx/DarkBit/src/SuperRenormHP.cpp"/>
  </compounddef>
</doxygen>
