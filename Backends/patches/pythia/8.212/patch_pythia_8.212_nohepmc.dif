diff -rupN pythia_8.212_original/include/Pythia8/ParticleData.h pythia_8.212_patched_nohepmc/include/Pythia8/ParticleData.h
--- pythia_8.212_original/include/Pythia8/ParticleData.h	2015-09-23 17:34:38.000000000 +0200
+++ pythia_8.212_patched_nohepmc/include/Pythia8/ParticleData.h	2020-09-09 20:16:05.232382323 +0200
@@ -347,6 +347,10 @@ public:
   bool init(string startFile = "../xmldoc/ParticleData.xml") {
     initCommon(); return readXML(startFile);}
 
+  // Read in database from saved file stored in memory
+  bool init(const ParticleData &particleDataIn) {
+    initCommon(); return copyXML(particleDataIn);}
+
   // Overwrite existing database by reading from specific file.
   bool reInit(string startFile, bool xmlFormat = true) { initCommon();
     return (xmlFormat) ? readXML(startFile) : readFF(startFile);}
@@ -354,10 +358,17 @@ public:
   // Initialize pointers, normal Breit-Wigners and special resonances.
   void initWidths(vector<ResonanceWidths*> resonancePtrs);
 
-  // Read or list whole (or part of) database from/to an XML file.
+  // Read and process or list whole (or part of) database from/to an XML file.
   bool readXML(string inFile, bool reset = true) ;
   void listXML(string outFile);
 
+  // Copy and process XML information from another particleData object
+  bool copyXML(const ParticleData &particleDataIn);
+
+  // Auxiliary functions to readXML() and copyXML():
+  bool loadXML(string inFile, bool reset = true) ;
+  bool processXML(bool reset = true) ;
+
   // Read or list whole (or part of) database from/to a free format file.
   bool readFF(string inFile, bool reset = true) ;
   void listFF(string outFile);
@@ -560,6 +571,9 @@ public:
   ParticleDataEntry* particleDataEntryPtr(int idIn) {
     return (isParticle(idIn)) ? &pdt[abs(idIn)] : &pdt[0]; }
 
+  // Check initialisation status.
+  bool getIsInit() {return isInit;}
+  
 private:
 
   // Common data, accessible for the individual particles.
@@ -607,6 +621,9 @@ private:
   int    intAttributeValue(string line, string attribute);
   double doubleAttributeValue(string line, string attribute);
 
+  // Vector of strings containing the readable lines of the XML file
+  vector<string> xmlFileSav;
+  
 };
 
 //==========================================================================
diff -rupN pythia_8.212_original/include/Pythia8/PartonDistributions.h pythia_8.212_patched_nohepmc/include/Pythia8/PartonDistributions.h
--- pythia_8.212_original/include/Pythia8/PartonDistributions.h	2015-09-23 17:34:38.000000000 +0200
+++ pythia_8.212_patched_nohepmc/include/Pythia8/PartonDistributions.h	2020-09-09 20:16:05.236382348 +0200
@@ -156,9 +156,8 @@ class MSTWpdf : public PDF {
 public:
 
   // Constructor.
-  MSTWpdf(int idBeamIn = 2212, int iFitIn = 1,
-    string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-    : PDF(idBeamIn) {init( iFitIn,  xmlPath, infoPtr);}
+  MSTWpdf(int idBeamIn = 2212, int iFitIn = 1, string xmlPath = "../xmldoc/",
+    Info* infoPtr = 0) : PDF(idBeamIn) {init( iFitIn,  xmlPath, infoPtr);}
 
 private:
 
@@ -209,9 +208,8 @@ class CTEQ6pdf : public PDF {
 public:
 
   // Constructor.
-  CTEQ6pdf(int idBeamIn = 2212, int iFitIn = 1,
-    string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-    : PDF(idBeamIn) {init( iFitIn, xmlPath, infoPtr);}
+  CTEQ6pdf(int idBeamIn = 2212, int iFitIn = 1, string xmlPath = "../xmldoc/",
+    Info* infoPtr = 0) : PDF(idBeamIn) {init( iFitIn, xmlPath, infoPtr);}
 
 private:
 
@@ -333,8 +331,8 @@ public:
 
   // Constructor.
  PomH1FitAB(int idBeamIn = 990, int iFit = 1, double rescaleIn = 1.,
-   string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-   : PDF(idBeamIn) {rescale = rescaleIn; init( iFit, xmlPath, infoPtr);}
+   string xmlPath = "../xmldoc/", Info* infoPtr = 0) : PDF(idBeamIn)
+   {rescale = rescaleIn; init( iFit, xmlPath, infoPtr);}
 
 private:
 
@@ -365,8 +363,8 @@ public:
 
   // Constructor.
   PomH1Jets(int idBeamIn = 990,  double rescaleIn = 1.,
-   string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-   : PDF(idBeamIn) {rescale = rescaleIn; init( xmlPath, infoPtr);}
+   string xmlPath = "../xmldoc/", Info* infoPtr = 0) : PDF(idBeamIn)
+   {rescale = rescaleIn; init( xmlPath, infoPtr);}
 
 private:
 
@@ -464,22 +462,14 @@ class NNPDF : public PDF {
 public:
 
   // Constructor.
-  NNPDF(int idBeamIn = 2212, int iFitIn = 1,
-    string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-    : PDF(idBeamIn), fPDFGrid(NULL), fXGrid(NULL), fLogXGrid(NULL),
-    fQ2Grid(NULL), fLogQ2Grid(NULL), fRes(NULL) {
-    init( iFitIn, xmlPath, infoPtr); };
+  NNPDF(int idBeamIn = 2212, int iFitIn = 1, string xmlPath = "../xmldoc/",
+    Info* infoPtr = 0) : PDF(idBeamIn), fPDFGrid(NULL), fXGrid(NULL),
+    fLogXGrid(NULL), fQ2Grid(NULL), fLogQ2Grid(NULL), fRes(NULL){
+      init( iFitIn, xmlPath, infoPtr); };
 
   // Destructor.
   ~NNPDF() {
-    if (fPDFGrid) {
-      for (int i = 0; i < fNFL; i++) {
-        for (int j = 0; j < fNX; j++)
-          if (fPDFGrid[i][j]) delete[] fPDFGrid[i][j];
-        if (fPDFGrid[i]) delete[] fPDFGrid[i];
-      }
-      delete[] fPDFGrid;
-    }
+    if (fPDFGrid) delete[] fPDFGrid;
     if (fXGrid) delete[] fXGrid;
     if (fLogXGrid) delete[] fLogXGrid;
     if (fQ2Grid) delete[] fQ2Grid;
@@ -499,7 +489,7 @@ private:
 
   // Variables to be set during code initialization.
   int iFit, fNX, fNQ2;
-  double ***fPDFGrid;
+  double *fPDFGrid;
   double *fXGrid;
   double *fLogXGrid;
   double *fQ2Grid;
diff -rupN pythia_8.212_original/include/Pythia8/Pythia.h pythia_8.212_patched_nohepmc/include/Pythia8/Pythia.h
--- pythia_8.212_original/include/Pythia8/Pythia.h	2015-09-23 17:34:39.000000000 +0200
+++ pythia_8.212_patched_nohepmc/include/Pythia8/Pythia.h	2020-09-09 20:16:05.236382348 +0200
@@ -56,6 +56,11 @@ public:
   // Constructor. (See Pythia.cc file.)
   Pythia(string xmlDir = "../share/Pythia8/xmldoc", bool printBanner = true);
 
+  // Special constructor to copy settings and particle database from another
+  // Pythia object instead of XML files (to speed up multiple initialisations)
+  Pythia(ParticleData& particleDataIn, Settings& settingsIn,
+         bool printBanner = true);
+  
   // Destructor. (See Pythia.cc file.)
   ~Pythia();
 
@@ -119,7 +124,7 @@ public:
     spacePtr = spacePtrIn; return true;}
 
   // Initialize.
-  bool init();
+  bool init(ostream& os = cout);
 
   // Generate the next event.
   bool next();
diff -rupN pythia_8.212_original/include/Pythia8/Settings.h pythia_8.212_patched_nohepmc/include/Pythia8/Settings.h
--- pythia_8.212_original/include/Pythia8/Settings.h	2015-09-23 17:34:39.000000000 +0200
+++ pythia_8.212_patched_nohepmc/include/Pythia8/Settings.h	2020-09-09 20:16:05.236382348 +0200
@@ -302,6 +302,9 @@ public:
   void resetMVec(string keyIn);
   void resetPVec(string keyIn);
 
+  // Check initialisation status
+  bool getIsInit() {return isInit;}
+  
 private:
 
   // Pointer to various information on the generation.
diff -rupN pythia_8.212_original/include/Pythia8/SusyLesHouches.h pythia_8.212_patched_nohepmc/include/Pythia8/SusyLesHouches.h
--- pythia_8.212_original/include/Pythia8/SusyLesHouches.h	2015-09-23 17:34:40.000000000 +0200
+++ pythia_8.212_patched_nohepmc/include/Pythia8/SusyLesHouches.h	2020-09-09 20:16:05.236382348 +0200
@@ -14,6 +14,9 @@
 #define Pythia8_SLHA_H
 
 #include "Pythia8/PythiaStdlib.h"
+// NOTE: Gambit hack to include slhaea support
+// SLHAea (for SLHA input from an SLHAea object instead of a file)
+#include "SLHAea/slhaea.h"
 
 namespace Pythia8 {
 
@@ -387,11 +390,13 @@ public:
   //Constructor, with and without filename.
   SusyLesHouches(int verboseIn=1) : verboseSav(verboseIn),
     headerPrinted(false), footerPrinted(false), filePrinted(false),
-    slhaRead(false), lhefRead(false), lhefSlha(false), useDecay(true) {};
+    slhaRead(false), lhefRead(false), lhefSlha(false), useDecay(true),
+    slhaeaCollPtr(NULL) {}; // NOTE: <== slhaeaCollPtr is a Gambit hack
   SusyLesHouches(string filename, int verboseIn=1) : verboseSav(verboseIn),
     headerPrinted(false), footerPrinted(false), filePrinted(false),
-    slhaRead(true), lhefRead(false), lhefSlha(false), useDecay(true)
-    {readFile(filename);};
+    slhaRead(true), lhefRead(false), lhefSlha(false), useDecay(true),
+    slhaeaCollPtr(NULL) {readFile(filename);}; // NOTE: <== slhaeaCollPtr is a Gambit hack
+
 
   //***************************** SLHA FILE I/O *****************************//
   // Read and write SLHA files
@@ -400,6 +405,8 @@ public:
   int readFile(istream& ,int verboseIn=1,
     bool useDecayIn=true);
   //int writeFile(string filename): write SLHA file on filename
+  // NOTE: Gambit hack to include slhaea support
+  void setSLHAea(const SLHAea::Coll* inputSLHAea) { slhaeaCollPtr = inputSLHAea; }
 
   //Output utilities
   void printHeader();   // print Header
@@ -641,6 +648,9 @@ private:
   int verboseSav;
   bool headerPrinted, footerPrinted, filePrinted;
   bool slhaRead, lhefRead, lhefSlha, useDecay;
+// NOTE: Gambit hack to include slhaea support
+  // SLHAea Collection (for SLHA input from a SLHAea::Coll instead of a file)
+  const SLHAea::Coll* slhaeaCollPtr;
 
 };
 
diff -rupN pythia_8.212_original/include/Pythia8Plugins/GeneratorInput.h pythia_8.212_patched_nohepmc/include/Pythia8Plugins/GeneratorInput.h
--- pythia_8.212_original/include/Pythia8Plugins/GeneratorInput.h	2015-09-23 17:34:41.000000000 +0200
+++ pythia_8.212_patched_nohepmc/include/Pythia8Plugins/GeneratorInput.h	2020-09-09 20:17:55.633040729 +0200
@@ -202,1045 +202,6 @@ private:
 
 };
 
-//==========================================================================
-
-// Main implementation of AlpgenPar class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-//--------------------------------------------------------------------------
-
-// Constants: could be changed here if desired, but normally should not.
-// These are of technical nature, as described for each.
-
-// A zero threshold value for double comparisons.
-const double AlpgenPar::ZEROTHRESHOLD = 1e-10;
-
-//--------------------------------------------------------------------------
-
-// Warn if e/pT imbalance greater than these values
-// Parse an incoming Alpgen parameter file string
-
-inline bool AlpgenPar::parse(const string paramStr) {
-
-  // Read par file in blocks:
-  //   0 - process information
-  //   1 - run parameters
-  //   2 - cross sections
-  int block = 0;
-
-  // Loop over incoming lines
-  stringstream paramStream(paramStr);
-  string line;
-  while (getline(paramStream, line)) {
-
-    // Change to 'run parameters' block
-    if        (line.find("run parameters") != string::npos) {
-      block = 1;
-
-    // End of 'run parameters' block
-    } else if (line.find("end parameters") != string::npos) {
-      block = 2;
-
-    // Do not extract anything from block 0 so far
-    } else if (block == 0) {
-
-    // Block 1 or 2: extract parameters
-    } else {
-      extractRunParam(line);
-
-    }
-  } // while (getline(paramStream, line))
-
-  return true;
-}
-
-//--------------------------------------------------------------------------
-
-// Parse an incoming parameter line
-
-inline void AlpgenPar::extractRunParam(string line) {
-
-  // Extract information to the right of the final '!' character
-  size_t idx = line.rfind("!");
-  if (idx == string::npos) return;
-  string paramName = trim(line.substr(idx + 1));
-  string paramVal  = trim(line.substr(0, idx));
-  istringstream iss(paramVal);
-
-  // Special case: 'hard process code' - single integer input
-  double val;
-  if (paramName == "hard process code") {
-    iss >> val;
-    warnParamOverwrite("hpc", val);
-    params["hpc"] = val;
-
-  // Special case: 'Crosssection +- error (pb)' - two double values
-  } else if (paramName.find("Crosssection") == 0) {
-    double xerrup;
-    iss >> val >> xerrup;
-    warnParamOverwrite("xsecup", val);
-    warnParamOverwrite("xerrup", val);
-    params["xsecup"] = val;
-    params["xerrup"] = xerrup;
-
-  // Special case: 'unwtd events, lum (pb-1)' - integer and double values
-  } else if (paramName.find("unwtd events") == 0) {
-    int nevent;
-    iss >> nevent >> val;
-    warnParamOverwrite("nevent", val);
-    warnParamOverwrite("lum", val);
-    params["nevent"] = nevent;
-    params["lum"]    = val;
-
-  // Special case: 'mc,mb,...' - split on ',' for name and ' ' for values
-  } else if (paramName.find(",") != string::npos) {
-
-    // Simple tokeniser
-    string        paramNameNow;
-    istringstream issName(paramName);
-    while (getline(issName, paramNameNow, ',')) {
-      iss >> val;
-      warnParamOverwrite(paramNameNow, val);
-      params[paramNameNow] = val;
-    }
-
-  // Default case: assume integer and double on the left
-  } else {
-    int paramIdx;
-    iss >> paramIdx >> val;
-    warnParamOverwrite(paramName, val);
-    params[paramName] = val;
-  }
-}
-
-//--------------------------------------------------------------------------
-
-// Print parameters read from the '.par' file
-
-inline void AlpgenPar::printParams() {
-
-  // Loop over all stored parameters and print
-  cout << fixed << setprecision(3) << endl
-       << " *-------  Alpgen parameters  -------*" << endl;
-  for (map < string, double >::iterator it = params.begin();
-       it != params.end(); ++it)
-    cout << " |  " << left << setw(13) << it->first
-         << "  |  " << right << setw(13) << it->second
-         << "  |" << endl;
-  cout << " *-----------------------------------*" << endl;
-}
-
-//--------------------------------------------------------------------------
-
-// Warn if a parameter is going to be overwriten
-
-inline void AlpgenPar::warnParamOverwrite(const string &paramIn, double val) {
-
-  // Check if present and if new value is different
-  if (haveParam(paramIn) &&
-      abs(getParam(paramIn) - val) > ZEROTHRESHOLD) {
-    if (infoPtr) infoPtr->errorMsg("Warning in LHAupAlpgen::"
-        "warnParamOverwrite: overwriting existing parameter", paramIn);
-  }
-}
-
-//--------------------------------------------------------------------------
-
-// Simple string trimmer
-
-inline string AlpgenPar::trim(string s) {
-
-  // Remove whitespace in incoming string
-  size_t i;
-  if ((i = s.find_last_not_of(" \t\r\n")) != string::npos)
-    s = s.substr(0, i + 1);
-  if ((i = s.find_first_not_of(" \t\r\n")) != string::npos)
-    s = s.substr(i);
-  return s;
-}
-
-//==========================================================================
-
-// Main implementation of LHAupAlpgen class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-// ----------------------------------------------------------------------
-
-// Constants: could be changed here if desired, but normally should not.
-// These are of technical nature, as described for each.
-
-// Debug flag to print all particles in each event.
-const bool LHAupAlpgen::LHADEBUG        = false;
-
-// Debug flag to print particles when an e/p imbalance is found.
-const bool LHAupAlpgen::LHADEBUGRESCALE = false;
-
-// A zero threshold value for double comparisons.
-const double LHAupAlpgen::ZEROTHRESHOLD   = 1e-10;
-
-// Warn if e/pT imbalance greater than these values
-const double LHAupAlpgen::EWARNTHRESHOLD  = 3e-3;
-const double LHAupAlpgen::PTWARNTHRESHOLD = 1e-3;
-
-// If incoming e/pZ is 0, it is reset to this value
-const double LHAupAlpgen::INCOMINGMIN     = 1e-3;
-
-// ----------------------------------------------------------------------
-
-// Constructor. Opens parameter file and parses then opens event file.
-
-LHAupAlpgen::LHAupAlpgen(const char* baseFNin, Info* infoPtrIn)
-  : baseFN(baseFNin), alpgenPar(infoPtrIn), isUnw(NULL) {
-
-  // Set the info pointer if given
-  if (infoPtrIn) setPtr(infoPtrIn);
-
-  // Read in '_unw.par' file to get parameters
-  ifstream  ifsPar;
-  istream*  isPar = NULL;
-
-  // Try gzip file first then normal file afterwards
-#ifdef GZIPSUPPORT
-  parFN = baseFN + "_unw.par.gz";
-  isPar = openFile(parFN.c_str(), ifsPar);
-  if (!ifsPar.is_open()) closeFile(isPar, ifsPar);
-#endif
-  if (isPar == NULL) {
-    parFN = baseFN + "_unw.par";
-    isPar = openFile(parFN.c_str(), ifsPar);
-    if (!ifsPar.is_open()) {
-      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::LHAupAlpgen: "
-          "cannot open parameter file", parFN);
-      closeFile(isPar, ifsPar);
-      return;
-    }
-  }
-
-  // Read entire contents into string and close file
-  string paramStr((std::istreambuf_iterator<char>(isPar->rdbuf())),
-                   std::istreambuf_iterator<char>());
-
-  // Make sure we reached EOF and not other error
-  if (ifsPar.bad()) {
-    if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::LHAupAlpgen: "
-        "cannot read parameter file", parFN);
-    return;
-  }
-  closeFile(isPar, ifsPar);
-
-  // Parse file and set LHEF header
-  alpgenPar.parse(paramStr);
-  if (infoPtr) setInfoHeader("AlpgenPar", paramStr);
-
-  // Open '.unw' events file (with possible gzip support)
-#ifdef GZIPSUPPORT
-  unwFN = baseFN + ".unw.gz";
-  isUnw = openFile(unwFN.c_str(), ifsUnw);
-  if (!ifsUnw.is_open()) closeFile(isUnw, ifsUnw);
-#endif
-  if (isUnw == NULL) {
-    unwFN = baseFN + ".unw";
-    isUnw = openFile(unwFN.c_str(), ifsUnw);
-    if (!ifsUnw.is_open()) {
-      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::LHAupAlpgen: "
-          "cannot open event file", unwFN);
-      closeFile(isUnw, ifsUnw);
-    }
-  }
-}
-
-// ----------------------------------------------------------------------
-
-// setInit is a virtual method that must be finalised here.
-// Sets up beams, strategy and processes.
-
-inline bool LHAupAlpgen::setInit() {
-
-  // Check that all required parameters are present
-  if (!alpgenPar.haveParam("ih2") || !alpgenPar.haveParam("ebeam")  ||
-      !alpgenPar.haveParam("hpc") || !alpgenPar.haveParam("xsecup") ||
-      !alpgenPar.haveParam("xerrup")) {
-    if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setInit: "
-        "missing input parameters");
-    return false;
-  }
-
-  // Beam IDs
-  int ih2 = alpgenPar.getParamAsInt("ih2");
-  int idbmupA = 2212;
-  int idbmupB = (ih2 == 1) ? 2212 : -2212;
-
-  // Beam energies
-  double ebeam = alpgenPar.getParam("ebeam");
-  ebmupA = ebeam;
-  ebmupB = ebmupA;
-
-  // PDF group and set (at the moment not set)
-  int pdfgupA = 0, pdfsupA = 0;
-  int pdfgupB = 0, pdfsupB = 0;
-
-  // Strategy is for unweighted events and xmaxup not important
-  int    idwtup = 3;
-  double xmaxup = 0.;
-
-  // Get hard process code
-  lprup = alpgenPar.getParamAsInt("hpc");
-
-  // Check for unsupported processes
-  if (lprup == 7 || lprup == 8 || lprup == 13) {
-    if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setInit: "
-        "process not implemented");
-    return false;
-  }
-
-  // Depending on the process code, get heavy flavour information:
-  //    6 = QQbar           + jets
-  //    7 = QQbar + Q'Qbar' + jets
-  //    8 = QQbar + Higgs   + jets
-  //   16 = QQbar + gamma   + jets
-  if (lprup == 6 || lprup == 7 || lprup == 8 || lprup == 16) {
-    if (!alpgenPar.haveParam("ihvy")) {
-      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setInit: "
-          "heavy flavour information not present");
-      return false;
-    }
-    ihvy1 = alpgenPar.getParamAsInt("ihvy");
-
-  } else ihvy1 = -1;
-  if (lprup == 7) {
-    if (!alpgenPar.haveParam("ihvy2")) {
-      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setInit: "
-          "heavy flavour information not present");
-      return false;
-    }
-    ihvy2 = alpgenPar.getParamAsInt("ihvy2");
-  } else ihvy2 = -1;
-  // For single top (process 13), get b mass to set incoming
-  mb = -1.;
-  if (lprup == 13) {
-    if (!alpgenPar.haveParam("mb")) {
-      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setInit: "
-          "heavy flavour information not present");
-      return false;
-    }
-    mb = alpgenPar.getParam("mb");
-  }
-
-  // Set the beams
-  setBeamA(idbmupA, ebmupA, pdfgupA, pdfsupA);
-  setBeamB(idbmupB, ebmupB, pdfgupB, pdfsupB);
-  setStrategy(idwtup);
-
-  // Add the process
-  double xsecup = alpgenPar.getParam("xsecup");
-  double xerrup = alpgenPar.getParam("xerrup");
-  addProcess(lprup, xsecup, xerrup, xmaxup);
-  xSecSumSave = xsecup;
-  xErrSumSave = xerrup;
-
-  // All okay
-  return true;
-}
-
-// ----------------------------------------------------------------------
-
-// setEvent is a virtual method that must be finalised here.
-// Read in an event from the 'unw' file and setup.
-
-inline bool LHAupAlpgen::setEvent(int) {
-
-  // Read in the first line of the event
-  int    nEvent, iProc, nParton;
-  double Swgt, Sq;
-  string line;
-  if (!getline(*isUnw, line)) {
-    // Read was bad
-    if (ifsUnw.bad()) {
-      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setEvent: "
-          "could not read events from file");
-      return false;
-    }
-    // End of file reached
-    if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setEvent: "
-        "end of file reached");
-    return false;
-  }
-  istringstream iss1(line);
-  iss1 >> nEvent >> iProc >> nParton >> Swgt >> Sq;
-
-  // Set the process details (ignore alphaQED and alphaQCD parameters)
-  double wgtT = Swgt, scaleT = Sq;
-  setProcess(lprup, wgtT, scaleT);
-
-  // Incoming flavour and x information for later
-  int    id1T, id2T;
-  double x1T, x2T;
-  // Temporary storage for read in parton information
-  int    idT, statusT, mother1T, mother2T, col1T, col2T;
-  double pxT, pyT, pzT, eT, mT;
-  // Leave tau and spin as default values
-  double tauT = 0., spinT = 9.;
-
-  // Store particles locally at first so that resonances can be added
-  myParticles.clear();
-
-  // Now read in partons
-  for (int i = 0; i < nParton; i++) {
-    // Get the next line
-    if (!getline(*isUnw, line)) {
-      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setEvent: "
-          "could not read events from file");
-      return false;
-    }
-    istringstream iss2(line);
-
-    // Incoming (flavour, colour, anticolour, pz)
-    if (i < 2) {
-      // Note that mothers will be set automatically by Pythia, and LHA
-      // status -1 is for an incoming parton
-      iss2 >> idT >> col1T >> col2T >> pzT;
-      statusT  = -1;
-      mother1T = mother2T = 0;
-      pxT = pyT = mT = 0.;
-      eT  = abs(pzT);
-
-      // Adjust when zero pz/e
-      if (pzT == 0.) {
-        pzT = (i == 0) ? INCOMINGMIN : -INCOMINGMIN;
-        eT  = INCOMINGMIN;
-      }
-
-    // Outgoing (flavour, colour, anticolour, px, py, pz, mass)
-    } else {
-      // Note that mothers 1 and 2 corresport to the incoming partons,
-      // as set above, and LHA status +1 is for outgoing final state
-      iss2 >> idT >> col1T >> col2T >> pxT >> pyT >> pzT >> mT;
-      statusT  = 1;
-      mother1T = 1;
-      mother2T = 2;
-      eT = sqrt(max(0., pxT*pxT + pyT*pyT + pzT*pzT + mT*mT));
-    }
-
-    // Add particle
-    myParticles.push_back(LHAParticle(
-        idT, statusT, mother1T, mother2T, col1T, col2T,
-        pxT, pyT, pzT, eT, mT, tauT, spinT,-1.));
-  }
-
-  // Add resonances if required
-  if (!addResonances()) return false;
-
-  // Rescale momenta if required (must be done after full event
-  // reconstruction in addResonances)
-  if (!rescaleMomenta()) return false;
-
-  // Pass particles on to Pythia
-  for (size_t i = 0; i < myParticles.size(); i++)
-    addParticle(myParticles[i]);
-
-  // Set incoming flavour/x information and done
-  id1T = myParticles[0].idPart;
-  x1T  = myParticles[0].ePart / ebmupA;
-  id2T = myParticles[1].idPart;
-  x2T  = myParticles[1].ePart / ebmupA;
-  setIdX(id1T, id2T, x1T, x2T);
-  setPdf(id1T, id2T, x1T, x2T, 0., 0., 0., false);
-  return true;
-}
-
-// ----------------------------------------------------------------------
-
-// Print list of particles; mainly intended for debugging
-
-inline void LHAupAlpgen::printParticles() {
-
-  cout << endl << "---- LHAupAlpgen particle listing begin ----" << endl;
-  cout << scientific << setprecision(6);
-  for (int i = 0; i < int(myParticles.size()); i++) {
-    cout << setw(5)  << i
-         << setw(5)  << myParticles[i].idPart
-         << setw(5)  << myParticles[i].statusPart
-         << setw(15) << myParticles[i].pxPart
-         << setw(15) << myParticles[i].pyPart
-         << setw(15) << myParticles[i].pzPart
-         << setw(15) << myParticles[i].ePart
-         << setw(15) << myParticles[i].mPart
-         << setw(5)  << myParticles[i].mother1Part - 1
-         << setw(5)  << myParticles[i].mother2Part - 1
-         << setw(5)  << myParticles[i].col1Part
-         << setw(5)  << myParticles[i].col2Part
-         << endl;
-  }
-  cout << "----  LHAupAlpgen particle listing end  ----" << endl;
-}
-
-// ----------------------------------------------------------------------
-
-// Routine to add resonances to an incoming event based on the
-// hard process code (now stored in lprup).
-
-inline bool LHAupAlpgen::addResonances() {
-
-  // Temporary storage for resonance information
-  int    idT, statusT, mother1T, mother2T, col1T, col2T;
-  double pxT, pyT, pzT, eT, mT;
-  // Leave tau and spin as default values
-  double tauT = 0., spinT = 9.;
-
-  // Alpgen process dependent parts. Processes:
-  //    1 = W        + QQbar         + jets
-  //    2 = Z/gamma* + QQbar         + jets
-  //    3 = W                        + jets
-  //    4 = Z/gamma*                 + jets
-  //   10 = W        + c             + jets
-  //   14 = W        + gamma         + jets
-  //   15 = W        + QQbar + gamma + jets
-  // When QQbar = ttbar, tops are not decayed in these processes.
-  // Explicitly reconstruct W/Z resonances; assumption is that the
-  // decay products are the last two particles.
-  if (lprup <= 4 || lprup == 10 || lprup == 14 || lprup == 15) {
-    // Decay products are the last two entries
-    int i1 = myParticles.size() - 1, i2 = i1 - 1;
-
-    // Follow 'alplib/alpsho.f' procedure to get ID
-    if (myParticles[i1].idPart + myParticles[i2].idPart == 0)
-      idT = 0;
-    else
-      idT = - (myParticles[i1].idPart % 2) - (myParticles[i2].idPart % 2);
-    idT = (idT > 0) ? 24 : (idT < 0) ? -24 : 23;
-
-    // Check that we get the expected resonance type; Z/gamma*
-    if (lprup == 2 || lprup == 4) {
-      if (idT != 23) {
-        if (infoPtr) infoPtr->errorMsg("Error in "
-            "LHAupAlpgen::addResonances: wrong resonance type in event");
-        return false;
-      }
-
-    // W's
-    } else {
-      if (abs(idT) != 24) {
-        if (infoPtr) infoPtr->errorMsg("Error in "
-            "LHAupAlpgen::addResonances: wrong resonance type in event");
-        return false;
-      }
-    }
-
-    // Remaining input
-    statusT  = 2;
-    mother1T = 1;
-    mother2T = 2;
-    col1T = col2T = 0;
-    pxT = myParticles[i1].pxPart + myParticles[i2].pxPart;
-    pyT = myParticles[i1].pyPart + myParticles[i2].pyPart;
-    pzT = myParticles[i1].pzPart + myParticles[i2].pzPart;
-    eT  = myParticles[i1].ePart  + myParticles[i2].ePart;
-    mT  = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
-    myParticles.push_back(LHAParticle(
-        idT, statusT, mother1T, mother2T, col1T, col2T,
-        pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
-
-    // Update decay product mothers (note array size as if from 1)
-    myParticles[i1].mother1Part = myParticles[i2].mother1Part =
-        myParticles.size();
-    myParticles[i1].mother2Part = myParticles[i2].mother2Part = 0;
-
-  // Processes:
-  //    5 = nW + mZ + j gamma + lH + jets
-  //    6 = QQbar         + jets    (QQbar = ttbar)
-  //    8 = QQbar + Higgs + jets    (QQbar = ttbar)
-  //   13 = top   + q               (topprc = 1)
-  //   13 = top   + b               (topprc = 2)
-  //   13 = top   + W     + jets    (topprc = 3)
-  //   13 = top   + W     + b       (topprc = 4)
-  //   16 = QQbar + gamma + jets    (QQbar = ttbar)
-  //
-  // When tops are present, they are decayed to Wb (both the W and b
-  // are not given), with this W also decaying (decay products given).
-  // The top is marked intermediate, the (intermediate) W is
-  // reconstructed from its decay products, and the decay product mothers
-  // updated. The final-state b is reconstructed from (top - W).
-  //
-  // W/Z resonances are given, as well as their decay products. The
-  // W/Z is marked intermediate, and the decay product mothers updated.
-  //
-  // It is always assumed that decay products are at the end.
-  // For processes 5 and 13, it is also assumed that the decay products
-  // are in the same order as the resonances.
-  // For processes 6, 8 and 16, the possibility of the decay products
-  // being out-of-order is also taken into account.
-  } else if ( ((lprup == 6 || lprup == 8 || lprup == 16) && ihvy1 == 6) ||
-              lprup == 5 || lprup == 13) {
-
-    // Go backwards through the particles looking for W/Z/top
-    int idx = myParticles.size() - 1;
-    for (int i = myParticles.size() - 1; i > -1; i--) {
-
-      // W or Z
-      if (myParticles[i].idPart == 23 ||
-          abs(myParticles[i].idPart) == 24) {
-
-        // Check that decay products and resonance match up
-        int flav;
-        if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
-          flav = 0;
-        else
-          flav = - (myParticles[idx].idPart % 2)
-                 - (myParticles[idx - 1].idPart % 2);
-        flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
-        if (flav != myParticles[i].idPart) {
-          if (infoPtr)
-            infoPtr->errorMsg("Error in LHAupAlpgen::addResonance: "
-                "resonance does not match decay products");
-          return false;
-        }
-
-        // Update status/mothers
-        myParticles[i].statusPart      = 2;
-        myParticles[idx  ].mother1Part = i + 1;
-        myParticles[idx--].mother2Part = 0;
-        myParticles[idx  ].mother1Part = i + 1;
-        myParticles[idx--].mother2Part = 0;
-
-      // Top
-      } else if (abs(myParticles[i].idPart) == 6) {
-
-        // Check that decay products and resonance match up
-        int flav;
-        if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
-          flav = 0;
-        else
-          flav = - (myParticles[idx].idPart % 2)
-                 - (myParticles[idx - 1].idPart % 2);
-        flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
-
-        bool outOfOrder = false, wrongFlavour = false;;
-        if ( abs(flav) != 24 ||
-             (flav ==  24 && myParticles[i].idPart !=  6) ||
-             (flav == -24 && myParticles[i].idPart != -6) ) {
-
-          // Processes 5 and 13, order should always be correct
-          if (lprup == 5 || lprup == 13) {
-            wrongFlavour = true;
-
-          // Processes 6, 8 and 16, can have out of order decay products
-          } else {
-
-            // Go back two decay products and retry
-            idx -= 2;
-            if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
-              flav = 0;
-            else
-              flav = - (myParticles[idx].idPart % 2)
-                     - (myParticles[idx - 1].idPart % 2);
-            flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
-
-            // If still the wrong flavour then error
-            if ( abs(flav) != 24 ||
-                 (flav ==  24 && myParticles[i].idPart !=  6) ||
-                 (flav == -24 && myParticles[i].idPart != -6) )
-              wrongFlavour = true;
-            else outOfOrder = true;
-          }
-
-          // Error if wrong flavour
-          if (wrongFlavour) {
-            if (infoPtr)
-              infoPtr->errorMsg("Error in LHAupAlpgen::addResonance: "
-                  "resonance does not match decay products");
-            return false;
-          }
-        }
-
-        // Mark t/tbar as now intermediate
-        myParticles[i].statusPart = 2;
-
-        // New intermediate W+/W-
-        idT      = flav;
-        statusT  = 2;
-        mother1T = i + 1;
-        mother2T = 0;
-        col1T = col2T = 0;
-        pxT = myParticles[idx].pxPart + myParticles[idx - 1].pxPart;
-        pyT = myParticles[idx].pyPart + myParticles[idx - 1].pyPart;
-        pzT = myParticles[idx].pzPart + myParticles[idx - 1].pzPart;
-        eT  = myParticles[idx].ePart  + myParticles[idx - 1].ePart;
-        mT  = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
-        myParticles.push_back(LHAParticle(
-            idT, statusT, mother1T, mother2T, col1T, col2T,
-            pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
-
-        // Update the decay product mothers
-        myParticles[idx  ].mother1Part = myParticles.size();
-        myParticles[idx--].mother2Part = 0;
-        myParticles[idx  ].mother1Part = myParticles.size();
-        myParticles[idx--].mother2Part = 0;
-
-        // New final-state b/bbar
-        idT     = (flav == 24) ? 5 : -5;
-        statusT = 1;
-        // Colour from top
-        col1T   = myParticles[i].col1Part;
-        col2T   = myParticles[i].col2Part;
-        // Momentum from (t/tbar - W+/W-)
-        pxT     = myParticles[i].pxPart - myParticles.back().pxPart;
-        pyT     = myParticles[i].pyPart - myParticles.back().pyPart;
-        pzT     = myParticles[i].pzPart - myParticles.back().pzPart;
-        eT      = myParticles[i].ePart  - myParticles.back().ePart;
-        mT      = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
-        myParticles.push_back(LHAParticle(
-            idT, statusT, mother1T, mother2T, col1T, col2T,
-            pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
-
-        // If decay products were out of order, reset idx to point
-        // at correct decay products
-        if (outOfOrder) idx += 4;
-
-      } // if (abs(myParticles[i].idPart) == 6)
-    } // for (i)
-
-
-  // Processes:
-  //    7 = QQbar + Q'Qbar' + jets (tops are not decayed)
-  //    9 =                   jets
-  //   11 = gamma           + jets
-  //   12 = Higgs           + jets
-  } else if (lprup == 7 || lprup == 9 || lprup == 11 || lprup == 12) {
-    // Nothing to do for these processes
-  }
-
-  // For single top, set incoming b mass if necessary
-  if (lprup == 13) for (int i = 0; i < 2; i++)
-    if (abs(myParticles[i].idPart) == 5) {
-      myParticles[i].mPart = mb;
-      myParticles[i].ePart = sqrt(pow2(myParticles[i].pzPart) + pow2(mb));
-    }
-
-  // Debug output and done.
-  if (LHADEBUG) printParticles();
-  return true;
-
-}
-
-// ----------------------------------------------------------------------
-
-// Routine to rescale momenta to remove any imbalances. The routine
-// assumes that any imbalances are due to decimal output/rounding
-// effects, and are therefore small.
-//
-// First any px/py imbalances are fixed by adjusting all outgoing
-// particles px/py and also updating their energy so mass is fixed.
-// Because incoming pT is zero, changes should be limited to ~0.001.
-//
-// Second, any pz/e imbalances are fixed by scaling the incoming beams
-// (again, no changes to masses required). Because incoming pz/e is not
-// zero, effects can be slightly larger ~0.002/0.003.
-
-inline bool LHAupAlpgen::rescaleMomenta() {
-
-  // Total momenta in/out
-  int  nOut = 0;
-  Vec4 pIn, pOut;
-  for (int i = 0; i < int(myParticles.size()); i++) {
-    Vec4 pNow = Vec4(myParticles[i].pxPart, myParticles[i].pyPart,
-                     myParticles[i].pzPart, myParticles[i].ePart);
-    if (i < 2) pIn += pNow;
-    else if (myParticles[i].statusPart == 1) {
-      nOut++;
-      pOut += pNow;
-    }
-  }
-
-  // pT out to match pT in. Split any imbalances over all outgoing
-  // particles, and scale energies also to keep m^2 fixed.
-  if (abs(pOut.pT() - pIn.pT()) > ZEROTHRESHOLD) {
-    // Differences in px/py
-    double pxDiff = (pOut.px() - pIn.px()) / nOut,
-           pyDiff = (pOut.py() - pIn.py()) / nOut;
-
-    // Warn if resulting changes above warning threshold
-    if (pxDiff > PTWARNTHRESHOLD || pyDiff > PTWARNTHRESHOLD) {
-      if (infoPtr) infoPtr->errorMsg("Warning in LHAupAlpgen::setEvent: "
-          "large pT imbalance in incoming event");
-
-      // Debug printout
-      if (LHADEBUGRESCALE) {
-        printParticles();
-        cout << "pxDiff = " << pxDiff << ", pyDiff = " << pyDiff << endl;
-      }
-    }
-
-    // Adjust all final-state outgoing
-    pOut.reset();
-    for (int i = 2; i < int(myParticles.size()); i++) {
-      if (myParticles[i].statusPart != 1) continue;
-      myParticles[i].pxPart -= pxDiff;
-      myParticles[i].pyPart -= pyDiff;
-      myParticles[i].ePart   = sqrt(max(0., pow2(myParticles[i].pxPart) +
-          pow2(myParticles[i].pyPart) + pow2(myParticles[i].pzPart) +
-          pow2(myParticles[i].mPart)));
-      pOut += Vec4(myParticles[i].pxPart, myParticles[i].pyPart,
-                   myParticles[i].pzPart, myParticles[i].ePart);
-    }
-  }
-
-  // Differences in E/pZ and scaling factors
-  double de = (pOut.e()  - pIn.e());
-  double dp = (pOut.pz() - pIn.pz());
-  double a  = 1 + (de + dp) / 2. / myParticles[0].ePart;
-  double b  = 1 + (de - dp) / 2. / myParticles[1].ePart;
-
-  // Warn if resulting energy changes above warning threshold.
-  // Change in pz less than or equal to change in energy (incoming b
-  // quark can have mass at this stage for process 13). Note that for
-  // very small incoming momenta, the relative adjustment may be large,
-  // but still small in absolute terms.
-  if (abs(a - 1.) * myParticles[0].ePart > EWARNTHRESHOLD ||
-      abs(b - 1.) * myParticles[1].ePart > EWARNTHRESHOLD) {
-    if (infoPtr) infoPtr->errorMsg("Warning in LHAupAlpgen::setEvent: "
-        "large rescaling factor");
-
-    // Debug printout
-    if (LHADEBUGRESCALE) {
-      printParticles();
-      cout << "de = " << de << ", dp = " << dp
-           << ", a = " << a << ", b = " << b << endl
-           << "Absolute energy change for incoming 0 = "
-           << abs(a - 1.) * myParticles[0].ePart << endl
-           << "Absolute energy change for incoming 1 = "
-           << abs(b - 1.) * myParticles[1].ePart << endl;
-    }
-  }
-  myParticles[0].ePart  *= a;
-  myParticles[0].pzPart *= a;
-  myParticles[1].ePart  *= b;
-  myParticles[1].pzPart *= b;
-
-  // Recalculate resonance four vectors
-  for (int i = 0; i < int(myParticles.size()); i++) {
-    if (myParticles[i].statusPart != 2) continue;
-
-    // Only mothers stored in LHA, so go through all
-    Vec4 resVec;
-    for (int j = 0; j < int(myParticles.size()); j++) {
-      if (myParticles[j].mother1Part - 1 != i) continue;
-      resVec += Vec4(myParticles[j].pxPart, myParticles[j].pyPart,
-                     myParticles[j].pzPart, myParticles[j].ePart);
-    }
-
-    myParticles[i].pxPart = resVec.px();
-    myParticles[i].pyPart = resVec.py();
-    myParticles[i].pzPart = resVec.pz();
-    myParticles[i].ePart  = resVec.e();
-  }
-
-  return true;
-}
-
-//==========================================================================
-
-// Main implementation of AlpgenHooks class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-// ----------------------------------------------------------------------
-
-// Constructor: provides the 'Alpgen:file' option by directly
-//              changing the Pythia 'Beams' settings
-
-AlpgenHooks::AlpgenHooks(Pythia &pythia) : LHAagPtr(NULL) {
-
-  // If LHAupAlpgen needed, construct and pass to Pythia
-  string agFile = pythia.settings.word("Alpgen:file");
-  if (agFile != "void") {
-    LHAagPtr = new LHAupAlpgen(agFile.c_str(), &pythia.info);
-    pythia.settings.mode("Beams:frameType", 5);
-    pythia.setLHAupPtr(LHAagPtr);
-  }
-}
-
-// ----------------------------------------------------------------------
-
-// Initialisation routine which is called by pythia.init().
-// This happens after the local pointers have been assigned and after
-// Pythia has processed the Beam information (and therefore LHEF header
-// information has been read in), but before any other internal
-// initialisation. Provides the remaining 'Alpgen:*' options.
-
-inline bool AlpgenHooks::initAfterBeams() {
-
-  // Read in ALPGEN specific configuration variables
-  bool setLightMasses = settingsPtr->flag("Alpgen:setLightMasses");
-  bool setHeavyMasses = settingsPtr->flag("Alpgen:setHeavyMasses");
-  bool setNjet   = settingsPtr->flag("Alpgen:setNjet");
-  bool setMLM    = settingsPtr->flag("Alpgen:setMLM");
-
-  // If ALPGEN parameters are present, then parse in AlpgenPar object
-  AlpgenPar par(infoPtr);
-  string parStr = infoPtr->header("AlpgenPar");
-  if (!parStr.empty()) {
-    par.parse(parStr);
-    par.printParams();
-  }
-
-  // Set masses if requested
-  if (setLightMasses) {
-    if (par.haveParam("mc")) particleDataPtr->m0(4,  par.getParam("mc"));
-    if (par.haveParam("mb")) particleDataPtr->m0(5,  par.getParam("mb"));
-  }
-  if (setHeavyMasses) {
-    if (par.haveParam("mt")) particleDataPtr->m0(6,  par.getParam("mt"));
-    if (par.haveParam("mz")) particleDataPtr->m0(23, par.getParam("mz"));
-    if (par.haveParam("mw")) particleDataPtr->m0(24, par.getParam("mw"));
-    if (par.haveParam("mh")) particleDataPtr->m0(25, par.getParam("mh"));
-  }
-
-  // Set MLM:nJets if requested
-  if (setNjet) {
-    if (par.haveParam("njets"))
-      settingsPtr->mode("JetMatching:nJet", par.getParamAsInt("njets"));
-    else
-      infoPtr->errorMsg("Warning in AlpgenHooks:init: "
-          "no ALPGEN nJet parameter found");
-  }
-
-  // Set MLM merging parameters if requested
-  if (setMLM) {
-    if (par.haveParam("ptjmin") && par.haveParam("drjmin") &&
-        par.haveParam("etajmax")) {
-      double ptjmin = par.getParam("ptjmin");
-      ptjmin = max(ptjmin + 5., 1.2 * ptjmin);
-      settingsPtr->parm("JetMatching:eTjetMin",   ptjmin);
-      settingsPtr->parm("JetMatching:coneRadius", par.getParam("drjmin"));
-      settingsPtr->parm("JetMatching:etaJetMax",  par.getParam("etajmax"));
-
-    // Warn if setMLM requested, but parameters not present
-    } else {
-      infoPtr->errorMsg("Warning in AlpgenHooks:init: "
-          "no ALPGEN merging parameters found");
-    }
-  }
-
-  // Initialisation complete.
-  return true;
-}
-
-//==========================================================================
-
-// Main implementation of MadgraphPar class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-//--------------------------------------------------------------------------
-
-// Constants: could be changed here if desired, but normally should not.
-// These are of technical nature, as described for each.
-
-// A zero threshold value for double comparisons.
-const double MadgraphPar::ZEROTHRESHOLD = 1e-10;
-
-//--------------------------------------------------------------------------
-
-// Parse an incoming Madgraph parameter file string
-
-inline bool MadgraphPar::parse(const string paramStr) {
-
-  // Loop over incoming lines
-  stringstream paramStream(paramStr);
-  string line;
-  while ( getline(paramStream, line) ) extractRunParam(line);
-  return true;
-
-}
-
-//--------------------------------------------------------------------------
-
-// Parse an incoming parameter line
-
-inline void MadgraphPar::extractRunParam(string line) {
-
-  // Extract information to the right of the final '!' character
-  size_t idz = line.find("#");
-  if ( !(idz == string::npos) ) return;
-  size_t idx = line.find("=");
-  size_t idy = line.find("!");
-  if (idy == string::npos) idy = line.size();
-  if (idx == string::npos) return;
-  string paramName = trim( line.substr( idx + 1, idy - idx - 1) );
-  string paramVal  = trim( line.substr( 0, idx) );
-  replace( paramVal.begin(), paramVal.end(), 'd', 'e');
-
-  // Simple tokeniser
-  istringstream iss(paramVal);
-  double val;
-  if (paramName.find(",") != string::npos) {
-    string        paramNameNow;
-    istringstream issName( paramName);
-    while ( getline(issName, paramNameNow, ',') ) {
-      iss >> val;
-      warnParamOverwrite( paramNameNow, val);
-      params[paramNameNow] = val;
-    }
-
-  // Default case: assume integer and double on the left
-  } else {
-    iss >> val;
-    warnParamOverwrite( paramName, val);
-    params[paramName] = val;
-  }
-}
-
-//--------------------------------------------------------------------------
-
-// Print parameters read from the '.par' file
-
-inline void MadgraphPar::printParams() {
-
-  // Loop over all stored parameters and print
-  cout << endl
-       << " *--------  Madgraph parameters  --------*" << endl;
-  for (map<string,double>::iterator it = params.begin();
-       it != params.end(); ++it)
-    cout << " |  " << left << setw(15) << it->first
-         << "  |  " << right << setw(15) << it->second
-         << "  |" << endl;
-  cout << " *---------------------------------------*" << endl;
-}
-
-//--------------------------------------------------------------------------
-
-// Warn if a parameter is going to be overwriten
-
-inline void MadgraphPar::warnParamOverwrite(const string &paramIn,
-  double val) {
-
-  // Check if present and if new value is different
-  if (haveParam(paramIn) &&
-      abs(getParam(paramIn) - val) > ZEROTHRESHOLD) {
-    if (infoPtr) infoPtr->errorMsg("Warning in LHAupAlpgen::"
-        "warnParamOverwrite: overwriting existing parameter", paramIn);
-  }
-}
-
-//--------------------------------------------------------------------------
-
-// Simple string trimmer
-
-inline string MadgraphPar::trim(string s) {
-
-  // Remove whitespace in incoming string
-  size_t i;
-  if ( (i = s.find_last_not_of(" \t\r\n")) != string::npos)
-    s = s.substr(0, i + 1);
-  if ( (i = s.find_first_not_of(" \t\r\n")) != string::npos)
-    s = s.substr(i);
-  return s;
-}
-
-//==========================================================================
-
 } // end namespace Pythia8
 
 #endif //  Pythia8_GeneratorInput_H
diff -rupN pythia_8.212_original/include/Pythia8Plugins/JetMatching.h pythia_8.212_patched_nohepmc/include/Pythia8Plugins/JetMatching.h
--- pythia_8.212_original/include/Pythia8Plugins/JetMatching.h	2015-09-23 17:34:41.000000000 +0200
+++ pythia_8.212_patched_nohepmc/include/Pythia8Plugins/JetMatching.h	2020-09-09 20:18:04.609091765 +0200
@@ -234,1476 +234,6 @@ protected:
 
 };
 
-//==========================================================================
-
-// Main implementation of JetMatching class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-//--------------------------------------------------------------------------
-
-// Constants to be changed for debug printout or extra checks.
-const bool JetMatching::MATCHINGDEBUG = false;
-const bool JetMatching::MATCHINGCHECK = false;
-
-//--------------------------------------------------------------------------
-
-// Early parton level veto (before beam remnants and resonance showers)
-
-inline bool JetMatching::doVetoPartonLevelEarly(const Event& event) {
-
-  // 1) Sort the original incoming process. After this step is performed,
-  //    the following assignments have been made:
-  //    eventProcessOrig - the original incoming process
-  //    eventProcess     - the final-state of the incoming process with
-  //                       resonance decays removed (and resonances
-  //                       themselves now with positive status code)
-  //    typeIdx[0/1/2]   - Indices into 'eventProcess' of
-  //                       light jets/heavy jets/other
-  //    typeSet[0/1/2]   - Indices into 'event' of light jets/heavy jets/other
-  //    workEvent        - partons from the hardest subsystem + ISR + FSR only
-  sortIncomingProcess(event);
-
-  // For the shower-kT scheme, do not perform any veto here, as any vetoing
-  // will already have taken place in doVetoStep.
-  if ( doShowerKt ) return false;
-
-  // Debug printout.
-  if (MATCHINGDEBUG) {
-    // Begin
-    cout << endl << "-------- Begin Madgraph Debug --------" << endl;
-    // Original incoming process
-    cout << endl << "Original incoming process:";
-    eventProcessOrig.list();
-    // Final-state of original incoming process
-    cout << endl << "Final-state incoming process:";
-    eventProcess.list();
-    // List categories of sorted particles
-    for (size_t i = 0; i < typeIdx[0].size(); i++)
-      cout << ((i == 0) ? "Light jets: " : ", ")   << setw(3) << typeIdx[0][i];
-    if( typeIdx[0].size()== 0 )
-      cout << "Light jets: None";
-
-    for (size_t i = 0; i < typeIdx[1].size(); i++)
-      cout << ((i == 0) ? "\nHeavy jets: " : ", ") << setw(3) << typeIdx[1][i];
-    for (size_t i = 0; i < typeIdx[2].size(); i++)
-      cout << ((i == 0) ? "\nOther:      " : ", ") << setw(3) << typeIdx[2][i];
-    // Full event at this stage
-    cout << endl << endl << "Event:";
-    event.list();
-    // Work event (partons from hardest subsystem + ISR + FSR)
-    cout << endl << "Work event:";
-    workEvent.list();
-  }
-
-  // 2) Light/heavy jets: iType = 0 (light jets), 1 (heavy jets)
-  int iTypeEnd = (typeIdx[1].empty()) ? 1 : 2;
-  for (int iType = 0; iType < iTypeEnd; iType++) {
-
-    // 2a) Find particles which will be passed from the jet algorithm.
-    //     Input from 'workEvent' and output in 'workEventJet'.
-    jetAlgorithmInput(event, iType);
-
-    // Debug printout.
-    if (MATCHINGDEBUG) {
-      // Jet algorithm event
-      cout << endl << "Jet algorithm event (iType = " << iType << "):";
-      workEventJet.list();
-    }
-
-    // 2b) Run jet algorithm on 'workEventJet'.
-    //     Output is stored in jetMomenta.
-    runJetAlgorithm();
-
-    // 2c) Match partons to jets and decide if veto is necessary
-    if (matchPartonsToJets(iType) == true) {
-      // Debug printout.
-      if (MATCHINGDEBUG) {
-        cout << endl << "Event vetoed" << endl
-             << "----------  End MLM Debug  ----------" << endl;
-      }
-      return true;
-    }
-  }
-
-  // Debug printout.
-  if (MATCHINGDEBUG) {
-    cout << endl << "Event accepted" << endl
-         << "----------  End MLM Debug  ----------" << endl;
-  }
-
-  // If we reached here, then no veto
-  return false;
-
-}
-
-//==========================================================================
-
-// Main implementation of Alpgen UserHooks class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-//--------------------------------------------------------------------------
-
-// Constants: could be changed here if desired, but normally should not.
-// These are of technical nature, as described for each.
-
-// The energy of ghost particles. For technical reasons, this cannot be
-// set arbitrarily low, see 'Particle::TINY' in 'Event.cc' for details.
-const double JetMatchingAlpgen::GHOSTENERGY   = 1e-15;
-
-// A zero threshold value for double comparisons.
-const double JetMatchingAlpgen::ZEROTHRESHOLD = 1e-10;
-
-//--------------------------------------------------------------------------
-
-// Function to sort typeIdx vectors into descending eT/pT order.
-// Uses a selection sort, as number of partons generally small
-// and so efficiency not a worry.
-
-inline void JetMatchingAlpgen::sortTypeIdx(vector < int > &vecIn) {
-  for (size_t i = 0; i < vecIn.size(); i++) {
-    size_t jMax = i;
-    double vMax = (jetAlgorithm == 1) ?
-      eventProcess[vecIn[i]].eT() :
-      eventProcess[vecIn[i]].pT();
-    for (size_t j = i + 1; j < vecIn.size(); j++) {
-      double vNow = (jetAlgorithm == 1)
-        ? eventProcess[vecIn[j]].eT() : eventProcess[vecIn[j]].pT();
-      if (vNow > vMax) {
-        vMax = vNow;
-        jMax = j;
-      }
-    }
-    if (jMax != i) swap(vecIn[i], vecIn[jMax]);
-  }
-}
-
-//--------------------------------------------------------------------------
-
-// Initialisation routine automatically called from Pythia::init().
-// Setup all parts needed for the merging.
-
-inline bool JetMatchingAlpgen::initAfterBeams() {
-
-  // Read in parameters
-  doMerge         = settingsPtr->flag("JetMatching:merge");
-  jetAlgorithm    = settingsPtr->mode("JetMatching:jetAlgorithm");
-  nJet            = settingsPtr->mode("JetMatching:nJet");
-  nJetMax         = settingsPtr->mode("JetMatching:nJetMax");
-  eTjetMin        = settingsPtr->parm("JetMatching:eTjetMin");
-  coneRadius      = settingsPtr->parm("JetMatching:coneRadius");
-  etaJetMax       = settingsPtr->parm("JetMatching:etaJetMax");
-  doShowerKt      = settingsPtr->flag("JetMatching:doShowerKt");
-
-  // Use etaJetMax + coneRadius in input to jet algorithms
-  etaJetMaxAlgo   = etaJetMax + coneRadius;
-
-  // CellJet specific
-  nEta            = settingsPtr->mode("JetMatching:nEta");
-  nPhi            = settingsPtr->mode("JetMatching:nPhi");
-  eTseed          = settingsPtr->parm("JetMatching:eTseed");
-  eTthreshold     = settingsPtr->parm("JetMatching:eTthreshold");
-
-  // SlowJet specific
-  slowJetPower    = settingsPtr->mode("JetMatching:slowJetPower");
-  coneMatchLight  = settingsPtr->parm("JetMatching:coneMatchLight");
-  coneRadiusHeavy = settingsPtr->parm("JetMatching:coneRadiusHeavy");
-  if (coneRadiusHeavy < 0.) coneRadiusHeavy = coneRadius;
-  coneMatchHeavy  = settingsPtr->parm("JetMatching:coneMatchHeavy");
-
-  // Matching procedure
-  jetAllow        = settingsPtr->mode("JetMatching:jetAllow");
-  jetMatch        = settingsPtr->mode("JetMatching:jetMatch");
-  exclusiveMode   = settingsPtr->mode("JetMatching:exclusive");
-
-  // If not merging, then done
-  if (!doMerge) return true;
-
-  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
-  if (exclusiveMode == 2) {
-
-    // No nJet or nJetMax, so default to exclusive mode
-    if (nJet < 0 || nJetMax < 0) {
-      infoPtr->errorMsg("Warning in JetMatchingAlpgen:init: "
-          "missing jet multiplicity information; running in exclusive mode");
-      exclusive = true;
-
-    // Inclusive if nJet == nJetMax, exclusive otherwise
-    } else {
-      exclusive = (nJet == nJetMax) ? false : true;
-    }
-
-  // Otherwise, just set as given
-  } else {
-    exclusive = (exclusiveMode == 0) ? false : true;
-  }
-
-  // Initialise chosen jet algorithm. CellJet.
-  if (jetAlgorithm == 1) {
-
-    // Extra options for CellJet. nSel = 1 means that all final-state
-    // particles are taken and we retain control of what to select.
-    // smear/resolution/upperCut are not used and are set to default values.
-    int    nSel = 2, smear = 0;
-    double resolution = 0.5, upperCut = 2.;
-    cellJet = new CellJet(etaJetMaxAlgo, nEta, nPhi, nSel,
-                          smear, resolution, upperCut, eTthreshold);
-
-  // SlowJet
-  } else if (jetAlgorithm == 2) {
-    slowJet = new SlowJet(slowJetPower, coneRadius, eTjetMin, etaJetMaxAlgo);
-  }
-
-  // Check the jetMatch parameter; option 2 only works with SlowJet
-  if (jetAlgorithm == 1 && jetMatch == 2) {
-    infoPtr->errorMsg("Warning in JetMatchingAlpgen:init: "
-        "jetMatch = 2 only valid with SlowJet algorithm. "
-        "Reverting to jetMatch = 1");
-    jetMatch = 1;
-  }
-
-  // Setup local event records
-  eventProcessOrig.init("(eventProcessOrig)", particleDataPtr);
-  eventProcess.init("(eventProcess)", particleDataPtr);
-  workEventJet.init("(workEventJet)", particleDataPtr);
-
-  // Print information
-  string jetStr  = (jetAlgorithm ==  1) ? "CellJet" :
-                   (slowJetPower == -1) ? "anti-kT" :
-                   (slowJetPower ==  0) ? "C/A"     :
-                   (slowJetPower ==  1) ? "kT"      : "unknown";
-  string modeStr = (exclusive)         ? "exclusive" : "inclusive";
-  stringstream nJetStr, nJetMaxStr;
-  if (nJet >= 0)    nJetStr    << nJet;    else nJetStr    << "unknown";
-  if (nJetMax >= 0) nJetMaxStr << nJetMax; else nJetMaxStr << "unknown";
-  cout << endl
-       << " *-------  MLM matching parameters  -------*" << endl
-       << " |  nJet                |  " << setw(14)
-       << nJetStr.str() << "  |" << endl
-       << " |  nJetMax             |  " << setw(14)
-       << nJetMaxStr.str() << "  |" << endl
-       << " |  Jet algorithm       |  " << setw(14)
-       << jetStr << "  |" << endl
-       << " |  eTjetMin            |  " << setw(14)
-       << eTjetMin << "  |" << endl
-       << " |  coneRadius          |  " << setw(14)
-       << coneRadius << "  |" << endl
-       << " |  etaJetMax           |  " << setw(14)
-       << etaJetMax << "  |" << endl
-       << " |  jetAllow            |  " << setw(14)
-       << jetAllow << "  |" << endl
-       << " |  jetMatch            |  " << setw(14)
-       << jetMatch << "  |" << endl
-       << " |  coneMatchLight      |  " << setw(14)
-       << coneMatchLight << "  |" << endl
-       << " |  coneRadiusHeavy     |  " << setw(14)
-       << coneRadiusHeavy << "  |" << endl
-       << " |  coneMatchHeavy      |  " << setw(14)
-       << coneMatchHeavy << "  |" << endl
-       << " |  Mode                |  " << setw(14)
-       << modeStr << "  |" << endl
-       << " *-----------------------------------------*" << endl;
-
-  return true;
-}
-
-//--------------------------------------------------------------------------
-
-// Step (1): sort the incoming particles
-
-inline void JetMatchingAlpgen::sortIncomingProcess(const Event &event) {
-
-  // Remove resonance decays from original process and keep only final
-  // state. Resonances will have positive status code after this step.
-  omitResonanceDecays(eventProcessOrig, true);
-  eventProcess = workEvent;
-
-  // Sort original process final state into light/heavy jets and 'other'.
-  // Criteria:
-  //   1 <= ID <= 5 and massless, or ID == 21 --> light jet (typeIdx[0])
-  //   4 <= ID <= 6 and massive               --> heavy jet (typeIdx[1])
-  //   All else                               --> other     (typeIdx[2])
-  // Note that 'typeIdx' stores indices into 'eventProcess' (after resonance
-  // decays are omitted), while 'typeSet' stores indices into the original
-  // process record, 'eventProcessOrig', but these indices are also valid
-  // in 'event'.
-  for (int i = 0; i < 3; i++) {
-    typeIdx[i].clear();
-    typeSet[i].clear();
-  }
-  for (int i = 0; i < eventProcess.size(); i++) {
-    // Ignore nonfinal and default to 'other'
-    if (!eventProcess[i].isFinal()) continue;
-    int idx = 2;
-
-    // Light jets
-    if (eventProcess[i].id() == ID_GLUON
-      || (eventProcess[i].idAbs() <= ID_BOT
-      && abs(eventProcess[i].m()) < ZEROTHRESHOLD)) idx = 0;
-
-    // Heavy jets
-    else if (eventProcess[i].idAbs() >= ID_CHARM
-      && eventProcess[i].idAbs() <= ID_TOP) idx = 1;
-
-    // Store
-    typeIdx[idx].push_back(i);
-    typeSet[idx].insert(eventProcess[i].daughter1());
-  }
-
-  // Extract partons from hardest subsystem + ISR + FSR only into
-  // workEvent. Note no resonance showers or MPIs.
-  subEvent(event);
-}
-
-//--------------------------------------------------------------------------
-
-// Step (2a): pick which particles to pass to the jet algorithm
-
-inline void JetMatchingAlpgen::jetAlgorithmInput(const Event &event,
-  int iType) {
-
-  // Take input from 'workEvent' and put output in 'workEventJet'
-  workEventJet = workEvent;
-
-  // Loop over particles and decide what to pass to the jet algorithm
-  for (int i = 0; i < workEventJet.size(); ++i) {
-    if (!workEventJet[i].isFinal()) continue;
-
-    // jetAllow option to disallow certain particle types
-    if (jetAllow == 1) {
-
-      // Original AG+Py6 algorithm explicitly excludes tops,
-      // leptons and photons.
-      int id = workEventJet[i].idAbs();
-      if ( (id >= ID_LEPMIN && id <= ID_LEPMAX) || id == ID_TOP
-        || id == ID_PHOTON) {
-        workEventJet[i].statusNeg();
-        continue;
-      }
-    }
-
-    // Get the index of this particle in original event
-    int idx = workEventJet[i].daughter1();
-
-    // Start with particle idx, and afterwards track mothers
-    while (true) {
-
-      // Light jets
-      if (iType == 0) {
-
-        // Do not include if originates from heavy jet or 'other'
-        if (typeSet[1].find(idx) != typeSet[1].end() ||
-            typeSet[2].find(idx) != typeSet[2].end()) {
-          workEventJet[i].statusNeg();
-          break;
-        }
-
-        // Made it to start of event record so done
-        if (idx == 0) break;
-        // Otherwise next mother and continue
-        idx = event[idx].mother1();
-
-      // Heavy jets
-      } else if (iType == 1) {
-
-        // Only include if originates from heavy jet
-        if (typeSet[1].find(idx) != typeSet[1].end()) break;
-
-        // Made it to start of event record with no heavy jet mother,
-        // so DO NOT include particle
-        if (idx == 0) {
-          workEventJet[i].statusNeg();
-          break;
-        }
-
-        // Otherwise next mother and continue
-        idx = event[idx].mother1();
-
-      } // if (iType)
-    } // while (true)
-  } // for (i)
-
-  // For jetMatch = 2, insert ghost particles corresponding to
-  // each hard parton in the original process
-  if (jetMatch == 2) {
-    for (int i = 0; i < int(typeIdx[iType].size()); i++) {
-      // Get y/phi of the parton
-      Vec4   pIn = eventProcess[typeIdx[iType][i]].p();
-      double y   = pIn.rap();
-      double phi = pIn.phi();
-
-      // Create a ghost particle and add to the workEventJet
-      double e   = GHOSTENERGY;
-      double e2y = exp(2. * y);
-      double pz  = e * (e2y - 1.) / (e2y + 1.);
-      double pt  = sqrt(e*e - pz*pz);
-      double px  = pt * cos(phi);
-      double py  = pt * sin(phi);
-      workEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0, px, py, pz, e);
-
-      // Extra check on reconstructed y/phi values. If many warnings
-      // of this type, GHOSTENERGY may be set too low.
-      if (MATCHINGCHECK) {
-      int lastIdx = workEventJet.size() - 1;
-      if (abs(y   - workEventJet[lastIdx].y())   > ZEROTHRESHOLD ||
-          abs(phi - workEventJet[lastIdx].phi()) > ZEROTHRESHOLD)
-        infoPtr->errorMsg("Warning in JetMatchingAlpgen:jetAlgorithmInput: "
-            "ghost particle y/phi mismatch");
-      }
-
-    } // for (i)
-  } // if (jetMatch == 2)
-}
-
-//--------------------------------------------------------------------------
-
-// Step (2b): run jet algorithm and provide common output
-
-inline void JetMatchingAlpgen::runJetAlgorithm() {
-
-  // Run the jet clustering algorithm
-  if (jetAlgorithm == 1)
-    cellJet->analyze(workEventJet, eTjetMin, coneRadius, eTseed);
-  else
-    slowJet->analyze(workEventJet);
-
-  // Extract four-momenta of jets with |eta| < etaJetMax and
-  // put into jetMomenta. Note that this is done backwards as
-  // jets are removed with SlowJet.
-  jetMomenta.clear();
-  int iJet = (jetAlgorithm == 1) ? cellJet->size() - 1:
-                                   slowJet->sizeJet() - 1;
-  for (int i = iJet; i > -1; i--) {
-    Vec4 jetMom = (jetAlgorithm == 1) ? cellJet->pMassive(i) :
-                                        slowJet->p(i);
-    double eta = jetMom.eta();
-
-    if (abs(eta) > etaJetMax) {
-      if (jetAlgorithm == 2) slowJet->removeJet(i);
-      continue;
-    }
-    jetMomenta.push_back(jetMom);
-  }
-
-  // Reverse jetMomenta to restore eT/pT ordering
-  reverse(jetMomenta.begin(), jetMomenta.end());
-}
-
-//--------------------------------------------------------------------------
-
-// Step (2c): veto decision (returning true vetoes the event)
-
-inline bool JetMatchingAlpgen::matchPartonsToJets(int iType) {
-
-  // Use two different routines for light/heavy jets as
-  // different veto conditions and for clarity
-  if (iType == 0) return (matchPartonsToJetsLight() > 0);
-  else            return (matchPartonsToJetsHeavy() > 0);
-}
-
-//--------------------------------------------------------------------------
-
-// Step(2c): light jets
-// Return codes are given indicating the reason for a veto.
-// Although not currently used, they are a useful debugging tool:
-//   0 = no veto
-//   1 = veto as number of jets less than number of partons
-//   2 = veto as exclusive mode and number of jets greater than
-//       number of partons
-//   3 = veto as inclusive mode and there would be an extra jet
-//       that is harder than any matched soft jet
-//   4 = veto as there is a parton which does not match a jet
-
-inline int JetMatchingAlpgen::matchPartonsToJetsLight() {
-
-  // Always veto if number of jets is less than original number of jets
-  if (jetMomenta.size() < typeIdx[0].size()) return LESS_JETS;
-  // Veto if in exclusive mode and number of jets bigger than original
-  if (exclusive && jetMomenta.size() > typeIdx[0].size()) return MORE_JETS;
-
-  // Sort partons by eT/pT
-  sortTypeIdx(typeIdx[0]);
-
-  // Number of hard partons
-  int nParton = typeIdx[0].size();
-
-  // Keep track of which jets have been assigned a hard parton
-  vector < bool > jetAssigned;
-  jetAssigned.assign(jetMomenta.size(), false);
-
-  // Jet matching procedure: (1) deltaR between partons and jets
-  if (jetMatch == 1) {
-
-    // Loop over light hard partons and get 4-momentum
-    for (int i = 0; i < nParton; i++) {
-      Vec4 p1 = eventProcess[typeIdx[0][i]].p();
-
-      // Track which jet has the minimal dR measure with this parton
-      int    jMin  = -1;
-      double dRmin = 0.;
-
-      // Loop over all jets (skipping those already assigned).
-      for (int j = 0; j < int(jetMomenta.size()); j++) {
-        if (jetAssigned[j]) continue;
-
-        // DeltaR between parton/jet and store if minimum
-        double dR = (jetAlgorithm == 1)
-          ? REtaPhi(p1, jetMomenta[j]) : RRapPhi(p1, jetMomenta[j]);
-        if (jMin < 0 || dR < dRmin) {
-          dRmin = dR;
-          jMin  = j;
-        }
-      } // for (j)
-
-      // Check for jet-parton match
-      if (jMin >= 0 && dRmin < coneRadius * coneMatchLight) {
-
-        // If the matched jet is not one of the nParton hardest jets,
-        // the extra left over jet would be harder than some of the
-        // matched jets. This is disallowed, so veto.
-        if (jMin >= nParton) return HARD_JET;
-
-        // Mark jet as assigned.
-        jetAssigned[jMin] = true;
-
-      // If no match, then event will be vetoed in all cases
-      } else return UNMATCHED_PARTON;
-
-    } // for (i)
-
-  // Jet matching procedure: (2) ghost particles in SlowJet
-  } else {
-
-    // Loop over added 'ghost' particles and find if assigned to a jet
-    for (int i = workEventJet.size() - nParton;
-        i < workEventJet.size(); i++) {
-      int jMin = slowJet->jetAssignment(i);
-
-      // Veto if:
-      //  1) not one of nParton hardest jets
-      //  2) not assigned to a jet
-      //  3) jet has already been assigned
-      if (jMin >= nParton)               return HARD_JET;
-      if (jMin < 0 || jetAssigned[jMin]) return UNMATCHED_PARTON;
-
-      // Mark jet as assigned
-      jetAssigned[jMin] = true;
-
-    } // for (i)
-  } // if (jetMatch)
-
-  // Minimal eT/pT (CellJet/SlowJet) of matched light jets. Needed
-  // later for heavy jet vetos in inclusive mode.
-  if (nParton > 0)
-    eTpTlightMin = (jetAlgorithm == 1) ? jetMomenta[nParton - 1].eT()
-                                       : jetMomenta[nParton - 1].pT();
-  else
-    eTpTlightMin = -1.;
-
-  // No veto
-  return NONE;
-}
-
-//--------------------------------------------------------------------------
-
-// Step(2c): heavy jets
-// Return codes are given indicating the reason for a veto.
-// Although not currently used, they are a useful debugging tool:
-//   0 = no veto as there are no extra jets present
-//   1 = veto as in exclusive mode and extra jets present
-//   2 = veto as in inclusive mode and extra jets were harder
-//       than any matched light jet
-
-inline int JetMatchingAlpgen::matchPartonsToJetsHeavy() {
-
-  // If there are no extra jets, then accept
-  if (jetMomenta.empty()) return NONE;
-
-  // Number of hard partons
-  int nParton = typeIdx[1].size();
-
-  // Remove jets that are close to heavy quarks
-  set < int > removeJets;
-
-  // Jet matching procedure: (1) deltaR between partons and jets
-  if (jetMatch == 1) {
-
-    // Loop over heavy hard partons and get 4-momentum
-    for (int i = 0; i < nParton; i++) {
-      Vec4 p1 = eventProcess[typeIdx[1][i]].p();
-
-      // Loop over all jets, find dR and mark for removal if match
-      for (int j = 0; j < int(jetMomenta.size()); j++) {
-        double dR = (jetAlgorithm == 1) ?
-            REtaPhi(p1, jetMomenta[j]) : RRapPhi(p1, jetMomenta[j]);
-        if (dR < coneRadiusHeavy * coneMatchHeavy)
-          removeJets.insert(j);
-
-      } // for (j)
-    } // for (i)
-
-  // Jet matching procedure: (2) ghost particles in SlowJet
-  } else {
-
-    // Loop over added 'ghost' particles and if assigned to a jet
-    // then mark this jet for removal
-    for (int i = workEventJet.size() - nParton;
-        i < workEventJet.size(); i++) {
-      int jMin = slowJet->jetAssignment(i);
-      if (jMin >= 0) removeJets.insert(jMin);
-    }
-
-  }
-
-  // Remove jets (backwards order to not disturb indices)
-  for (set < int >::reverse_iterator it  = removeJets.rbegin();
-                                     it != removeJets.rend(); it++)
-    jetMomenta.erase(jetMomenta.begin() + *it);
-
-  // Handle case if there are still extra jets
-  if (!jetMomenta.empty()) {
-
-    // Exclusive mode, so immediate veto
-    if (exclusive) return MORE_JETS;
-
-    // Inclusive mode; extra jets must be softer than any matched light jet
-    else if (eTpTlightMin >= 0.)
-      for (size_t j = 0; j < jetMomenta.size(); j++) {
-        // CellJet uses eT, SlowJet uses pT
-        if ( (jetAlgorithm == 1 && jetMomenta[j].eT() > eTpTlightMin) ||
-             (jetAlgorithm == 2 && jetMomenta[j].pT() > eTpTlightMin) )
-          return HARD_JET;
-      }
-
-  } // if (!jetMomenta.empty())
-
-  // No extra jets were present so no veto
-  return NONE;
-}
-
-//==========================================================================
-
-// Main implementation of Madgraph UserHooks class.
-// This may be split out to a separate C++ file if desired,
-// but currently included here for ease of use.
-
-//--------------------------------------------------------------------------
-
-// Initialisation routine automatically called from Pythia::init().
-// Setup all parts needed for the merging.
-
-inline bool JetMatchingMadgraph::initAfterBeams() {
-
-  // Read in Madgraph specific configuration variables
-  bool setMad    = settingsPtr->flag("JetMatching:setMad");
-
-  // If Madgraph parameters are present, then parse in MadgraphPar object
-  MadgraphPar par(infoPtr);
-  string parStr = infoPtr->header("MGRunCard");
-  if (!parStr.empty()) {
-    par.parse(parStr);
-    par.printParams();
-  }
-
-  // Set Madgraph merging parameters from the file if requested
-  if (setMad) {
-    if ( par.haveParam("xqcut")    && par.haveParam("maxjetflavor")
-      && par.haveParam("alpsfact") && par.haveParam("ickkw") ) {
-      settingsPtr->flag("JetMatching:merge", par.getParam("ickkw"));
-      settingsPtr->parm("JetMatching:qCut", par.getParam("xqcut"));
-      settingsPtr->mode("JetMatching:nQmatch",
-        par.getParamAsInt("maxjetflavor"));
-      settingsPtr->parm("JetMatching:clFact",
-        clFact = par.getParam("alpsfact"));
-      if (par.getParamAsInt("ickkw") == 0)
-        infoPtr->errorMsg("Error in JetMatchingMadgraph:init: "
-          "Madgraph file parameters are not set for merging");
-
-    // Warn if setMad requested, but one or more parameters not present
-    } else {
-       infoPtr->errorMsg("Warning in JetMatchingMadgraph:init: "
-          "Madgraph merging parameters not found");
-       if (!par.haveParam("xqcut")) infoPtr->errorMsg("Warning in "
-          "JetMatchingMadgraph:init: No xqcut");
-       if (!par.haveParam("ickkw")) infoPtr->errorMsg("Warning in "
-          "JetMatchingMadgraph:init: No ickkw");
-       if (!par.haveParam("maxjetflavor")) infoPtr->errorMsg("Warning in "
-          "JetMatchingMadgraph:init: No maxjetflavor");
-       if (!par.haveParam("alpsfact")) infoPtr->errorMsg("Warning in "
-          "JetMatchingMadgraph:init: No alpsfact");
-    }
-  }
-
-  // Read in FxFx matching parameters
-  doFxFx       = settingsPtr->flag("JetMatching:doFxFx");
-  nPartonsNow  = settingsPtr->mode("JetMatching:nPartonsNow");
-  qCutME       = settingsPtr->parm("JetMatching:qCutME");
-  qCutMESq     = pow(qCutME,2);
-
-  // Read in Madgraph merging parameters
-  doMerge      = settingsPtr->flag("JetMatching:merge");
-  doShowerKt   = settingsPtr->flag("JetMatching:doShowerKt");
-  qCut         = settingsPtr->parm("JetMatching:qCut");
-  nQmatch      = settingsPtr->mode("JetMatching:nQmatch");
-  clFact       = settingsPtr->parm("JetMatching:clFact");
-
-  // Read in jet algorithm parameters
-  jetAlgorithm   = settingsPtr->mode("JetMatching:jetAlgorithm");
-  nJetMax        = settingsPtr->mode("JetMatching:nJetMax");
-  eTjetMin       = settingsPtr->parm("JetMatching:eTjetMin");
-  coneRadius     = settingsPtr->parm("JetMatching:coneRadius");
-  etaJetMax      = settingsPtr->parm("JetMatching:etaJetMax");
-  slowJetPower   = settingsPtr->mode("JetMatching:slowJetPower");
-
-  // Matching procedure
-  jetAllow       = settingsPtr->mode("JetMatching:jetAllow");
-  exclusiveMode  = settingsPtr->mode("JetMatching:exclusive");
-  qCutSq         = pow(qCut,2);
-  etaJetMaxAlgo  = etaJetMax;
-
-  // If not merging, then done
-  if (!doMerge) return true;
-
-  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
-  if (exclusiveMode == 2) {
-
-    // No nJet or nJetMax, so default to exclusive mode
-    if (nJetMax < 0) {
-      infoPtr->errorMsg("Warning in JetMatchingMadgraph:init: "
-        "missing jet multiplicity information; running in exclusive mode");
-      exclusiveMode = 1;
-    }
-  }
-
-  // Initialise chosen jet algorithm.
-  // Currently, this only supports the kT-algorithm in SlowJet.
-  // Use the QCD distance measure by default.
-  jetAlgorithm = 2;
-  slowJetPower = 1;
-  slowJet = new SlowJet(slowJetPower, coneRadius, eTjetMin,
-    etaJetMaxAlgo, 2, 2, NULL, false);
-
-  // For FxFx, also initialise jet algorithm to define matrix element jets.
-  // Currently, this only supports the kT-algorithm in SlowJet.
-  // Use the QCD distance measure by default.
-  slowJetHard = new SlowJet(slowJetPower, coneRadius, qCutME,
-    etaJetMaxAlgo, 2, 2, NULL, false);
-
-  // To access the DJR's
-  slowJetDJR = new SlowJet(slowJetPower, coneRadius, qCutME,
-    etaJetMaxAlgo, 2, 2, NULL, false);
-
-  // Setup local event records
-  eventProcessOrig.init("(eventProcessOrig)", particleDataPtr);
-  eventProcess.init("(eventProcess)", particleDataPtr);
-  workEventJet.init("(workEventJet)", particleDataPtr);
-
-  // Print information
-  string jetStr  = (jetAlgorithm ==  1) ? "CellJet" :
-                   (slowJetPower == -1) ? "anti-kT" :
-                   (slowJetPower ==  0) ? "C/A"     :
-                   (slowJetPower ==  1) ? "kT"      : "unknown";
-  string modeStr = (exclusiveMode)         ? "exclusive" : "inclusive";
-  cout << endl
-       << " *-----  Madgraph matching parameters  -----*" << endl
-       << " |  qCut                |  " << setw(14)
-       << qCut << "  |" << endl
-       << " |  nQmatch             |  " << setw(14)
-       << nQmatch << "  |" << endl
-       << " |  clFact              |  " << setw(14)
-       << clFact << "  |" << endl
-       << " |  Jet algorithm       |  " << setw(14)
-       << jetStr << "  |" << endl
-       << " |  eTjetMin            |  " << setw(14)
-       << eTjetMin << "  |" << endl
-       << " |  etaJetMax           |  " << setw(14)
-       << etaJetMax << "  |" << endl
-       << " |  jetAllow            |  " << setw(14)
-       << jetAllow << "  |" << endl
-       << " |  Mode                |  " << setw(14)
-       << modeStr << "  |" << endl
-       << " *-----------------------------------------*" << endl;
-
-  return true;
-}
-
-//--------------------------------------------------------------------------
-
-// Process level vetos
-
-inline bool JetMatchingMadgraph::doVetoProcessLevel(Event& process) {
-
-  eventProcessOrig = process;
-
-  // Setup for veto if hard ME has too many partons.
-  // This is done to achieve consistency with the Pythia6 implementation.
-
-  // Clear the event of MPI systems and resonace decay products. Store trimmed
-  // event in workEvent.
-  sortIncomingProcess(process);
-
-  // Veto in case the hard input matrix element already has too many partons.
-  if ( !doFxFx && int(typeIdx[0].size()) > nJetMax )
-    return true;
-  if ( doFxFx && npNLO() < nJetMax && int(typeIdx[0].size()) > nJetMax )
-    return true;
-
-  // Done
-  return false;
-
-}
-
-//--------------------------------------------------------------------------
-
-inline bool JetMatchingMadgraph::doVetoStep(int iPos, int nISR, int nFSR,
-  const Event& event)  {
-
-  // Do not perform any veto if not in the Shower-kT scheme.
-  if ( !doShowerKt ) return false;
-
-  // Do nothing for emissions after the first one.
-  if ( nISR + nFSR > 1 ) return false;
-
-  // Do nothing in resonance decay showers.
-  if (iPos == 5) return false;
-
-  // Clear the event of MPI systems and resonace decay products. Store trimmed
-  // event in workEvent.
-  sortIncomingProcess(event);
-
-  // Get (kinematical) pT of first emission
-  double pTfirst = 0.;
-
-  // Get weak bosons, for later checks if the emission is a "QCD emission".
-  vector<int> weakBosons;
-  for (int i = 0; i < event.size(); i++) {
-    if ( event[i].id() == 22
-      && event[i].id() == 23
-      && event[i].idAbs() == 24)
-      weakBosons.push_back(i);
-  }
-
-  for (int i =  workEvent.size()-1; i > 0; --i) {
-    if ( workEvent[i].isFinal() && workEvent[i].colType() != 0
-      && (workEvent[i].statusAbs() == 43 || workEvent[i].statusAbs() == 51)) {
-      // Check if any of the EW bosons are ancestors of this parton. This
-      // should never happen for the first non-resonance shower emission.
-      // Check just to be sure.
-      bool QCDemission = true;
-      // Get position of this parton in the actual event (workEvent does
-      // not contain right mother-daughter relations). Stored in daughters.
-      int iPosOld = workEvent[i].daughter1();
-      for (int j = 0; i < int(weakBosons.size()); ++i)
-        if ( event[iPosOld].isAncestor(j)) {
-          QCDemission = false;
-          break;
-        }
-      // Done for a QCD emission.
-      if (QCDemission){
-        pTfirst = workEvent[i].pT();
-        break;
-      }
-    }
-  }
-
-  // Check veto.
-  if ( doShowerKtVeto(pTfirst) ) return true;
-
-  // No veto if come this far.
-  return false;
-
-}
-
-//--------------------------------------------------------------------------
-
-inline bool JetMatchingMadgraph::doShowerKtVeto(double pTfirst) {
-
-  // Only check veto in the shower-kT scheme.
-  if ( !doShowerKt ) return false;
-
-  // Reset veto code
-  bool doVeto = false;
-
-  // Find the (kinematical) pT of the softest (light) parton in the hard
-  // process.
-  int nParton = typeIdx[0].size();
-  double pTminME=1e10;
-  for ( int i = 0; i < nParton; ++i)
-    pTminME = min(pTminME,eventProcess[typeIdx[0][i]].pT());
-
-  // Veto if the softest hard process parton is below Qcut.
-  if ( nParton > 0 && pow(pTminME,2) < qCutSq ) doVeto = true;
-
-  // For non-highest multiplicity, veto if the hardest emission is harder
-  // than Qcut.
-  if ( exclusive && pow(pTfirst,2) > qCutSq ) {
-    doVeto = true;
-  // For highest multiplicity sample, veto if the hardest emission is harder
-  // than the hard process parton.
-  } else if ( !exclusive && nParton > 0 && pTfirst > pTminME ) {
-    doVeto = true;
-  }
-
-  // Return veto
-  return doVeto;
-
-}
-
-//--------------------------------------------------------------------------
-
-// Function to set the jet clustering scales (to be used as output)
-
-inline void JetMatchingMadgraph::SetDJR( const Event& event) {
-
- // Clear members.
- ClearDJR();
- vector<double> result;
-
-  // Initialize SlowJetDJR jet algorithm with event
-  if (!slowJetDJR->setup(event) ) {
-    infoPtr->errorMsg("Warning in JetMatchingMadgraph:iGetDJR"
-      ": the SlowJet algorithm failed on setup");
-    return;
-  }
-
-  // Cluster in steps to find all hadronic jets
-  while ( slowJetDJR->sizeAll() - slowJetDJR->sizeJet() > 0 ) {
-    // Save the next clustering scale.
-    result.push_back(sqrt(slowJetDJR->dNext()));
-    // Perform step.
-    slowJetDJR->doStep();
-  }
-
-  // Save clustering scales in reserve order.
-  for (int i=int(result.size())-1; i > 0; --i)
-    DJR.push_back(result[i]);
-
-}
-
-//--------------------------------------------------------------------------
-
-// Function to get the current number of partons in the Born state, as
-// read from LHE.
-
-inline int JetMatchingMadgraph::npNLO(){
-  string npIn = infoPtr->getEventAttribute("npNLO",true);
-  int np = (npIn != "") ? atoi((char*)npIn.c_str()) : -1;
-  if ( np < 0 ) { ; }
-  else return np;
-  return nPartonsNow;
-}
-
-//--------------------------------------------------------------------------
-
-// Step (1): sort the incoming particles
-
-inline void JetMatchingMadgraph::sortIncomingProcess(const Event &event) {
-
-  // Remove resonance decays from original process and keep only final
-  // state. Resonances will have positive status code after this step.
-  omitResonanceDecays(eventProcessOrig, true);
-  ClearDJR();
-  clear_nMEpartons();
-
-  // For FxFx, pre-cluster partons in the event into jets.
-  if (doFxFx) {
-
-    // Get final state partons
-    eventProcess.clear();
-    workEventJet.clear();
-    for( int i=0; i < workEvent.size(); ++i) {
-      // Original AG+Py6 algorithm explicitly excludes tops,
-      // leptons and photons.
-      int id = workEvent[i].idAbs();
-      if ((id >= ID_LEPMIN && id <= ID_LEPMAX) || id == ID_TOP
-        || id == ID_PHOTON || id == 23 || id == 24 || id == 25) {
-        eventProcess.append(workEvent[i]);
-      } else {
-        workEventJet.append(workEvent[i]);
-      }
-    }
-
-    // Initialize SlowJetHard jet algorithm with current working event
-    if (!slowJetHard->setup(workEventJet) ) {
-      infoPtr->errorMsg("Warning in JetMatchingMadgraph:sortIncomingProcess"
-        ": the SlowJet algorithm failed on setup");
-      return;
-    }
-
-    // Get matrix element cut scale.
-    double localQcutSq = qCutMESq;
-    // Cluster in steps to find all hadronic jets at the scale qCutME
-    while ( slowJetHard->sizeAll() - slowJetHard->sizeJet() > 0 ) {
-      // Done if next step is above qCut
-      if( slowJetHard->dNext() > localQcutSq ) break;
-      // Done if we're at or below the number of partons in the Born state.
-      if( slowJetHard->sizeAll()-slowJetHard->sizeJet() <= npNLO()) break;
-      slowJetHard->doStep();
-    }
-
-    // Construct a master copy of the event containing only the
-    // hardest nPartonsNow hadronic clusters. While constructing the event,
-    // the parton type (ID_GLUON) and status (98,99) are arbitrary.
-    int nJets = slowJetHard->sizeJet();
-    int nClus = slowJetHard->sizeAll();
-    int nNow = 0;
-    for (int i = nJets; i < nClus; ++i) {
-      vector<int> parts;
-      if (i < nClus-nJets) parts = slowJetHard->clusConstituents(i);
-      else parts = slowJetHard->constituents(nClus-nJets-i);
-      int flavour = ID_GLUON;
-      for(int j=0; j < int(parts.size()); ++j)
-        if (workEventJet[parts[j]].id() == ID_BOT)
-          flavour = ID_BOT;
-      eventProcess.append( flavour, 98,
-        workEventJet[parts.back()].mother1(),
-        workEventJet[parts.back()].mother2(),
-        workEventJet[parts.back()].daughter1(),
-        workEventJet[parts.back()].daughter2(),
-        0, 0, slowJetHard->p(i).px(), slowJetHard->p(i).py(),
-        slowJetHard->p(i).pz(), slowJetHard->p(i).e() );
-      nNow++;
-    }
-
-    // Done. Clean-up
-    workEventJet.clear();
-
-  // For MLM matching, simply take hard process state from workEvent,
-  // without any preclustering.
-  } else {
-    eventProcess = workEvent;
-  }
-
-  // Sort original process final state into light/heavy jets and 'other'.
-  // Criteria:
-  //   1 <= ID <= nQmatch, or ID == 21         --> light jet (typeIdx[0])
-  //   nQMatch < ID                            --> heavy jet (typeIdx[1])
-  //   All else                                --> other     (typeIdx[2])
-  // Note that 'typeIdx' stores indices into 'eventProcess' (after resonance
-  // decays are omitted), while 'typeSet' stores indices into the original
-  // process record, 'eventProcessOrig', but these indices are also valid
-  // in 'event'.
-  for (int i = 0; i < 3; i++) {
-    typeIdx[i].clear();
-    typeSet[i].clear();
-    origTypeIdx[i].clear();
-  }
-  for (int i = 0; i < eventProcess.size(); i++) {
-    // Ignore non-final state and default to 'other'
-    if (!eventProcess[i].isFinal()) continue;
-    int idx = 2;
-    int orig_idx = 2;
-
-    // Light jets: all gluons and quarks with id less than or equal to nQmatch
-    if (eventProcess[i].id() == ID_GLUON
-      || (eventProcess[i].idAbs() <= nQmatch) ) {
-      orig_idx = 0;
-      // Crucial point: MG puts the scale of a non-QCD particle to eCM. For
-      // such particles, we should keep the default "2"
-      if ( eventProcess[i].scale() < 1.999*sqrt(infoPtr->eA()*infoPtr->eB()) )
-        idx = 0;
-    }
-
-    // Heavy jets:  all quarks with id greater than nQmatch
-    else if (eventProcess[i].idAbs() > nQmatch
-      && eventProcess[i].idAbs() <= ID_TOP) {
-      idx = 1;
-      orig_idx = 1;
-
-    } else {
-      idx = 2;
-      orig_idx = 2;
-    }
-
-    // Store
-    typeIdx[idx].push_back(i);
-    typeSet[idx].insert(eventProcess[i].daughter1());
-    origTypeIdx[orig_idx].push_back(i);
-  }
-
-  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
-  if (exclusiveMode == 2) {
-
-    // Inclusive if nJet == nJetMax, exclusive otherwise
-    int nParton = origTypeIdx[0].size();
-    exclusive = (nParton == nJetMax) ? false : true;
-
-  // Otherwise, just set as given
-  } else {
-    exclusive = (exclusiveMode == 0) ? false : true;
-  }
-
-  // Extract partons from hardest subsystem + ISR + FSR only into
-  // workEvent. Note no resonance showers or MPIs.
-  subEvent(event);
-}
-
-//--------------------------------------------------------------------------
-
-// Step (2a): pick which particles to pass to the jet algorithm
-
-inline void JetMatchingMadgraph::jetAlgorithmInput(const Event &event,
-  int iType) {
-
-  // Take input from 'workEvent' and put output in 'workEventJet'
-  workEventJet = workEvent;
-
-  // Loop over particles and decide what to pass to the jet algorithm
-  for (int i = 0; i < workEventJet.size(); ++i) {
-    if (!workEventJet[i].isFinal()) continue;
-
-    // jetAllow option to disallow certain particle types
-    if (jetAllow == 1) {
-
-      // Original AG+Py6 algorithm explicitly excludes tops,
-      // leptons and photons.
-      int id = workEventJet[i].idAbs();
-      if ((id >= ID_LEPMIN && id <= ID_LEPMAX) || id == ID_TOP
-      || id == ID_PHOTON || (id > nQmatch && id!=21)) {
-        workEventJet[i].statusNeg();
-        continue;
-      }
-    }
-
-    // Get the index of this particle in original event
-    int idx = workEventJet[i].daughter1();
-
-    // Start with particle idx, and afterwards track mothers
-    while (true) {
-
-      // Light jets
-      if (iType == 0) {
-
-        // Do not include if originates from heavy jet or 'other'
-        if (typeSet[1].find(idx) != typeSet[1].end() ||
-            typeSet[2].find(idx) != typeSet[2].end()) {
-          workEventJet[i].statusNeg();
-          break;
-        }
-
-        // Made it to start of event record so done
-        if (idx == 0) break;
-        // Otherwise next mother and continue
-        idx = event[idx].mother1();
-
-      // Heavy jets
-      } else if (iType == 1) {
-
-        // Only include if originates from heavy jet
-        if (typeSet[1].find(idx) != typeSet[1].end()) break;
-
-        // Made it to start of event record with no heavy jet mother,
-        // so DO NOT include particle
-        if (idx == 0) {
-          workEventJet[i].statusNeg();
-          break;
-        }
-
-        // Otherwise next mother and continue
-        idx = event[idx].mother1();
-
-      } // if (iType)
-    } // while (true)
-  } // for (i)
-}
-
-//--------------------------------------------------------------------------
-
-// Step (2b): run jet algorithm and provide common output
-// This does nothing, because the jet algorithm is run several times
-//  in the matching algorithm.
-
-inline void JetMatchingMadgraph::runJetAlgorithm() {; }
-
-//--------------------------------------------------------------------------
-
-// Step (2c): veto decision (returning true vetoes the event)
-
-inline bool JetMatchingMadgraph::matchPartonsToJets(int iType) {
-
-  // Use two different routines for light/heavy jets as
-  // different veto conditions and for clarity
-  if (iType == 0) {
-    // Record the jet separations here, also if matchPartonsToJetsLight
-    // returns preemptively.
-    SetDJR(workEventJet);
-    set_nMEpartons(origTypeIdx[0].size(), typeIdx[0].size());
-    // Perform jet matching.
-    return (matchPartonsToJetsLight() > 0);
-  } else return (matchPartonsToJetsHeavy() > 0);
-}
-
-//--------------------------------------------------------------------------
-
-// Step(2c): light jets
-// Return codes are given indicating the reason for a veto.
-// Although not currently used, they are a useful debugging tool:
-//   0 = no veto
-//   1 = veto as number of jets less than number of partons
-//   2 = veto as exclusive mode and number of jets greater than
-//       number of partons
-//   3 = veto as inclusive mode and there would be an extra jet
-//       that is harder than any matched soft jet
-//   4 = veto as there is a parton which does not match a jet
-
-inline int JetMatchingMadgraph::matchPartonsToJetsLight() {
-
-  // Count the number of hard partons
-  int nParton = typeIdx[0].size();
-
-  // Initialize SlowJet with current working event
-  if (!slowJet->setup(workEventJet) ) {
-    infoPtr->errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
-      "Light: the SlowJet algorithm failed on setup");
-    return NONE;
-  }
-  double localQcutSq = qCutSq;
-  double dOld = 0.0;
-  // Cluster in steps to find all hadronic jets at the scale qCut
-  while ( slowJet->sizeAll() - slowJet->sizeJet() > 0 ) {
-    if( slowJet->dNext() > localQcutSq ) break;
-    dOld = slowJet->dNext();
-    slowJet->doStep();
-  }
-  int nJets = slowJet->sizeJet();
-  int nClus = slowJet->sizeAll();
-
-  // Debug printout.
-  if (MATCHINGDEBUG) slowJet->list(true);
-
-  // Count of the number of hadronic jets in SlowJet accounting
-  int nCLjets = nClus - nJets;
-  // Get number of partons. Different for MLM and FxFx schemes.
-  int nRequested = (doFxFx) ? npNLO() : nParton;
-
-  // Veto event if too few hadronic jets
-  if ( nCLjets < nRequested ) return LESS_JETS;
-
-  // In exclusive mode, do not allow more hadronic jets than partons
-  if ( exclusive && !doFxFx ) {
-    if ( nCLjets > nRequested ) return MORE_JETS;
-  } else {
-
-    // For FxFx, in the non-highest multipicity, all jets need to matched to
-    // partons. For nCLjets > nRequested, this is not possible. Hence, we can
-    // veto here already.
-    if ( doFxFx && nRequested < nJetMax && nCLjets > nRequested )
-      return MORE_JETS;
-
-    // Now continue in inclusive mode.
-    // In inclusive mode, there can be more hadronic jets than partons,
-    // provided that all partons are properly matched to hadronic jets.
-    // Start by setting up the jet algorithm.
-    if (!slowJet->setup(workEventJet) ) {
-      infoPtr->errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
-        "Light: the SlowJet algorithm failed on setup");
-      return NONE;
-    }
-
-    // For FxFx, continue clustering as long as the jet separation is above
-    // qCut.
-    if (doFxFx) {
-      while ( slowJet->sizeAll() - slowJet->sizeJet() > 0 ) {
-        if( slowJet->dNext() > localQcutSq ) break;
-        slowJet->doStep();
-      }
-    // For MLM, cluster into hadronic jets until there are the same number as
-    // partons.
-    } else {
-      while ( slowJet->sizeAll() - slowJet->sizeJet() > nParton )
-        slowJet->doStep();
-    }
-
-    // Sort partons in pT.  Update local qCut value.
-    //  Hadronic jets are already sorted in pT.
-    localQcutSq = dOld;
-    if ( clFact >= 0. && nParton > 0 ) {
-       vector<double> partonPt;
-       for (int i = 0; i < nParton; ++i)
-         partonPt.push_back( eventProcess[typeIdx[0][i]].pT2() );
-       sort( partonPt.begin(), partonPt.end());
-       localQcutSq = max( qCutSq, partonPt[0]);
-    }
-    nJets = slowJet->sizeJet();
-    nClus = slowJet->sizeAll();
-  }
-  // Update scale if clustering factor is non-zero
-  if ( clFact != 0. ) localQcutSq *= pow2(clFact);
-
-  Event tempEvent;
-  tempEvent.init( "(tempEvent)", particleDataPtr);
-  int nPass = 0;
-  double pTminEstimate = -1.;
-  // Construct a master copy of the event containing only the
-  // hardest nParton hadronic clusters. While constructing the event,
-  // the parton type (ID_GLUON) and status (98,99) are arbitrary.
-  for (int i = nJets; i < nClus; ++i) {
-    tempEvent.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0, slowJet->p(i).px(),
-      slowJet->p(i).py(), slowJet->p(i).pz(), slowJet->p(i).e() );
-    ++nPass;
-    pTminEstimate = max( pTminEstimate, slowJet->pT(i));
-    if(nPass == nRequested) break;
-  }
-
-  int tempSize = tempEvent.size();
-  // This keeps track of which hadronic jets are matched to parton
-  vector<bool> jetAssigned;
-  jetAssigned.assign( tempSize, false);
-
-  // This keeps track of which partons are matched to which hadronic
-  // jets.
-  vector< vector<bool> > partonMatchesJet;
-  for (int i=0; i < nParton; ++i )
-    partonMatchesJet.push_back( vector<bool>(tempEvent.size(),false) );
-
-  // Begin matching.
-  // Do jet matching for FxFx.
-  // Make sure that the nPartonsNow hardest hadronic jets are matched to any
-  // of the nPartonsNow (+1) partons. This matching is done by attaching a jet
-  // from the list of unmatched hadronic jets, and appending a jet from the
-  // list of partonic jets, one at a time. The partonic jet will be clustered
-  // with the hadronic jet or the beam if the distance measure is below the
-  // cut. The hadronic jet is matched once this happens. Otherwise, another
-  // partonic jet is tried. When a hadronic jet is matched to a partonic jet,
-  // it is removed from the list of unmatched hadronic jets. This process
-  // continues until the nPartonsNow hardest hadronic jets are matched to
-  // partonic jets, or it is not possible to make a match for a hadronic jet.
-  int iNow = 0;
-  int nMatched = 0;
-  while ( doFxFx && iNow < tempSize ) {
-
-    // Check if this shower jet matches any partonic jet.
-    Event tempEventJet;
-    tempEventJet.init("(tempEventJet)", particleDataPtr);
-    for (int i=0; i < nParton; ++i ) {
-
-      //// Only assign a parton once.
-      //for (int j=0; j < tempSize; ++j )
-      //  if ( partonMatchesJet[i][j]) continue;
-
-      // Attach a single hadronic jet.
-      tempEventJet.clear();
-      tempEventJet.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0,
-        tempEvent[iNow].px(), tempEvent[iNow].py(),
-        tempEvent[iNow].pz(), tempEvent[iNow].e() );
-      // Attach the current parton.
-      Vec4 pIn = eventProcess[typeIdx[0][i]].p();
-      tempEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0,
-        pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
-
-      // Setup jet algorithm.
-      if ( !slowJet->setup(tempEventJet) ) {
-        infoPtr->errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
-          "Light: the SlowJet algorithm failed on setup");
-        return NONE;
-      }
-
-      // These are the conditions for the hadronic jet to match the parton
-      //  at the local qCut scale
-      if ( slowJet->iNext() == tempEventJet.size() - 1
-        && slowJet->jNext() > -1 && slowJet->dNext() < localQcutSq ) {
-        jetAssigned[iNow] = true;
-        partonMatchesJet[i][iNow] = true;
-      }
-
-    } // End loop over hard partons.
-
-    // Veto if the jet could not be assigned to any parton.
-    if ( jetAssigned[iNow] ) nMatched++;
-
-    // Continue;
-    ++iNow;
-  }
-
-  // Jet matching veto for FxFx
-  if (doFxFx) {
-    if ( nRequested <  nJetMax && nMatched != nRequested )
-      return UNMATCHED_PARTON;
-    if ( nRequested == nJetMax && nMatched <  nRequested )
-      return UNMATCHED_PARTON;
-  }
-
-  // Do jet matching for MLM.
-  // Take the list of unmatched hadronic jets and append a parton, one at
-  // a time. The parton will be clustered with the "closest" hadronic jet
-  // or the beam if the distance measure is below the cut. When a hadronic
-  // jet is matched to a parton, it is removed from the list of unmatched
-  // hadronic jets. This process continues until all hadronic jets are
-  // matched to partons or it is not possible to make a match.
-  iNow = 0;
-  while (!doFxFx && iNow < nParton ) {
-    Event tempEventJet;
-    tempEventJet.init("(tempEventJet)", particleDataPtr);
-    for (int i = 0; i < tempSize; ++i) {
-      if (jetAssigned[i]) continue;
-      Vec4 pIn = tempEvent[i].p();
-      // Append unmatched hadronic jets
-      tempEventJet.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0,
-        pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
-    }
-
-    Vec4 pIn = eventProcess[typeIdx[0][iNow]].p();
-    // Append the current parton
-    tempEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0,
-      pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
-    if ( !slowJet->setup(tempEventJet) ) {
-      infoPtr->errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
-        "Light: the SlowJet algorithm failed on setup");
-      return NONE;
-    }
-    // These are the conditions for the hadronic jet to match the parton
-    //  at the local qCut scale
-    if ( slowJet->iNext() == tempEventJet.size() - 1
-      && slowJet->jNext() > -1 && slowJet->dNext() < localQcutSq ) {
-      int iKnt = -1;
-      for (int i = 0; i != tempSize; ++i) {
-        if (jetAssigned[i]) continue;
-        ++iKnt;
-        // Identify the hadronic jet that matches the parton
-        if (iKnt == slowJet->jNext() ) jetAssigned[i] = true;
-      }
-    } else {
-      return UNMATCHED_PARTON;
-    }
-    ++iNow;
-  }
-
-  // Minimal eT/pT (CellJet/SlowJet) of matched light jets.
-  // Needed later for heavy jet vetos in inclusive mode.
-  // This information is not used currently.
-  if (nParton > 0 && pTminEstimate > 0) eTpTlightMin = pTminEstimate;
-  else eTpTlightMin = -1.;
-
-  // Record the jet separations.
-  SetDJR(workEventJet);
-
-  // No veto
-  return NONE;
-}
-
-//--------------------------------------------------------------------------
-
-// Step(2c): heavy jets
-// Return codes are given indicating the reason for a veto.
-// Although not currently used, they are a useful debugging tool:
-//   0 = no veto as there are no extra jets present
-//   1 = veto as in exclusive mode and extra jets present
-//   2 = veto as in inclusive mode and extra jets were harder
-//       than any matched light jet
-
-inline int JetMatchingMadgraph::matchPartonsToJetsHeavy() {
-
-  // Currently, heavy jets are unmatched
-  // If there are no extra jets, then accept
-  if (jetMomenta.empty()) return NONE;
-
-  // No extra jets were present so no veto
-  return NONE;
-}
-
-//==========================================================================
-
 } // end namespace Pythia8
 
 #endif // end Pythia8_JetMatching_H
diff -rupN pythia_8.212_original/src/GeneratorInput.cc pythia_8.212_patched_nohepmc/src/GeneratorInput.cc
--- pythia_8.212_original/src/GeneratorInput.cc	1970-01-01 01:00:00.000000000 +0100
+++ pythia_8.212_patched_nohepmc/src/GeneratorInput.cc	2020-09-09 20:18:23.689199120 +0200
@@ -0,0 +1,1053 @@
+#include "Pythia8Plugins/GeneratorInput.h"
+
+// GAMBIT: We moved the below definitions from GeneratorInput.h
+//         to this source file to allow easy BOSSing
+
+
+namespace Pythia8 {
+
+//==========================================================================
+
+// Main implementation of AlpgenPar class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+
+//--------------------------------------------------------------------------
+
+// Constants: could be changed here if desired, but normally should not.
+// These are of technical nature, as described for each.
+
+// A zero threshold value for double comparisons.
+const double AlpgenPar::ZEROTHRESHOLD = 1e-10;
+
+//--------------------------------------------------------------------------
+
+// Warn if e/pT imbalance greater than these values
+// Parse an incoming Alpgen parameter file string
+
+  bool AlpgenPar::parse(const string paramStr) {
+
+  // Read par file in blocks:
+  //   0 - process information
+  //   1 - run parameters
+  //   2 - cross sections
+  int block = 0;
+
+  // Loop over incoming lines
+  stringstream paramStream(paramStr);
+  string line;
+  while (getline(paramStream, line)) {
+
+    // Change to 'run parameters' block
+    if        (line.find("run parameters") != string::npos) {
+      block = 1;
+
+    // End of 'run parameters' block
+    } else if (line.find("end parameters") != string::npos) {
+      block = 2;
+
+    // Do not extract anything from block 0 so far
+    } else if (block == 0) {
+
+    // Block 1 or 2: extract parameters
+    } else {
+      extractRunParam(line);
+
+    }
+  } // while (getline(paramStream, line))
+
+  return true;
+}
+
+//--------------------------------------------------------------------------
+
+// Parse an incoming parameter line
+
+  void AlpgenPar::extractRunParam(string line) {
+
+  // Extract information to the right of the final '!' character
+  size_t idx = line.rfind("!");
+  if (idx == string::npos) return;
+  string paramName = trim(line.substr(idx + 1));
+  string paramVal  = trim(line.substr(0, idx));
+  istringstream iss(paramVal);
+
+  // Special case: 'hard process code' - single integer input
+  double val;
+  if (paramName == "hard process code") {
+    iss >> val;
+    warnParamOverwrite("hpc", val);
+    params["hpc"] = val;
+
+  // Special case: 'Crosssection +- error (pb)' - two double values
+  } else if (paramName.find("Crosssection") == 0) {
+    double xerrup;
+    iss >> val >> xerrup;
+    warnParamOverwrite("xsecup", val);
+    warnParamOverwrite("xerrup", val);
+    params["xsecup"] = val;
+    params["xerrup"] = xerrup;
+
+  // Special case: 'unwtd events, lum (pb-1)' - integer and double values
+  } else if (paramName.find("unwtd events") == 0) {
+    int nevent;
+    iss >> nevent >> val;
+    warnParamOverwrite("nevent", val);
+    warnParamOverwrite("lum", val);
+    params["nevent"] = nevent;
+    params["lum"]    = val;
+
+  // Special case: 'mc,mb,...' - split on ',' for name and ' ' for values
+  } else if (paramName.find(",") != string::npos) {
+
+    // Simple tokeniser
+    string        paramNameNow;
+    istringstream issName(paramName);
+    while (getline(issName, paramNameNow, ',')) {
+      iss >> val;
+      warnParamOverwrite(paramNameNow, val);
+      params[paramNameNow] = val;
+    }
+
+  // Default case: assume integer and double on the left
+  } else {
+    int paramIdx;
+    iss >> paramIdx >> val;
+    warnParamOverwrite(paramName, val);
+    params[paramName] = val;
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Print parameters read from the '.par' file
+
+  void AlpgenPar::printParams() {
+
+  // Loop over all stored parameters and print
+  cout << fixed << setprecision(3) << endl
+       << " *-------  Alpgen parameters  -------*" << endl;
+  for (map < string, double >::iterator it = params.begin();
+       it != params.end(); ++it)
+    cout << " |  " << left << setw(13) << it->first
+         << "  |  " << right << setw(13) << it->second
+         << "  |" << endl;
+  cout << " *-----------------------------------*" << endl;
+}
+
+//--------------------------------------------------------------------------
+
+// Warn if a parameter is going to be overwriten
+
+  void AlpgenPar::warnParamOverwrite(const string &paramIn, double val) {
+
+  // Check if present and if new value is different
+  if (haveParam(paramIn) &&
+      abs(getParam(paramIn) - val) > ZEROTHRESHOLD) {
+    if (infoPtr) infoPtr->errorMsg("Warning in LHAupAlpgen::"
+        "warnParamOverwrite: overwriting existing parameter", paramIn);
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Simple string trimmer
+
+  string AlpgenPar::trim(string s) {
+
+  // Remove whitespace in incoming string
+  size_t i;
+  if ((i = s.find_last_not_of(" \t\r\n")) != string::npos)
+    s = s.substr(0, i + 1);
+  if ((i = s.find_first_not_of(" \t\r\n")) != string::npos)
+    s = s.substr(i);
+  return s;
+}
+
+
+//==========================================================================
+
+// Main implementation of LHAupAlpgen class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+// ----------------------------------------------------------------------
+
+// Constants: could be changed here if desired, but normally should not.
+// These are of technical nature, as described for each.
+
+// Debug flag to print all particles in each event.
+const bool LHAupAlpgen::LHADEBUG        = false;
+
+// Debug flag to print particles when an e/p imbalance is found.
+const bool LHAupAlpgen::LHADEBUGRESCALE = false;
+
+// A zero threshold value for double comparisons.
+const double LHAupAlpgen::ZEROTHRESHOLD   = 1e-10;
+
+// Warn if e/pT imbalance greater than these values
+const double LHAupAlpgen::EWARNTHRESHOLD  = 3e-3;
+const double LHAupAlpgen::PTWARNTHRESHOLD = 1e-3;
+
+// If incoming e/pZ is 0, it is reset to this value
+const double LHAupAlpgen::INCOMINGMIN     = 1e-3;
+
+// ----------------------------------------------------------------------
+
+// Constructor. Opens parameter file and parses then opens event file.
+
+LHAupAlpgen::LHAupAlpgen(const char* baseFNin, Info* infoPtrIn)
+  : baseFN(baseFNin), alpgenPar(infoPtrIn), isUnw(NULL) {
+
+  // Set the info pointer if given
+  if (infoPtrIn) setPtr(infoPtrIn);
+
+  // Read in '_unw.par' file to get parameters
+  ifstream  ifsPar;
+  istream*  isPar = NULL;
+
+  // Try gzip file first then normal file afterwards
+#ifdef GZIPSUPPORT
+  parFN = baseFN + "_unw.par.gz";
+  isPar = openFile(parFN.c_str(), ifsPar);
+  if (!ifsPar.is_open()) closeFile(isPar, ifsPar);
+#endif
+  if (isPar == NULL) {
+    parFN = baseFN + "_unw.par";
+    isPar = openFile(parFN.c_str(), ifsPar);
+    if (!ifsPar.is_open()) {
+      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::LHAupAlpgen: "
+          "cannot open parameter file", parFN);
+      closeFile(isPar, ifsPar);
+      return;
+    }
+  }
+
+  // Read entire contents into string and close file
+  string paramStr((std::istreambuf_iterator<char>(isPar->rdbuf())),
+                   std::istreambuf_iterator<char>());
+
+  // Make sure we reached EOF and not other error
+  if (ifsPar.bad()) {
+    if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::LHAupAlpgen: "
+        "cannot read parameter file", parFN);
+    return;
+  }
+  closeFile(isPar, ifsPar);
+
+  // Parse file and set LHEF header
+  alpgenPar.parse(paramStr);
+  if (infoPtr) setInfoHeader("AlpgenPar", paramStr);
+
+  // Open '.unw' events file (with possible gzip support)
+#ifdef GZIPSUPPORT
+  unwFN = baseFN + ".unw.gz";
+  isUnw = openFile(unwFN.c_str(), ifsUnw);
+  if (!ifsUnw.is_open()) closeFile(isUnw, ifsUnw);
+#endif
+  if (isUnw == NULL) {
+    unwFN = baseFN + ".unw";
+    isUnw = openFile(unwFN.c_str(), ifsUnw);
+    if (!ifsUnw.is_open()) {
+      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::LHAupAlpgen: "
+          "cannot open event file", unwFN);
+      closeFile(isUnw, ifsUnw);
+    }
+  }
+}
+
+// ----------------------------------------------------------------------
+
+// setInit is a virtual method that must be finalised here.
+// Sets up beams, strategy and processes.
+
+  bool LHAupAlpgen::setInit() {
+
+  // Check that all required parameters are present
+  if (!alpgenPar.haveParam("ih2") || !alpgenPar.haveParam("ebeam")  ||
+      !alpgenPar.haveParam("hpc") || !alpgenPar.haveParam("xsecup") ||
+      !alpgenPar.haveParam("xerrup")) {
+    if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setInit: "
+        "missing input parameters");
+    return false;
+  }
+
+  // Beam IDs
+  int ih2 = alpgenPar.getParamAsInt("ih2");
+  int idbmupA = 2212;
+  int idbmupB = (ih2 == 1) ? 2212 : -2212;
+
+  // Beam energies
+  double ebeam = alpgenPar.getParam("ebeam");
+  ebmupA = ebeam;
+  ebmupB = ebmupA;
+
+  // PDF group and set (at the moment not set)
+  int pdfgupA = 0, pdfsupA = 0;
+  int pdfgupB = 0, pdfsupB = 0;
+
+  // Strategy is for unweighted events and xmaxup not important
+  int    idwtup = 3;
+  double xmaxup = 0.;
+
+  // Get hard process code
+  lprup = alpgenPar.getParamAsInt("hpc");
+
+  // Check for unsupported processes
+  if (lprup == 7 || lprup == 8 || lprup == 13) {
+    if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setInit: "
+        "process not implemented");
+    return false;
+  }
+
+  // Depending on the process code, get heavy flavour information:
+  //    6 = QQbar           + jets
+  //    7 = QQbar + Q'Qbar' + jets
+  //    8 = QQbar + Higgs   + jets
+  //   16 = QQbar + gamma   + jets
+  if (lprup == 6 || lprup == 7 || lprup == 8 || lprup == 16) {
+    if (!alpgenPar.haveParam("ihvy")) {
+      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setInit: "
+          "heavy flavour information not present");
+      return false;
+    }
+    ihvy1 = alpgenPar.getParamAsInt("ihvy");
+
+  } else ihvy1 = -1;
+  if (lprup == 7) {
+    if (!alpgenPar.haveParam("ihvy2")) {
+      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setInit: "
+          "heavy flavour information not present");
+      return false;
+    }
+    ihvy2 = alpgenPar.getParamAsInt("ihvy2");
+  } else ihvy2 = -1;
+  // For single top (process 13), get b mass to set incoming
+  mb = -1.;
+  if (lprup == 13) {
+    if (!alpgenPar.haveParam("mb")) {
+      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setInit: "
+          "heavy flavour information not present");
+      return false;
+    }
+    mb = alpgenPar.getParam("mb");
+  }
+
+  // Set the beams
+  setBeamA(idbmupA, ebmupA, pdfgupA, pdfsupA);
+  setBeamB(idbmupB, ebmupB, pdfgupB, pdfsupB);
+  setStrategy(idwtup);
+
+  // Add the process
+  double xsecup = alpgenPar.getParam("xsecup");
+  double xerrup = alpgenPar.getParam("xerrup");
+  addProcess(lprup, xsecup, xerrup, xmaxup);
+  xSecSumSave = xsecup;
+  xErrSumSave = xerrup;
+
+  // All okay
+  return true;
+}
+
+// ----------------------------------------------------------------------
+
+// setEvent is a virtual method that must be finalised here.
+// Read in an event from the 'unw' file and setup.
+
+  bool LHAupAlpgen::setEvent(int) {
+
+  // Read in the first line of the event
+  int    nEvent, iProc, nParton;
+  double Swgt, Sq;
+  string line;
+  if (!getline(*isUnw, line)) {
+    // Read was bad
+    if (ifsUnw.bad()) {
+      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setEvent: "
+          "could not read events from file");
+      return false;
+    }
+    // End of file reached
+    if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setEvent: "
+        "end of file reached");
+    return false;
+  }
+  istringstream iss1(line);
+  iss1 >> nEvent >> iProc >> nParton >> Swgt >> Sq;
+
+  // Set the process details (ignore alphaQED and alphaQCD parameters)
+  double wgtT = Swgt, scaleT = Sq;
+  setProcess(lprup, wgtT, scaleT);
+
+  // Incoming flavour and x information for later
+  int    id1T, id2T;
+  double x1T, x2T;
+  // Temporary storage for read in parton information
+  int    idT, statusT, mother1T, mother2T, col1T, col2T;
+  double pxT, pyT, pzT, eT, mT;
+  // Leave tau and spin as default values
+  double tauT = 0., spinT = 9.;
+
+  // Store particles locally at first so that resonances can be added
+  myParticles.clear();
+
+  // Now read in partons
+  for (int i = 0; i < nParton; i++) {
+    // Get the next line
+    if (!getline(*isUnw, line)) {
+      if (infoPtr) infoPtr->errorMsg("Error in LHAupAlpgen::setEvent: "
+          "could not read events from file");
+      return false;
+    }
+    istringstream iss2(line);
+
+    // Incoming (flavour, colour, anticolour, pz)
+    if (i < 2) {
+      // Note that mothers will be set automatically by Pythia, and LHA
+      // status -1 is for an incoming parton
+      iss2 >> idT >> col1T >> col2T >> pzT;
+      statusT  = -1;
+      mother1T = mother2T = 0;
+      pxT = pyT = mT = 0.;
+      eT  = abs(pzT);
+
+      // Adjust when zero pz/e
+      if (pzT == 0.) {
+        pzT = (i == 0) ? INCOMINGMIN : -INCOMINGMIN;
+        eT  = INCOMINGMIN;
+      }
+
+    // Outgoing (flavour, colour, anticolour, px, py, pz, mass)
+    } else {
+      // Note that mothers 1 and 2 corresport to the incoming partons,
+      // as set above, and LHA status +1 is for outgoing final state
+      iss2 >> idT >> col1T >> col2T >> pxT >> pyT >> pzT >> mT;
+      statusT  = 1;
+      mother1T = 1;
+      mother2T = 2;
+      eT = sqrt(max(0., pxT*pxT + pyT*pyT + pzT*pzT + mT*mT));
+    }
+
+    // Add particle
+    myParticles.push_back(LHAParticle(
+        idT, statusT, mother1T, mother2T, col1T, col2T,
+        pxT, pyT, pzT, eT, mT, tauT, spinT,-1.));
+  }
+
+  // Add resonances if required
+  if (!addResonances()) return false;
+
+  // Rescale momenta if required (must be done after full event
+  // reconstruction in addResonances)
+  if (!rescaleMomenta()) return false;
+
+  // Pass particles on to Pythia
+  for (size_t i = 0; i < myParticles.size(); i++)
+    addParticle(myParticles[i]);
+
+  // Set incoming flavour/x information and done
+  id1T = myParticles[0].idPart;
+  x1T  = myParticles[0].ePart / ebmupA;
+  id2T = myParticles[1].idPart;
+  x2T  = myParticles[1].ePart / ebmupA;
+  setIdX(id1T, id2T, x1T, x2T);
+  setPdf(id1T, id2T, x1T, x2T, 0., 0., 0., false);
+  return true;
+}
+
+// ----------------------------------------------------------------------
+
+// Print list of particles; mainly intended for debugging
+
+  void LHAupAlpgen::printParticles() {
+
+  cout << endl << "---- LHAupAlpgen particle listing begin ----" << endl;
+  cout << scientific << setprecision(6);
+  for (int i = 0; i < int(myParticles.size()); i++) {
+    cout << setw(5)  << i
+         << setw(5)  << myParticles[i].idPart
+         << setw(5)  << myParticles[i].statusPart
+         << setw(15) << myParticles[i].pxPart
+         << setw(15) << myParticles[i].pyPart
+         << setw(15) << myParticles[i].pzPart
+         << setw(15) << myParticles[i].ePart
+         << setw(15) << myParticles[i].mPart
+         << setw(5)  << myParticles[i].mother1Part - 1
+         << setw(5)  << myParticles[i].mother2Part - 1
+         << setw(5)  << myParticles[i].col1Part
+         << setw(5)  << myParticles[i].col2Part
+         << endl;
+  }
+  cout << "----  LHAupAlpgen particle listing end  ----" << endl;
+}
+
+// ----------------------------------------------------------------------
+
+// Routine to add resonances to an incoming event based on the
+// hard process code (now stored in lprup).
+
+  bool LHAupAlpgen::addResonances() {
+
+  // Temporary storage for resonance information
+  int    idT, statusT, mother1T, mother2T, col1T, col2T;
+  double pxT, pyT, pzT, eT, mT;
+  // Leave tau and spin as default values
+  double tauT = 0., spinT = 9.;
+
+  // Alpgen process dependent parts. Processes:
+  //    1 = W        + QQbar         + jets
+  //    2 = Z/gamma* + QQbar         + jets
+  //    3 = W                        + jets
+  //    4 = Z/gamma*                 + jets
+  //   10 = W        + c             + jets
+  //   14 = W        + gamma         + jets
+  //   15 = W        + QQbar + gamma + jets
+  // When QQbar = ttbar, tops are not decayed in these processes.
+  // Explicitly reconstruct W/Z resonances; assumption is that the
+  // decay products are the last two particles.
+  if (lprup <= 4 || lprup == 10 || lprup == 14 || lprup == 15) {
+    // Decay products are the last two entries
+    int i1 = myParticles.size() - 1, i2 = i1 - 1;
+
+    // Follow 'alplib/alpsho.f' procedure to get ID
+    if (myParticles[i1].idPart + myParticles[i2].idPart == 0)
+      idT = 0;
+    else
+      idT = - (myParticles[i1].idPart % 2) - (myParticles[i2].idPart % 2);
+    idT = (idT > 0) ? 24 : (idT < 0) ? -24 : 23;
+
+    // Check that we get the expected resonance type; Z/gamma*
+    if (lprup == 2 || lprup == 4) {
+      if (idT != 23) {
+        if (infoPtr) infoPtr->errorMsg("Error in "
+            "LHAupAlpgen::addResonances: wrong resonance type in event");
+        return false;
+      }
+
+    // W's
+    } else {
+      if (abs(idT) != 24) {
+        if (infoPtr) infoPtr->errorMsg("Error in "
+            "LHAupAlpgen::addResonances: wrong resonance type in event");
+        return false;
+      }
+    }
+
+    // Remaining input
+    statusT  = 2;
+    mother1T = 1;
+    mother2T = 2;
+    col1T = col2T = 0;
+    pxT = myParticles[i1].pxPart + myParticles[i2].pxPart;
+    pyT = myParticles[i1].pyPart + myParticles[i2].pyPart;
+    pzT = myParticles[i1].pzPart + myParticles[i2].pzPart;
+    eT  = myParticles[i1].ePart  + myParticles[i2].ePart;
+    mT  = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
+    myParticles.push_back(LHAParticle(
+        idT, statusT, mother1T, mother2T, col1T, col2T,
+        pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
+
+    // Update decay product mothers (note array size as if from 1)
+    myParticles[i1].mother1Part = myParticles[i2].mother1Part =
+        myParticles.size();
+    myParticles[i1].mother2Part = myParticles[i2].mother2Part = 0;
+
+  // Processes:
+  //    5 = nW + mZ + j gamma + lH + jets
+  //    6 = QQbar         + jets    (QQbar = ttbar)
+  //    8 = QQbar + Higgs + jets    (QQbar = ttbar)
+  //   13 = top   + q               (topprc = 1)
+  //   13 = top   + b               (topprc = 2)
+  //   13 = top   + W     + jets    (topprc = 3)
+  //   13 = top   + W     + b       (topprc = 4)
+  //   16 = QQbar + gamma + jets    (QQbar = ttbar)
+  //
+  // When tops are present, they are decayed to Wb (both the W and b
+  // are not given), with this W also decaying (decay products given).
+  // The top is marked intermediate, the (intermediate) W is
+  // reconstructed from its decay products, and the decay product mothers
+  // updated. The final-state b is reconstructed from (top - W).
+  //
+  // W/Z resonances are given, as well as their decay products. The
+  // W/Z is marked intermediate, and the decay product mothers updated.
+  //
+  // It is always assumed that decay products are at the end.
+  // For processes 5 and 13, it is also assumed that the decay products
+  // are in the same order as the resonances.
+  // For processes 6, 8 and 16, the possibility of the decay products
+  // being out-of-order is also taken into account.
+  } else if ( ((lprup == 6 || lprup == 8 || lprup == 16) && ihvy1 == 6) ||
+              lprup == 5 || lprup == 13) {
+
+    // Go backwards through the particles looking for W/Z/top
+    int idx = myParticles.size() - 1;
+    for (int i = myParticles.size() - 1; i > -1; i--) {
+
+      // W or Z
+      if (myParticles[i].idPart == 23 ||
+          abs(myParticles[i].idPart) == 24) {
+
+        // Check that decay products and resonance match up
+        int flav;
+        if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
+          flav = 0;
+        else
+          flav = - (myParticles[idx].idPart % 2)
+                 - (myParticles[idx - 1].idPart % 2);
+        flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
+        if (flav != myParticles[i].idPart) {
+          if (infoPtr)
+            infoPtr->errorMsg("Error in LHAupAlpgen::addResonance: "
+                "resonance does not match decay products");
+          return false;
+        }
+
+        // Update status/mothers
+        myParticles[i].statusPart      = 2;
+        myParticles[idx  ].mother1Part = i + 1;
+        myParticles[idx--].mother2Part = 0;
+        myParticles[idx  ].mother1Part = i + 1;
+        myParticles[idx--].mother2Part = 0;
+
+      // Top
+      } else if (abs(myParticles[i].idPart) == 6) {
+
+        // Check that decay products and resonance match up
+        int flav;
+        if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
+          flav = 0;
+        else
+          flav = - (myParticles[idx].idPart % 2)
+                 - (myParticles[idx - 1].idPart % 2);
+        flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
+
+        bool outOfOrder = false, wrongFlavour = false;;
+        if ( abs(flav) != 24 ||
+             (flav ==  24 && myParticles[i].idPart !=  6) ||
+             (flav == -24 && myParticles[i].idPart != -6) ) {
+
+          // Processes 5 and 13, order should always be correct
+          if (lprup == 5 || lprup == 13) {
+            wrongFlavour = true;
+
+          // Processes 6, 8 and 16, can have out of order decay products
+          } else {
+
+            // Go back two decay products and retry
+            idx -= 2;
+            if (myParticles[idx].idPart + myParticles[idx - 1].idPart == 0)
+              flav = 0;
+            else
+              flav = - (myParticles[idx].idPart % 2)
+                     - (myParticles[idx - 1].idPart % 2);
+            flav = (flav > 0) ? 24 : (flav < 0) ? -24 : 23;
+
+            // If still the wrong flavour then error
+            if ( abs(flav) != 24 ||
+                 (flav ==  24 && myParticles[i].idPart !=  6) ||
+                 (flav == -24 && myParticles[i].idPart != -6) )
+              wrongFlavour = true;
+            else outOfOrder = true;
+          }
+
+          // Error if wrong flavour
+          if (wrongFlavour) {
+            if (infoPtr)
+              infoPtr->errorMsg("Error in LHAupAlpgen::addResonance: "
+                  "resonance does not match decay products");
+            return false;
+          }
+        }
+
+        // Mark t/tbar as now intermediate
+        myParticles[i].statusPart = 2;
+
+        // New intermediate W+/W-
+        idT      = flav;
+        statusT  = 2;
+        mother1T = i + 1;
+        mother2T = 0;
+        col1T = col2T = 0;
+        pxT = myParticles[idx].pxPart + myParticles[idx - 1].pxPart;
+        pyT = myParticles[idx].pyPart + myParticles[idx - 1].pyPart;
+        pzT = myParticles[idx].pzPart + myParticles[idx - 1].pzPart;
+        eT  = myParticles[idx].ePart  + myParticles[idx - 1].ePart;
+        mT  = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
+        myParticles.push_back(LHAParticle(
+            idT, statusT, mother1T, mother2T, col1T, col2T,
+            pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
+
+        // Update the decay product mothers
+        myParticles[idx  ].mother1Part = myParticles.size();
+        myParticles[idx--].mother2Part = 0;
+        myParticles[idx  ].mother1Part = myParticles.size();
+        myParticles[idx--].mother2Part = 0;
+
+        // New final-state b/bbar
+        idT     = (flav == 24) ? 5 : -5;
+        statusT = 1;
+        // Colour from top
+        col1T   = myParticles[i].col1Part;
+        col2T   = myParticles[i].col2Part;
+        // Momentum from (t/tbar - W+/W-)
+        pxT     = myParticles[i].pxPart - myParticles.back().pxPart;
+        pyT     = myParticles[i].pyPart - myParticles.back().pyPart;
+        pzT     = myParticles[i].pzPart - myParticles.back().pzPart;
+        eT      = myParticles[i].ePart  - myParticles.back().ePart;
+        mT      = sqrt(eT*eT - pxT*pxT - pyT*pyT - pzT*pzT);
+        myParticles.push_back(LHAParticle(
+            idT, statusT, mother1T, mother2T, col1T, col2T,
+            pxT, pyT, pzT, eT, mT, tauT, spinT, -1.));
+
+        // If decay products were out of order, reset idx to point
+        // at correct decay products
+        if (outOfOrder) idx += 4;
+
+      } // if (abs(myParticles[i].idPart) == 6)
+    } // for (i)
+
+
+  // Processes:
+  //    7 = QQbar + Q'Qbar' + jets (tops are not decayed)
+  //    9 =                   jets
+  //   11 = gamma           + jets
+  //   12 = Higgs           + jets
+  } else if (lprup == 7 || lprup == 9 || lprup == 11 || lprup == 12) {
+    // Nothing to do for these processes
+  }
+
+  // For single top, set incoming b mass if necessary
+  if (lprup == 13) for (int i = 0; i < 2; i++)
+    if (abs(myParticles[i].idPart) == 5) {
+      myParticles[i].mPart = mb;
+      myParticles[i].ePart = sqrt(pow2(myParticles[i].pzPart) + pow2(mb));
+    }
+
+  // Debug output and done.
+  if (LHADEBUG) printParticles();
+  return true;
+
+}
+
+// ----------------------------------------------------------------------
+
+// Routine to rescale momenta to remove any imbalances. The routine
+// assumes that any imbalances are due to decimal output/rounding
+// effects, and are therefore small.
+//
+// First any px/py imbalances are fixed by adjusting all outgoing
+// particles px/py and also updating their energy so mass is fixed.
+// Because incoming pT is zero, changes should be limited to ~0.001.
+//
+// Second, any pz/e imbalances are fixed by scaling the incoming beams
+// (again, no changes to masses required). Because incoming pz/e is not
+// zero, effects can be slightly larger ~0.002/0.003.
+
+  bool LHAupAlpgen::rescaleMomenta() {
+
+  // Total momenta in/out
+  int  nOut = 0;
+  Vec4 pIn, pOut;
+  for (int i = 0; i < int(myParticles.size()); i++) {
+    Vec4 pNow = Vec4(myParticles[i].pxPart, myParticles[i].pyPart,
+                     myParticles[i].pzPart, myParticles[i].ePart);
+    if (i < 2) pIn += pNow;
+    else if (myParticles[i].statusPart == 1) {
+      nOut++;
+      pOut += pNow;
+    }
+  }
+
+  // pT out to match pT in. Split any imbalances over all outgoing
+  // particles, and scale energies also to keep m^2 fixed.
+  if (abs(pOut.pT() - pIn.pT()) > ZEROTHRESHOLD) {
+    // Differences in px/py
+    double pxDiff = (pOut.px() - pIn.px()) / nOut,
+           pyDiff = (pOut.py() - pIn.py()) / nOut;
+
+    // Warn if resulting changes above warning threshold
+    if (pxDiff > PTWARNTHRESHOLD || pyDiff > PTWARNTHRESHOLD) {
+      if (infoPtr) infoPtr->errorMsg("Warning in LHAupAlpgen::setEvent: "
+          "large pT imbalance in incoming event");
+
+      // Debug printout
+      if (LHADEBUGRESCALE) {
+        printParticles();
+        cout << "pxDiff = " << pxDiff << ", pyDiff = " << pyDiff << endl;
+      }
+    }
+
+    // Adjust all final-state outgoing
+    pOut.reset();
+    for (int i = 2; i < int(myParticles.size()); i++) {
+      if (myParticles[i].statusPart != 1) continue;
+      myParticles[i].pxPart -= pxDiff;
+      myParticles[i].pyPart -= pyDiff;
+      myParticles[i].ePart   = sqrt(max(0., pow2(myParticles[i].pxPart) +
+          pow2(myParticles[i].pyPart) + pow2(myParticles[i].pzPart) +
+          pow2(myParticles[i].mPart)));
+      pOut += Vec4(myParticles[i].pxPart, myParticles[i].pyPart,
+                   myParticles[i].pzPart, myParticles[i].ePart);
+    }
+  }
+
+  // Differences in E/pZ and scaling factors
+  double de = (pOut.e()  - pIn.e());
+  double dp = (pOut.pz() - pIn.pz());
+  double a  = 1 + (de + dp) / 2. / myParticles[0].ePart;
+  double b  = 1 + (de - dp) / 2. / myParticles[1].ePart;
+
+  // Warn if resulting energy changes above warning threshold.
+  // Change in pz less than or equal to change in energy (incoming b
+  // quark can have mass at this stage for process 13). Note that for
+  // very small incoming momenta, the relative adjustment may be large,
+  // but still small in absolute terms.
+  if (abs(a - 1.) * myParticles[0].ePart > EWARNTHRESHOLD ||
+      abs(b - 1.) * myParticles[1].ePart > EWARNTHRESHOLD) {
+    if (infoPtr) infoPtr->errorMsg("Warning in LHAupAlpgen::setEvent: "
+        "large rescaling factor");
+
+    // Debug printout
+    if (LHADEBUGRESCALE) {
+      printParticles();
+      cout << "de = " << de << ", dp = " << dp
+           << ", a = " << a << ", b = " << b << endl
+           << "Absolute energy change for incoming 0 = "
+           << abs(a - 1.) * myParticles[0].ePart << endl
+           << "Absolute energy change for incoming 1 = "
+           << abs(b - 1.) * myParticles[1].ePart << endl;
+    }
+  }
+  myParticles[0].ePart  *= a;
+  myParticles[0].pzPart *= a;
+  myParticles[1].ePart  *= b;
+  myParticles[1].pzPart *= b;
+
+  // Recalculate resonance four vectors
+  for (int i = 0; i < int(myParticles.size()); i++) {
+    if (myParticles[i].statusPart != 2) continue;
+
+    // Only mothers stored in LHA, so go through all
+    Vec4 resVec;
+    for (int j = 0; j < int(myParticles.size()); j++) {
+      if (myParticles[j].mother1Part - 1 != i) continue;
+      resVec += Vec4(myParticles[j].pxPart, myParticles[j].pyPart,
+                     myParticles[j].pzPart, myParticles[j].ePart);
+    }
+
+    myParticles[i].pxPart = resVec.px();
+    myParticles[i].pyPart = resVec.py();
+    myParticles[i].pzPart = resVec.pz();
+    myParticles[i].ePart  = resVec.e();
+  }
+
+  return true;
+}
+
+
+//==========================================================================
+
+// Main implementation of AlpgenHooks class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+// ----------------------------------------------------------------------
+
+// Constructor: provides the 'Alpgen:file' option by directly
+//              changing the Pythia 'Beams' settings
+
+AlpgenHooks::AlpgenHooks(Pythia &pythia) : LHAagPtr(NULL) {
+
+  // If LHAupAlpgen needed, construct and pass to Pythia
+  string agFile = pythia.settings.word("Alpgen:file");
+  if (agFile != "void") {
+    LHAagPtr = new LHAupAlpgen(agFile.c_str(), &pythia.info);
+    pythia.settings.mode("Beams:frameType", 5);
+    pythia.setLHAupPtr(LHAagPtr);
+  }
+}
+
+// ----------------------------------------------------------------------
+
+// Initialisation routine which is called by pythia.init().
+// This happens after the local pointers have been assigned and after
+// Pythia has processed the Beam information (and therefore LHEF header
+// information has been read in), but before any other internal
+// initialisation. Provides the remaining 'Alpgen:*' options.
+
+  bool AlpgenHooks::initAfterBeams() {
+
+  // Read in ALPGEN specific configuration variables
+  bool setLightMasses = settingsPtr->flag("Alpgen:setLightMasses");
+  bool setHeavyMasses = settingsPtr->flag("Alpgen:setHeavyMasses");
+  bool setNjet   = settingsPtr->flag("Alpgen:setNjet");
+  bool setMLM    = settingsPtr->flag("Alpgen:setMLM");
+
+  // If ALPGEN parameters are present, then parse in AlpgenPar object
+  AlpgenPar par(infoPtr);
+  string parStr = infoPtr->header("AlpgenPar");
+  if (!parStr.empty()) {
+    par.parse(parStr);
+    par.printParams();
+  }
+
+  // Set masses if requested
+  if (setLightMasses) {
+    if (par.haveParam("mc")) particleDataPtr->m0(4,  par.getParam("mc"));
+    if (par.haveParam("mb")) particleDataPtr->m0(5,  par.getParam("mb"));
+  }
+  if (setHeavyMasses) {
+    if (par.haveParam("mt")) particleDataPtr->m0(6,  par.getParam("mt"));
+    if (par.haveParam("mz")) particleDataPtr->m0(23, par.getParam("mz"));
+    if (par.haveParam("mw")) particleDataPtr->m0(24, par.getParam("mw"));
+    if (par.haveParam("mh")) particleDataPtr->m0(25, par.getParam("mh"));
+  }
+
+  // Set MLM:nJets if requested
+  if (setNjet) {
+    if (par.haveParam("njets"))
+      settingsPtr->mode("JetMatching:nJet", par.getParamAsInt("njets"));
+    else
+      infoPtr->errorMsg("Warning in AlpgenHooks:init: "
+          "no ALPGEN nJet parameter found");
+  }
+
+  // Set MLM merging parameters if requested
+  if (setMLM) {
+    if (par.haveParam("ptjmin") && par.haveParam("drjmin") &&
+        par.haveParam("etajmax")) {
+      double ptjmin = par.getParam("ptjmin");
+      ptjmin = max(ptjmin + 5., 1.2 * ptjmin);
+      settingsPtr->parm("JetMatching:eTjetMin",   ptjmin);
+      settingsPtr->parm("JetMatching:coneRadius", par.getParam("drjmin"));
+      settingsPtr->parm("JetMatching:etaJetMax",  par.getParam("etajmax"));
+
+    // Warn if setMLM requested, but parameters not present
+    } else {
+      infoPtr->errorMsg("Warning in AlpgenHooks:init: "
+          "no ALPGEN merging parameters found");
+    }
+  }
+
+  // Initialisation complete.
+  return true;
+}
+
+
+
+
+//==========================================================================
+
+// Main implementation of MadgraphPar class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+//--------------------------------------------------------------------------
+
+// Constants: could be changed here if desired, but normally should not.
+// These are of technical nature, as described for each.
+
+// A zero threshold value for double comparisons.
+const double MadgraphPar::ZEROTHRESHOLD = 1e-10;
+
+//--------------------------------------------------------------------------
+
+// Parse an incoming Madgraph parameter file string
+
+  bool MadgraphPar::parse(const string paramStr) {
+
+  // Loop over incoming lines
+  stringstream paramStream(paramStr);
+  string line;
+  while ( getline(paramStream, line) ) extractRunParam(line);
+  return true;
+
+}
+
+//--------------------------------------------------------------------------
+
+// Parse an incoming parameter line
+
+  void MadgraphPar::extractRunParam(string line) {
+
+  // Extract information to the right of the final '!' character
+  size_t idz = line.find("#");
+  if ( !(idz == string::npos) ) return;
+  size_t idx = line.find("=");
+  size_t idy = line.find("!");
+  if (idy == string::npos) idy = line.size();
+  if (idx == string::npos) return;
+  string paramName = trim( line.substr( idx + 1, idy - idx - 1) );
+  string paramVal  = trim( line.substr( 0, idx) );
+  replace( paramVal.begin(), paramVal.end(), 'd', 'e');
+
+  // Simple tokeniser
+  istringstream iss(paramVal);
+  double val;
+  if (paramName.find(",") != string::npos) {
+    string        paramNameNow;
+    istringstream issName( paramName);
+    while ( getline(issName, paramNameNow, ',') ) {
+      iss >> val;
+      warnParamOverwrite( paramNameNow, val);
+      params[paramNameNow] = val;
+    }
+
+  // Default case: assume integer and double on the left
+  } else {
+    iss >> val;
+    warnParamOverwrite( paramName, val);
+    params[paramName] = val;
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Print parameters read from the '.par' file
+
+  void MadgraphPar::printParams() {
+
+  // Loop over all stored parameters and print
+  cout << endl
+       << " *--------  Madgraph parameters  --------*" << endl;
+  for (map<string,double>::iterator it = params.begin();
+       it != params.end(); ++it)
+    cout << " |  " << left << setw(15) << it->first
+         << "  |  " << right << setw(15) << it->second
+         << "  |" << endl;
+  cout << " *---------------------------------------*" << endl;
+}
+
+//--------------------------------------------------------------------------
+
+// Warn if a parameter is going to be overwriten
+
+  void MadgraphPar::warnParamOverwrite(const string &paramIn,
+  double val) {
+
+  // Check if present and if new value is different
+  if (haveParam(paramIn) &&
+      abs(getParam(paramIn) - val) > ZEROTHRESHOLD) {
+    if (infoPtr) infoPtr->errorMsg("Warning in LHAupAlpgen::"
+        "warnParamOverwrite: overwriting existing parameter", paramIn);
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Simple string trimmer
+
+  string MadgraphPar::trim(string s) {
+
+  // Remove whitespace in incoming string
+  size_t i;
+  if ( (i = s.find_last_not_of(" \t\r\n")) != string::npos)
+    s = s.substr(0, i + 1);
+  if ( (i = s.find_first_not_of(" \t\r\n")) != string::npos)
+    s = s.substr(i);
+  return s;
+}
+
+} // end namespace Pythia8
+
diff -rupN pythia_8.212_original/src/JetMatching.cc pythia_8.212_patched_nohepmc/src/JetMatching.cc
--- pythia_8.212_original/src/JetMatching.cc	1970-01-01 01:00:00.000000000 +0100
+++ pythia_8.212_patched_nohepmc/src/JetMatching.cc	2020-09-09 20:18:31.109240459 +0200
@@ -0,0 +1,1481 @@
+#include "Pythia8Plugins/JetMatching.h"
+
+// GAMBIT: We moved the below definitions from GeneratorInput.h
+//         to this source file to allow easy BOSSing
+
+
+namespace Pythia8 {
+
+//==========================================================================
+
+// Main implementation of JetMatching class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+//--------------------------------------------------------------------------
+
+// Constants to be changed for debug printout or extra checks.
+const bool JetMatching::MATCHINGDEBUG = false;
+const bool JetMatching::MATCHINGCHECK = false;
+
+//--------------------------------------------------------------------------
+
+// Early parton level veto (before beam remnants and resonance showers)
+
+inline bool JetMatching::doVetoPartonLevelEarly(const Event& event) {
+
+  // 1) Sort the original incoming process. After this step is performed,
+  //    the following assignments have been made:
+  //    eventProcessOrig - the original incoming process
+  //    eventProcess     - the final-state of the incoming process with
+  //                       resonance decays removed (and resonances
+  //                       themselves now with positive status code)
+  //    typeIdx[0/1/2]   - Indices into 'eventProcess' of
+  //                       light jets/heavy jets/other
+  //    typeSet[0/1/2]   - Indices into 'event' of light jets/heavy jets/other
+  //    workEvent        - partons from the hardest subsystem + ISR + FSR only
+  sortIncomingProcess(event);
+
+  // For the shower-kT scheme, do not perform any veto here, as any vetoing
+  // will already have taken place in doVetoStep.
+  if ( doShowerKt ) return false;
+
+  // Debug printout.
+  if (MATCHINGDEBUG) {
+    // Begin
+    cout << endl << "-------- Begin Madgraph Debug --------" << endl;
+    // Original incoming process
+    cout << endl << "Original incoming process:";
+    eventProcessOrig.list();
+    // Final-state of original incoming process
+    cout << endl << "Final-state incoming process:";
+    eventProcess.list();
+    // List categories of sorted particles
+    for (size_t i = 0; i < typeIdx[0].size(); i++)
+      cout << ((i == 0) ? "Light jets: " : ", ")   << setw(3) << typeIdx[0][i];
+    if( typeIdx[0].size()== 0 )
+      cout << "Light jets: None";
+
+    for (size_t i = 0; i < typeIdx[1].size(); i++)
+      cout << ((i == 0) ? "\nHeavy jets: " : ", ") << setw(3) << typeIdx[1][i];
+    for (size_t i = 0; i < typeIdx[2].size(); i++)
+      cout << ((i == 0) ? "\nOther:      " : ", ") << setw(3) << typeIdx[2][i];
+    // Full event at this stage
+    cout << endl << endl << "Event:";
+    event.list();
+    // Work event (partons from hardest subsystem + ISR + FSR)
+    cout << endl << "Work event:";
+    workEvent.list();
+  }
+
+  // 2) Light/heavy jets: iType = 0 (light jets), 1 (heavy jets)
+  int iTypeEnd = (typeIdx[1].empty()) ? 1 : 2;
+  for (int iType = 0; iType < iTypeEnd; iType++) {
+
+    // 2a) Find particles which will be passed from the jet algorithm.
+    //     Input from 'workEvent' and output in 'workEventJet'.
+    jetAlgorithmInput(event, iType);
+
+    // Debug printout.
+    if (MATCHINGDEBUG) {
+      // Jet algorithm event
+      cout << endl << "Jet algorithm event (iType = " << iType << "):";
+      workEventJet.list();
+    }
+
+    // 2b) Run jet algorithm on 'workEventJet'.
+    //     Output is stored in jetMomenta.
+    runJetAlgorithm();
+
+    // 2c) Match partons to jets and decide if veto is necessary
+    if (matchPartonsToJets(iType) == true) {
+      // Debug printout.
+      if (MATCHINGDEBUG) {
+        cout << endl << "Event vetoed" << endl
+             << "----------  End MLM Debug  ----------" << endl;
+      }
+      return true;
+    }
+  }
+
+  // Debug printout.
+  if (MATCHINGDEBUG) {
+    cout << endl << "Event accepted" << endl
+         << "----------  End MLM Debug  ----------" << endl;
+  }
+
+  // If we reached here, then no veto
+  return false;
+
+}
+
+
+//==========================================================================
+
+// Main implementation of Alpgen UserHooks class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+//--------------------------------------------------------------------------
+
+// Constants: could be changed here if desired, but normally should not.
+// These are of technical nature, as described for each.
+
+// The energy of ghost particles. For technical reasons, this cannot be
+// set arbitrarily low, see 'Particle::TINY' in 'Event.cc' for details.
+const double JetMatchingAlpgen::GHOSTENERGY   = 1e-15;
+
+// A zero threshold value for double comparisons.
+const double JetMatchingAlpgen::ZEROTHRESHOLD = 1e-10;
+
+//--------------------------------------------------------------------------
+
+// Function to sort typeIdx vectors into descending eT/pT order.
+// Uses a selection sort, as number of partons generally small
+// and so efficiency not a worry.
+
+inline void JetMatchingAlpgen::sortTypeIdx(vector < int > &vecIn) {
+  for (size_t i = 0; i < vecIn.size(); i++) {
+    size_t jMax = i;
+    double vMax = (jetAlgorithm == 1) ?
+      eventProcess[vecIn[i]].eT() :
+      eventProcess[vecIn[i]].pT();
+    for (size_t j = i + 1; j < vecIn.size(); j++) {
+      double vNow = (jetAlgorithm == 1)
+        ? eventProcess[vecIn[j]].eT() : eventProcess[vecIn[j]].pT();
+      if (vNow > vMax) {
+        vMax = vNow;
+        jMax = j;
+      }
+    }
+    if (jMax != i) swap(vecIn[i], vecIn[jMax]);
+  }
+}
+
+//--------------------------------------------------------------------------
+
+// Initialisation routine automatically called from Pythia::init().
+// Setup all parts needed for the merging.
+
+inline bool JetMatchingAlpgen::initAfterBeams() {
+
+  // Read in parameters
+  doMerge         = settingsPtr->flag("JetMatching:merge");
+  jetAlgorithm    = settingsPtr->mode("JetMatching:jetAlgorithm");
+  nJet            = settingsPtr->mode("JetMatching:nJet");
+  nJetMax         = settingsPtr->mode("JetMatching:nJetMax");
+  eTjetMin        = settingsPtr->parm("JetMatching:eTjetMin");
+  coneRadius      = settingsPtr->parm("JetMatching:coneRadius");
+  etaJetMax       = settingsPtr->parm("JetMatching:etaJetMax");
+  doShowerKt      = settingsPtr->flag("JetMatching:doShowerKt");
+
+  // Use etaJetMax + coneRadius in input to jet algorithms
+  etaJetMaxAlgo   = etaJetMax + coneRadius;
+
+  // CellJet specific
+  nEta            = settingsPtr->mode("JetMatching:nEta");
+  nPhi            = settingsPtr->mode("JetMatching:nPhi");
+  eTseed          = settingsPtr->parm("JetMatching:eTseed");
+  eTthreshold     = settingsPtr->parm("JetMatching:eTthreshold");
+
+  // SlowJet specific
+  slowJetPower    = settingsPtr->mode("JetMatching:slowJetPower");
+  coneMatchLight  = settingsPtr->parm("JetMatching:coneMatchLight");
+  coneRadiusHeavy = settingsPtr->parm("JetMatching:coneRadiusHeavy");
+  if (coneRadiusHeavy < 0.) coneRadiusHeavy = coneRadius;
+  coneMatchHeavy  = settingsPtr->parm("JetMatching:coneMatchHeavy");
+
+  // Matching procedure
+  jetAllow        = settingsPtr->mode("JetMatching:jetAllow");
+  jetMatch        = settingsPtr->mode("JetMatching:jetMatch");
+  exclusiveMode   = settingsPtr->mode("JetMatching:exclusive");
+
+  // If not merging, then done
+  if (!doMerge) return true;
+
+  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
+  if (exclusiveMode == 2) {
+
+    // No nJet or nJetMax, so default to exclusive mode
+    if (nJet < 0 || nJetMax < 0) {
+      infoPtr->errorMsg("Warning in JetMatchingAlpgen:init: "
+          "missing jet multiplicity information; running in exclusive mode");
+      exclusive = true;
+
+    // Inclusive if nJet == nJetMax, exclusive otherwise
+    } else {
+      exclusive = (nJet == nJetMax) ? false : true;
+    }
+
+  // Otherwise, just set as given
+  } else {
+    exclusive = (exclusiveMode == 0) ? false : true;
+  }
+
+  // Initialise chosen jet algorithm. CellJet.
+  if (jetAlgorithm == 1) {
+
+    // Extra options for CellJet. nSel = 1 means that all final-state
+    // particles are taken and we retain control of what to select.
+    // smear/resolution/upperCut are not used and are set to default values.
+    int    nSel = 2, smear = 0;
+    double resolution = 0.5, upperCut = 2.;
+    cellJet = new CellJet(etaJetMaxAlgo, nEta, nPhi, nSel,
+                          smear, resolution, upperCut, eTthreshold);
+
+  // SlowJet
+  } else if (jetAlgorithm == 2) {
+    slowJet = new SlowJet(slowJetPower, coneRadius, eTjetMin, etaJetMaxAlgo);
+  }
+
+  // Check the jetMatch parameter; option 2 only works with SlowJet
+  if (jetAlgorithm == 1 && jetMatch == 2) {
+    infoPtr->errorMsg("Warning in JetMatchingAlpgen:init: "
+        "jetMatch = 2 only valid with SlowJet algorithm. "
+        "Reverting to jetMatch = 1");
+    jetMatch = 1;
+  }
+
+  // Setup local event records
+  eventProcessOrig.init("(eventProcessOrig)", particleDataPtr);
+  eventProcess.init("(eventProcess)", particleDataPtr);
+  workEventJet.init("(workEventJet)", particleDataPtr);
+
+  // Print information
+  string jetStr  = (jetAlgorithm ==  1) ? "CellJet" :
+                   (slowJetPower == -1) ? "anti-kT" :
+                   (slowJetPower ==  0) ? "C/A"     :
+                   (slowJetPower ==  1) ? "kT"      : "unknown";
+  string modeStr = (exclusive)         ? "exclusive" : "inclusive";
+  stringstream nJetStr, nJetMaxStr;
+  if (nJet >= 0)    nJetStr    << nJet;    else nJetStr    << "unknown";
+  if (nJetMax >= 0) nJetMaxStr << nJetMax; else nJetMaxStr << "unknown";
+  cout << endl
+       << " *-------  MLM matching parameters  -------*" << endl
+       << " |  nJet                |  " << setw(14)
+       << nJetStr.str() << "  |" << endl
+       << " |  nJetMax             |  " << setw(14)
+       << nJetMaxStr.str() << "  |" << endl
+       << " |  Jet algorithm       |  " << setw(14)
+       << jetStr << "  |" << endl
+       << " |  eTjetMin            |  " << setw(14)
+       << eTjetMin << "  |" << endl
+       << " |  coneRadius          |  " << setw(14)
+       << coneRadius << "  |" << endl
+       << " |  etaJetMax           |  " << setw(14)
+       << etaJetMax << "  |" << endl
+       << " |  jetAllow            |  " << setw(14)
+       << jetAllow << "  |" << endl
+       << " |  jetMatch            |  " << setw(14)
+       << jetMatch << "  |" << endl
+       << " |  coneMatchLight      |  " << setw(14)
+       << coneMatchLight << "  |" << endl
+       << " |  coneRadiusHeavy     |  " << setw(14)
+       << coneRadiusHeavy << "  |" << endl
+       << " |  coneMatchHeavy      |  " << setw(14)
+       << coneMatchHeavy << "  |" << endl
+       << " |  Mode                |  " << setw(14)
+       << modeStr << "  |" << endl
+       << " *-----------------------------------------*" << endl;
+
+  return true;
+}
+
+//--------------------------------------------------------------------------
+
+// Step (1): sort the incoming particles
+
+inline void JetMatchingAlpgen::sortIncomingProcess(const Event &event) {
+
+  // Remove resonance decays from original process and keep only final
+  // state. Resonances will have positive status code after this step.
+  omitResonanceDecays(eventProcessOrig, true);
+  eventProcess = workEvent;
+
+  // Sort original process final state into light/heavy jets and 'other'.
+  // Criteria:
+  //   1 <= ID <= 5 and massless, or ID == 21 --> light jet (typeIdx[0])
+  //   4 <= ID <= 6 and massive               --> heavy jet (typeIdx[1])
+  //   All else                               --> other     (typeIdx[2])
+  // Note that 'typeIdx' stores indices into 'eventProcess' (after resonance
+  // decays are omitted), while 'typeSet' stores indices into the original
+  // process record, 'eventProcessOrig', but these indices are also valid
+  // in 'event'.
+  for (int i = 0; i < 3; i++) {
+    typeIdx[i].clear();
+    typeSet[i].clear();
+  }
+  for (int i = 0; i < eventProcess.size(); i++) {
+    // Ignore nonfinal and default to 'other'
+    if (!eventProcess[i].isFinal()) continue;
+    int idx = 2;
+
+    // Light jets
+    if (eventProcess[i].id() == ID_GLUON
+      || (eventProcess[i].idAbs() <= ID_BOT
+      && abs(eventProcess[i].m()) < ZEROTHRESHOLD)) idx = 0;
+
+    // Heavy jets
+    else if (eventProcess[i].idAbs() >= ID_CHARM
+      && eventProcess[i].idAbs() <= ID_TOP) idx = 1;
+
+    // Store
+    typeIdx[idx].push_back(i);
+    typeSet[idx].insert(eventProcess[i].daughter1());
+  }
+
+  // Extract partons from hardest subsystem + ISR + FSR only into
+  // workEvent. Note no resonance showers or MPIs.
+  subEvent(event);
+}
+
+//--------------------------------------------------------------------------
+
+// Step (2a): pick which particles to pass to the jet algorithm
+
+inline void JetMatchingAlpgen::jetAlgorithmInput(const Event &event,
+  int iType) {
+
+  // Take input from 'workEvent' and put output in 'workEventJet'
+  workEventJet = workEvent;
+
+  // Loop over particles and decide what to pass to the jet algorithm
+  for (int i = 0; i < workEventJet.size(); ++i) {
+    if (!workEventJet[i].isFinal()) continue;
+
+    // jetAllow option to disallow certain particle types
+    if (jetAllow == 1) {
+
+      // Original AG+Py6 algorithm explicitly excludes tops,
+      // leptons and photons.
+      int id = workEventJet[i].idAbs();
+      if ( (id >= ID_LEPMIN && id <= ID_LEPMAX) || id == ID_TOP
+        || id == ID_PHOTON) {
+        workEventJet[i].statusNeg();
+        continue;
+      }
+    }
+
+    // Get the index of this particle in original event
+    int idx = workEventJet[i].daughter1();
+
+    // Start with particle idx, and afterwards track mothers
+    while (true) {
+
+      // Light jets
+      if (iType == 0) {
+
+        // Do not include if originates from heavy jet or 'other'
+        if (typeSet[1].find(idx) != typeSet[1].end() ||
+            typeSet[2].find(idx) != typeSet[2].end()) {
+          workEventJet[i].statusNeg();
+          break;
+        }
+
+        // Made it to start of event record so done
+        if (idx == 0) break;
+        // Otherwise next mother and continue
+        idx = event[idx].mother1();
+
+      // Heavy jets
+      } else if (iType == 1) {
+
+        // Only include if originates from heavy jet
+        if (typeSet[1].find(idx) != typeSet[1].end()) break;
+
+        // Made it to start of event record with no heavy jet mother,
+        // so DO NOT include particle
+        if (idx == 0) {
+          workEventJet[i].statusNeg();
+          break;
+        }
+
+        // Otherwise next mother and continue
+        idx = event[idx].mother1();
+
+      } // if (iType)
+    } // while (true)
+  } // for (i)
+
+  // For jetMatch = 2, insert ghost particles corresponding to
+  // each hard parton in the original process
+  if (jetMatch == 2) {
+    for (int i = 0; i < int(typeIdx[iType].size()); i++) {
+      // Get y/phi of the parton
+      Vec4   pIn = eventProcess[typeIdx[iType][i]].p();
+      double y   = pIn.rap();
+      double phi = pIn.phi();
+
+      // Create a ghost particle and add to the workEventJet
+      double e   = GHOSTENERGY;
+      double e2y = exp(2. * y);
+      double pz  = e * (e2y - 1.) / (e2y + 1.);
+      double pt  = sqrt(e*e - pz*pz);
+      double px  = pt * cos(phi);
+      double py  = pt * sin(phi);
+      workEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0, px, py, pz, e);
+
+      // Extra check on reconstructed y/phi values. If many warnings
+      // of this type, GHOSTENERGY may be set too low.
+      if (MATCHINGCHECK) {
+      int lastIdx = workEventJet.size() - 1;
+      if (abs(y   - workEventJet[lastIdx].y())   > ZEROTHRESHOLD ||
+          abs(phi - workEventJet[lastIdx].phi()) > ZEROTHRESHOLD)
+        infoPtr->errorMsg("Warning in JetMatchingAlpgen:jetAlgorithmInput: "
+            "ghost particle y/phi mismatch");
+      }
+
+    } // for (i)
+  } // if (jetMatch == 2)
+}
+
+//--------------------------------------------------------------------------
+
+// Step (2b): run jet algorithm and provide common output
+
+inline void JetMatchingAlpgen::runJetAlgorithm() {
+
+  // Run the jet clustering algorithm
+  if (jetAlgorithm == 1)
+    cellJet->analyze(workEventJet, eTjetMin, coneRadius, eTseed);
+  else
+    slowJet->analyze(workEventJet);
+
+  // Extract four-momenta of jets with |eta| < etaJetMax and
+  // put into jetMomenta. Note that this is done backwards as
+  // jets are removed with SlowJet.
+  jetMomenta.clear();
+  int iJet = (jetAlgorithm == 1) ? cellJet->size() - 1:
+                                   slowJet->sizeJet() - 1;
+  for (int i = iJet; i > -1; i--) {
+    Vec4 jetMom = (jetAlgorithm == 1) ? cellJet->pMassive(i) :
+                                        slowJet->p(i);
+    double eta = jetMom.eta();
+
+    if (abs(eta) > etaJetMax) {
+      if (jetAlgorithm == 2) slowJet->removeJet(i);
+      continue;
+    }
+    jetMomenta.push_back(jetMom);
+  }
+
+  // Reverse jetMomenta to restore eT/pT ordering
+  reverse(jetMomenta.begin(), jetMomenta.end());
+}
+
+//--------------------------------------------------------------------------
+
+// Step (2c): veto decision (returning true vetoes the event)
+
+inline bool JetMatchingAlpgen::matchPartonsToJets(int iType) {
+
+  // Use two different routines for light/heavy jets as
+  // different veto conditions and for clarity
+  if (iType == 0) return (matchPartonsToJetsLight() > 0);
+  else            return (matchPartonsToJetsHeavy() > 0);
+}
+
+//--------------------------------------------------------------------------
+
+// Step(2c): light jets
+// Return codes are given indicating the reason for a veto.
+// Although not currently used, they are a useful debugging tool:
+//   0 = no veto
+//   1 = veto as number of jets less than number of partons
+//   2 = veto as exclusive mode and number of jets greater than
+//       number of partons
+//   3 = veto as inclusive mode and there would be an extra jet
+//       that is harder than any matched soft jet
+//   4 = veto as there is a parton which does not match a jet
+
+inline int JetMatchingAlpgen::matchPartonsToJetsLight() {
+
+  // Always veto if number of jets is less than original number of jets
+  if (jetMomenta.size() < typeIdx[0].size()) return LESS_JETS;
+  // Veto if in exclusive mode and number of jets bigger than original
+  if (exclusive && jetMomenta.size() > typeIdx[0].size()) return MORE_JETS;
+
+  // Sort partons by eT/pT
+  sortTypeIdx(typeIdx[0]);
+
+  // Number of hard partons
+  int nParton = typeIdx[0].size();
+
+  // Keep track of which jets have been assigned a hard parton
+  vector < bool > jetAssigned;
+  jetAssigned.assign(jetMomenta.size(), false);
+
+  // Jet matching procedure: (1) deltaR between partons and jets
+  if (jetMatch == 1) {
+
+    // Loop over light hard partons and get 4-momentum
+    for (int i = 0; i < nParton; i++) {
+      Vec4 p1 = eventProcess[typeIdx[0][i]].p();
+
+      // Track which jet has the minimal dR measure with this parton
+      int    jMin  = -1;
+      double dRmin = 0.;
+
+      // Loop over all jets (skipping those already assigned).
+      for (int j = 0; j < int(jetMomenta.size()); j++) {
+        if (jetAssigned[j]) continue;
+
+        // DeltaR between parton/jet and store if minimum
+        double dR = (jetAlgorithm == 1)
+          ? REtaPhi(p1, jetMomenta[j]) : RRapPhi(p1, jetMomenta[j]);
+        if (jMin < 0 || dR < dRmin) {
+          dRmin = dR;
+          jMin  = j;
+        }
+      } // for (j)
+
+      // Check for jet-parton match
+      if (jMin >= 0 && dRmin < coneRadius * coneMatchLight) {
+
+        // If the matched jet is not one of the nParton hardest jets,
+        // the extra left over jet would be harder than some of the
+        // matched jets. This is disallowed, so veto.
+        if (jMin >= nParton) return HARD_JET;
+
+        // Mark jet as assigned.
+        jetAssigned[jMin] = true;
+
+      // If no match, then event will be vetoed in all cases
+      } else return UNMATCHED_PARTON;
+
+    } // for (i)
+
+  // Jet matching procedure: (2) ghost particles in SlowJet
+  } else {
+
+    // Loop over added 'ghost' particles and find if assigned to a jet
+    for (int i = workEventJet.size() - nParton;
+        i < workEventJet.size(); i++) {
+      int jMin = slowJet->jetAssignment(i);
+
+      // Veto if:
+      //  1) not one of nParton hardest jets
+      //  2) not assigned to a jet
+      //  3) jet has already been assigned
+      if (jMin >= nParton)               return HARD_JET;
+      if (jMin < 0 || jetAssigned[jMin]) return UNMATCHED_PARTON;
+
+      // Mark jet as assigned
+      jetAssigned[jMin] = true;
+
+    } // for (i)
+  } // if (jetMatch)
+
+  // Minimal eT/pT (CellJet/SlowJet) of matched light jets. Needed
+  // later for heavy jet vetos in inclusive mode.
+  if (nParton > 0)
+    eTpTlightMin = (jetAlgorithm == 1) ? jetMomenta[nParton - 1].eT()
+                                       : jetMomenta[nParton - 1].pT();
+  else
+    eTpTlightMin = -1.;
+
+  // No veto
+  return NONE;
+}
+
+//--------------------------------------------------------------------------
+
+// Step(2c): heavy jets
+// Return codes are given indicating the reason for a veto.
+// Although not currently used, they are a useful debugging tool:
+//   0 = no veto as there are no extra jets present
+//   1 = veto as in exclusive mode and extra jets present
+//   2 = veto as in inclusive mode and extra jets were harder
+//       than any matched light jet
+
+inline int JetMatchingAlpgen::matchPartonsToJetsHeavy() {
+
+  // If there are no extra jets, then accept
+  if (jetMomenta.empty()) return NONE;
+
+  // Number of hard partons
+  int nParton = typeIdx[1].size();
+
+  // Remove jets that are close to heavy quarks
+  set < int > removeJets;
+
+  // Jet matching procedure: (1) deltaR between partons and jets
+  if (jetMatch == 1) {
+
+    // Loop over heavy hard partons and get 4-momentum
+    for (int i = 0; i < nParton; i++) {
+      Vec4 p1 = eventProcess[typeIdx[1][i]].p();
+
+      // Loop over all jets, find dR and mark for removal if match
+      for (int j = 0; j < int(jetMomenta.size()); j++) {
+        double dR = (jetAlgorithm == 1) ?
+            REtaPhi(p1, jetMomenta[j]) : RRapPhi(p1, jetMomenta[j]);
+        if (dR < coneRadiusHeavy * coneMatchHeavy)
+          removeJets.insert(j);
+
+      } // for (j)
+    } // for (i)
+
+  // Jet matching procedure: (2) ghost particles in SlowJet
+  } else {
+
+    // Loop over added 'ghost' particles and if assigned to a jet
+    // then mark this jet for removal
+    for (int i = workEventJet.size() - nParton;
+        i < workEventJet.size(); i++) {
+      int jMin = slowJet->jetAssignment(i);
+      if (jMin >= 0) removeJets.insert(jMin);
+    }
+
+  }
+
+  // Remove jets (backwards order to not disturb indices)
+  for (set < int >::reverse_iterator it  = removeJets.rbegin();
+                                     it != removeJets.rend(); it++)
+    jetMomenta.erase(jetMomenta.begin() + *it);
+
+  // Handle case if there are still extra jets
+  if (!jetMomenta.empty()) {
+
+    // Exclusive mode, so immediate veto
+    if (exclusive) return MORE_JETS;
+
+    // Inclusive mode; extra jets must be softer than any matched light jet
+    else if (eTpTlightMin >= 0.)
+      for (size_t j = 0; j < jetMomenta.size(); j++) {
+        // CellJet uses eT, SlowJet uses pT
+        if ( (jetAlgorithm == 1 && jetMomenta[j].eT() > eTpTlightMin) ||
+             (jetAlgorithm == 2 && jetMomenta[j].pT() > eTpTlightMin) )
+          return HARD_JET;
+      }
+
+  } // if (!jetMomenta.empty())
+
+  // No extra jets were present so no veto
+  return NONE;
+}
+
+
+//==========================================================================
+
+// Main implementation of Madgraph UserHooks class.
+// This may be split out to a separate C++ file if desired,
+// but currently included here for ease of use.
+
+//--------------------------------------------------------------------------
+
+// Initialisation routine automatically called from Pythia::init().
+// Setup all parts needed for the merging.
+
+inline bool JetMatchingMadgraph::initAfterBeams() {
+
+  // Read in Madgraph specific configuration variables
+  bool setMad    = settingsPtr->flag("JetMatching:setMad");
+
+  // If Madgraph parameters are present, then parse in MadgraphPar object
+  MadgraphPar par(infoPtr);
+  string parStr = infoPtr->header("MGRunCard");
+  if (!parStr.empty()) {
+    par.parse(parStr);
+    par.printParams();
+  }
+
+  // Set Madgraph merging parameters from the file if requested
+  if (setMad) {
+    if ( par.haveParam("xqcut")    && par.haveParam("maxjetflavor")
+      && par.haveParam("alpsfact") && par.haveParam("ickkw") ) {
+      settingsPtr->flag("JetMatching:merge", par.getParam("ickkw"));
+      settingsPtr->parm("JetMatching:qCut", par.getParam("xqcut"));
+      settingsPtr->mode("JetMatching:nQmatch",
+        par.getParamAsInt("maxjetflavor"));
+      settingsPtr->parm("JetMatching:clFact",
+        clFact = par.getParam("alpsfact"));
+      if (par.getParamAsInt("ickkw") == 0)
+        infoPtr->errorMsg("Error in JetMatchingMadgraph:init: "
+          "Madgraph file parameters are not set for merging");
+
+    // Warn if setMad requested, but one or more parameters not present
+    } else {
+       infoPtr->errorMsg("Warning in JetMatchingMadgraph:init: "
+          "Madgraph merging parameters not found");
+       if (!par.haveParam("xqcut")) infoPtr->errorMsg("Warning in "
+          "JetMatchingMadgraph:init: No xqcut");
+       if (!par.haveParam("ickkw")) infoPtr->errorMsg("Warning in "
+          "JetMatchingMadgraph:init: No ickkw");
+       if (!par.haveParam("maxjetflavor")) infoPtr->errorMsg("Warning in "
+          "JetMatchingMadgraph:init: No maxjetflavor");
+       if (!par.haveParam("alpsfact")) infoPtr->errorMsg("Warning in "
+          "JetMatchingMadgraph:init: No alpsfact");
+    }
+  }
+
+  // Read in FxFx matching parameters
+  doFxFx       = settingsPtr->flag("JetMatching:doFxFx");
+  nPartonsNow  = settingsPtr->mode("JetMatching:nPartonsNow");
+  qCutME       = settingsPtr->parm("JetMatching:qCutME");
+  qCutMESq     = pow(qCutME,2);
+
+  // Read in Madgraph merging parameters
+  doMerge      = settingsPtr->flag("JetMatching:merge");
+  doShowerKt   = settingsPtr->flag("JetMatching:doShowerKt");
+  qCut         = settingsPtr->parm("JetMatching:qCut");
+  nQmatch      = settingsPtr->mode("JetMatching:nQmatch");
+  clFact       = settingsPtr->parm("JetMatching:clFact");
+
+  // Read in jet algorithm parameters
+  jetAlgorithm   = settingsPtr->mode("JetMatching:jetAlgorithm");
+  nJetMax        = settingsPtr->mode("JetMatching:nJetMax");
+  eTjetMin       = settingsPtr->parm("JetMatching:eTjetMin");
+  coneRadius     = settingsPtr->parm("JetMatching:coneRadius");
+  etaJetMax      = settingsPtr->parm("JetMatching:etaJetMax");
+  slowJetPower   = settingsPtr->mode("JetMatching:slowJetPower");
+
+  // Matching procedure
+  jetAllow       = settingsPtr->mode("JetMatching:jetAllow");
+  exclusiveMode  = settingsPtr->mode("JetMatching:exclusive");
+  qCutSq         = pow(qCut,2);
+  etaJetMaxAlgo  = etaJetMax;
+
+  // If not merging, then done
+  if (!doMerge) return true;
+
+  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
+  if (exclusiveMode == 2) {
+
+    // No nJet or nJetMax, so default to exclusive mode
+    if (nJetMax < 0) {
+      infoPtr->errorMsg("Warning in JetMatchingMadgraph:init: "
+        "missing jet multiplicity information; running in exclusive mode");
+      exclusiveMode = 1;
+    }
+  }
+
+  // Initialise chosen jet algorithm.
+  // Currently, this only supports the kT-algorithm in SlowJet.
+  // Use the QCD distance measure by default.
+  jetAlgorithm = 2;
+  slowJetPower = 1;
+  slowJet = new SlowJet(slowJetPower, coneRadius, eTjetMin,
+    etaJetMaxAlgo, 2, 2, NULL, false);
+
+  // For FxFx, also initialise jet algorithm to define matrix element jets.
+  // Currently, this only supports the kT-algorithm in SlowJet.
+  // Use the QCD distance measure by default.
+  slowJetHard = new SlowJet(slowJetPower, coneRadius, qCutME,
+    etaJetMaxAlgo, 2, 2, NULL, false);
+
+  // To access the DJR's
+  slowJetDJR = new SlowJet(slowJetPower, coneRadius, qCutME,
+    etaJetMaxAlgo, 2, 2, NULL, false);
+
+  // Setup local event records
+  eventProcessOrig.init("(eventProcessOrig)", particleDataPtr);
+  eventProcess.init("(eventProcess)", particleDataPtr);
+  workEventJet.init("(workEventJet)", particleDataPtr);
+
+  // Print information
+  string jetStr  = (jetAlgorithm ==  1) ? "CellJet" :
+                   (slowJetPower == -1) ? "anti-kT" :
+                   (slowJetPower ==  0) ? "C/A"     :
+                   (slowJetPower ==  1) ? "kT"      : "unknown";
+  string modeStr = (exclusiveMode)         ? "exclusive" : "inclusive";
+  cout << endl
+       << " *-----  Madgraph matching parameters  -----*" << endl
+       << " |  qCut                |  " << setw(14)
+       << qCut << "  |" << endl
+       << " |  nQmatch             |  " << setw(14)
+       << nQmatch << "  |" << endl
+       << " |  clFact              |  " << setw(14)
+       << clFact << "  |" << endl
+       << " |  Jet algorithm       |  " << setw(14)
+       << jetStr << "  |" << endl
+       << " |  eTjetMin            |  " << setw(14)
+       << eTjetMin << "  |" << endl
+       << " |  etaJetMax           |  " << setw(14)
+       << etaJetMax << "  |" << endl
+       << " |  jetAllow            |  " << setw(14)
+       << jetAllow << "  |" << endl
+       << " |  Mode                |  " << setw(14)
+       << modeStr << "  |" << endl
+       << " *-----------------------------------------*" << endl;
+
+  return true;
+}
+
+//--------------------------------------------------------------------------
+
+// Process level vetos
+
+inline bool JetMatchingMadgraph::doVetoProcessLevel(Event& process) {
+
+  eventProcessOrig = process;
+
+  // Setup for veto if hard ME has too many partons.
+  // This is done to achieve consistency with the Pythia6 implementation.
+
+  // Clear the event of MPI systems and resonace decay products. Store trimmed
+  // event in workEvent.
+  sortIncomingProcess(process);
+
+  // Veto in case the hard input matrix element already has too many partons.
+  if ( !doFxFx && int(typeIdx[0].size()) > nJetMax )
+    return true;
+  if ( doFxFx && npNLO() < nJetMax && int(typeIdx[0].size()) > nJetMax )
+    return true;
+
+  // Done
+  return false;
+
+}
+
+//--------------------------------------------------------------------------
+
+inline bool JetMatchingMadgraph::doVetoStep(int iPos, int nISR, int nFSR,
+  const Event& event)  {
+
+  // Do not perform any veto if not in the Shower-kT scheme.
+  if ( !doShowerKt ) return false;
+
+  // Do nothing for emissions after the first one.
+  if ( nISR + nFSR > 1 ) return false;
+
+  // Do nothing in resonance decay showers.
+  if (iPos == 5) return false;
+
+  // Clear the event of MPI systems and resonace decay products. Store trimmed
+  // event in workEvent.
+  sortIncomingProcess(event);
+
+  // Get (kinematical) pT of first emission
+  double pTfirst = 0.;
+
+  // Get weak bosons, for later checks if the emission is a "QCD emission".
+  vector<int> weakBosons;
+  for (int i = 0; i < event.size(); i++) {
+    if ( event[i].id() == 22
+      && event[i].id() == 23
+      && event[i].idAbs() == 24)
+      weakBosons.push_back(i);
+  }
+
+  for (int i =  workEvent.size()-1; i > 0; --i) {
+    if ( workEvent[i].isFinal() && workEvent[i].colType() != 0
+      && (workEvent[i].statusAbs() == 43 || workEvent[i].statusAbs() == 51)) {
+      // Check if any of the EW bosons are ancestors of this parton. This
+      // should never happen for the first non-resonance shower emission.
+      // Check just to be sure.
+      bool QCDemission = true;
+      // Get position of this parton in the actual event (workEvent does
+      // not contain right mother-daughter relations). Stored in daughters.
+      int iPosOld = workEvent[i].daughter1();
+      for (int j = 0; i < int(weakBosons.size()); ++i)
+        if ( event[iPosOld].isAncestor(j)) {
+          QCDemission = false;
+          break;
+        }
+      // Done for a QCD emission.
+      if (QCDemission){
+        pTfirst = workEvent[i].pT();
+        break;
+      }
+    }
+  }
+
+  // Check veto.
+  if ( doShowerKtVeto(pTfirst) ) return true;
+
+  // No veto if come this far.
+  return false;
+
+}
+
+//--------------------------------------------------------------------------
+
+inline bool JetMatchingMadgraph::doShowerKtVeto(double pTfirst) {
+
+  // Only check veto in the shower-kT scheme.
+  if ( !doShowerKt ) return false;
+
+  // Reset veto code
+  bool doVeto = false;
+
+  // Find the (kinematical) pT of the softest (light) parton in the hard
+  // process.
+  int nParton = typeIdx[0].size();
+  double pTminME=1e10;
+  for ( int i = 0; i < nParton; ++i)
+    pTminME = min(pTminME,eventProcess[typeIdx[0][i]].pT());
+
+  // Veto if the softest hard process parton is below Qcut.
+  if ( nParton > 0 && pow(pTminME,2) < qCutSq ) doVeto = true;
+
+  // For non-highest multiplicity, veto if the hardest emission is harder
+  // than Qcut.
+  if ( exclusive && pow(pTfirst,2) > qCutSq ) {
+    doVeto = true;
+  // For highest multiplicity sample, veto if the hardest emission is harder
+  // than the hard process parton.
+  } else if ( !exclusive && nParton > 0 && pTfirst > pTminME ) {
+    doVeto = true;
+  }
+
+  // Return veto
+  return doVeto;
+
+}
+
+//--------------------------------------------------------------------------
+
+// Function to set the jet clustering scales (to be used as output)
+
+inline void JetMatchingMadgraph::SetDJR( const Event& event) {
+
+ // Clear members.
+ ClearDJR();
+ vector<double> result;
+
+  // Initialize SlowJetDJR jet algorithm with event
+  if (!slowJetDJR->setup(event) ) {
+    infoPtr->errorMsg("Warning in JetMatchingMadgraph:iGetDJR"
+      ": the SlowJet algorithm failed on setup");
+    return;
+  }
+
+  // Cluster in steps to find all hadronic jets
+  while ( slowJetDJR->sizeAll() - slowJetDJR->sizeJet() > 0 ) {
+    // Save the next clustering scale.
+    result.push_back(sqrt(slowJetDJR->dNext()));
+    // Perform step.
+    slowJetDJR->doStep();
+  }
+
+  // Save clustering scales in reserve order.
+  for (int i=int(result.size())-1; i > 0; --i)
+    DJR.push_back(result[i]);
+
+}
+
+//--------------------------------------------------------------------------
+
+// Function to get the current number of partons in the Born state, as
+// read from LHE.
+
+inline int JetMatchingMadgraph::npNLO(){
+  string npIn = infoPtr->getEventAttribute("npNLO",true);
+  int np = (npIn != "") ? atoi((char*)npIn.c_str()) : -1;
+  if ( np < 0 ) { ; }
+  else return np;
+  return nPartonsNow;
+}
+
+//--------------------------------------------------------------------------
+
+// Step (1): sort the incoming particles
+
+inline void JetMatchingMadgraph::sortIncomingProcess(const Event &event) {
+
+  // Remove resonance decays from original process and keep only final
+  // state. Resonances will have positive status code after this step.
+  omitResonanceDecays(eventProcessOrig, true);
+  ClearDJR();
+  clear_nMEpartons();
+
+  // For FxFx, pre-cluster partons in the event into jets.
+  if (doFxFx) {
+
+    // Get final state partons
+    eventProcess.clear();
+    workEventJet.clear();
+    for( int i=0; i < workEvent.size(); ++i) {
+      // Original AG+Py6 algorithm explicitly excludes tops,
+      // leptons and photons.
+      int id = workEvent[i].idAbs();
+      if ((id >= ID_LEPMIN && id <= ID_LEPMAX) || id == ID_TOP
+        || id == ID_PHOTON || id == 23 || id == 24 || id == 25) {
+        eventProcess.append(workEvent[i]);
+      } else {
+        workEventJet.append(workEvent[i]);
+      }
+    }
+
+    // Initialize SlowJetHard jet algorithm with current working event
+    if (!slowJetHard->setup(workEventJet) ) {
+      infoPtr->errorMsg("Warning in JetMatchingMadgraph:sortIncomingProcess"
+        ": the SlowJet algorithm failed on setup");
+      return;
+    }
+
+    // Get matrix element cut scale.
+    double localQcutSq = qCutMESq;
+    // Cluster in steps to find all hadronic jets at the scale qCutME
+    while ( slowJetHard->sizeAll() - slowJetHard->sizeJet() > 0 ) {
+      // Done if next step is above qCut
+      if( slowJetHard->dNext() > localQcutSq ) break;
+      // Done if we're at or below the number of partons in the Born state.
+      if( slowJetHard->sizeAll()-slowJetHard->sizeJet() <= npNLO()) break;
+      slowJetHard->doStep();
+    }
+
+    // Construct a master copy of the event containing only the
+    // hardest nPartonsNow hadronic clusters. While constructing the event,
+    // the parton type (ID_GLUON) and status (98,99) are arbitrary.
+    int nJets = slowJetHard->sizeJet();
+    int nClus = slowJetHard->sizeAll();
+    int nNow = 0;
+    for (int i = nJets; i < nClus; ++i) {
+      vector<int> parts;
+      if (i < nClus-nJets) parts = slowJetHard->clusConstituents(i);
+      else parts = slowJetHard->constituents(nClus-nJets-i);
+      int flavour = ID_GLUON;
+      for(int j=0; j < int(parts.size()); ++j)
+        if (workEventJet[parts[j]].id() == ID_BOT)
+          flavour = ID_BOT;
+      eventProcess.append( flavour, 98,
+        workEventJet[parts.back()].mother1(),
+        workEventJet[parts.back()].mother2(),
+        workEventJet[parts.back()].daughter1(),
+        workEventJet[parts.back()].daughter2(),
+        0, 0, slowJetHard->p(i).px(), slowJetHard->p(i).py(),
+        slowJetHard->p(i).pz(), slowJetHard->p(i).e() );
+      nNow++;
+    }
+
+    // Done. Clean-up
+    workEventJet.clear();
+
+  // For MLM matching, simply take hard process state from workEvent,
+  // without any preclustering.
+  } else {
+    eventProcess = workEvent;
+  }
+
+  // Sort original process final state into light/heavy jets and 'other'.
+  // Criteria:
+  //   1 <= ID <= nQmatch, or ID == 21         --> light jet (typeIdx[0])
+  //   nQMatch < ID                            --> heavy jet (typeIdx[1])
+  //   All else                                --> other     (typeIdx[2])
+  // Note that 'typeIdx' stores indices into 'eventProcess' (after resonance
+  // decays are omitted), while 'typeSet' stores indices into the original
+  // process record, 'eventProcessOrig', but these indices are also valid
+  // in 'event'.
+  for (int i = 0; i < 3; i++) {
+    typeIdx[i].clear();
+    typeSet[i].clear();
+    origTypeIdx[i].clear();
+  }
+  for (int i = 0; i < eventProcess.size(); i++) {
+    // Ignore non-final state and default to 'other'
+    if (!eventProcess[i].isFinal()) continue;
+    int idx = 2;
+    int orig_idx = 2;
+
+    // Light jets: all gluons and quarks with id less than or equal to nQmatch
+    if (eventProcess[i].id() == ID_GLUON
+      || (eventProcess[i].idAbs() <= nQmatch) ) {
+      orig_idx = 0;
+      // Crucial point: MG puts the scale of a non-QCD particle to eCM. For
+      // such particles, we should keep the default "2"
+      if ( eventProcess[i].scale() < 1.999*sqrt(infoPtr->eA()*infoPtr->eB()) )
+        idx = 0;
+    }
+
+    // Heavy jets:  all quarks with id greater than nQmatch
+    else if (eventProcess[i].idAbs() > nQmatch
+      && eventProcess[i].idAbs() <= ID_TOP) {
+      idx = 1;
+      orig_idx = 1;
+
+    } else {
+      idx = 2;
+      orig_idx = 2;
+    }
+
+    // Store
+    typeIdx[idx].push_back(i);
+    typeSet[idx].insert(eventProcess[i].daughter1());
+    origTypeIdx[orig_idx].push_back(i);
+  }
+
+  // Exclusive mode; if set to 2, then set based on nJet/nJetMax
+  if (exclusiveMode == 2) {
+
+    // Inclusive if nJet == nJetMax, exclusive otherwise
+    int nParton = origTypeIdx[0].size();
+    exclusive = (nParton == nJetMax) ? false : true;
+
+  // Otherwise, just set as given
+  } else {
+    exclusive = (exclusiveMode == 0) ? false : true;
+  }
+
+  // Extract partons from hardest subsystem + ISR + FSR only into
+  // workEvent. Note no resonance showers or MPIs.
+  subEvent(event);
+}
+
+//--------------------------------------------------------------------------
+
+// Step (2a): pick which particles to pass to the jet algorithm
+
+inline void JetMatchingMadgraph::jetAlgorithmInput(const Event &event,
+  int iType) {
+
+  // Take input from 'workEvent' and put output in 'workEventJet'
+  workEventJet = workEvent;
+
+  // Loop over particles and decide what to pass to the jet algorithm
+  for (int i = 0; i < workEventJet.size(); ++i) {
+    if (!workEventJet[i].isFinal()) continue;
+
+    // jetAllow option to disallow certain particle types
+    if (jetAllow == 1) {
+
+      // Original AG+Py6 algorithm explicitly excludes tops,
+      // leptons and photons.
+      int id = workEventJet[i].idAbs();
+      if ((id >= ID_LEPMIN && id <= ID_LEPMAX) || id == ID_TOP
+      || id == ID_PHOTON || (id > nQmatch && id!=21)) {
+        workEventJet[i].statusNeg();
+        continue;
+      }
+    }
+
+    // Get the index of this particle in original event
+    int idx = workEventJet[i].daughter1();
+
+    // Start with particle idx, and afterwards track mothers
+    while (true) {
+
+      // Light jets
+      if (iType == 0) {
+
+        // Do not include if originates from heavy jet or 'other'
+        if (typeSet[1].find(idx) != typeSet[1].end() ||
+            typeSet[2].find(idx) != typeSet[2].end()) {
+          workEventJet[i].statusNeg();
+          break;
+        }
+
+        // Made it to start of event record so done
+        if (idx == 0) break;
+        // Otherwise next mother and continue
+        idx = event[idx].mother1();
+
+      // Heavy jets
+      } else if (iType == 1) {
+
+        // Only include if originates from heavy jet
+        if (typeSet[1].find(idx) != typeSet[1].end()) break;
+
+        // Made it to start of event record with no heavy jet mother,
+        // so DO NOT include particle
+        if (idx == 0) {
+          workEventJet[i].statusNeg();
+          break;
+        }
+
+        // Otherwise next mother and continue
+        idx = event[idx].mother1();
+
+      } // if (iType)
+    } // while (true)
+  } // for (i)
+}
+
+//--------------------------------------------------------------------------
+
+// Step (2b): run jet algorithm and provide common output
+// This does nothing, because the jet algorithm is run several times
+//  in the matching algorithm.
+
+inline void JetMatchingMadgraph::runJetAlgorithm() {; }
+
+//--------------------------------------------------------------------------
+
+// Step (2c): veto decision (returning true vetoes the event)
+
+inline bool JetMatchingMadgraph::matchPartonsToJets(int iType) {
+
+  // Use two different routines for light/heavy jets as
+  // different veto conditions and for clarity
+  if (iType == 0) {
+    // Record the jet separations here, also if matchPartonsToJetsLight
+    // returns preemptively.
+    SetDJR(workEventJet);
+    set_nMEpartons(origTypeIdx[0].size(), typeIdx[0].size());
+    // Perform jet matching.
+    return (matchPartonsToJetsLight() > 0);
+  } else return (matchPartonsToJetsHeavy() > 0);
+}
+
+//--------------------------------------------------------------------------
+
+// Step(2c): light jets
+// Return codes are given indicating the reason for a veto.
+// Although not currently used, they are a useful debugging tool:
+//   0 = no veto
+//   1 = veto as number of jets less than number of partons
+//   2 = veto as exclusive mode and number of jets greater than
+//       number of partons
+//   3 = veto as inclusive mode and there would be an extra jet
+//       that is harder than any matched soft jet
+//   4 = veto as there is a parton which does not match a jet
+
+inline int JetMatchingMadgraph::matchPartonsToJetsLight() {
+
+  // Count the number of hard partons
+  int nParton = typeIdx[0].size();
+
+  // Initialize SlowJet with current working event
+  if (!slowJet->setup(workEventJet) ) {
+    infoPtr->errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
+      "Light: the SlowJet algorithm failed on setup");
+    return NONE;
+  }
+  double localQcutSq = qCutSq;
+  double dOld = 0.0;
+  // Cluster in steps to find all hadronic jets at the scale qCut
+  while ( slowJet->sizeAll() - slowJet->sizeJet() > 0 ) {
+    if( slowJet->dNext() > localQcutSq ) break;
+    dOld = slowJet->dNext();
+    slowJet->doStep();
+  }
+  int nJets = slowJet->sizeJet();
+  int nClus = slowJet->sizeAll();
+
+  // Debug printout.
+  if (MATCHINGDEBUG) slowJet->list(true);
+
+  // Count of the number of hadronic jets in SlowJet accounting
+  int nCLjets = nClus - nJets;
+  // Get number of partons. Different for MLM and FxFx schemes.
+  int nRequested = (doFxFx) ? npNLO() : nParton;
+
+  // Veto event if too few hadronic jets
+  if ( nCLjets < nRequested ) return LESS_JETS;
+
+  // In exclusive mode, do not allow more hadronic jets than partons
+  if ( exclusive && !doFxFx ) {
+    if ( nCLjets > nRequested ) return MORE_JETS;
+  } else {
+
+    // For FxFx, in the non-highest multipicity, all jets need to matched to
+    // partons. For nCLjets > nRequested, this is not possible. Hence, we can
+    // veto here already.
+    if ( doFxFx && nRequested < nJetMax && nCLjets > nRequested )
+      return MORE_JETS;
+
+    // Now continue in inclusive mode.
+    // In inclusive mode, there can be more hadronic jets than partons,
+    // provided that all partons are properly matched to hadronic jets.
+    // Start by setting up the jet algorithm.
+    if (!slowJet->setup(workEventJet) ) {
+      infoPtr->errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
+        "Light: the SlowJet algorithm failed on setup");
+      return NONE;
+    }
+
+    // For FxFx, continue clustering as long as the jet separation is above
+    // qCut.
+    if (doFxFx) {
+      while ( slowJet->sizeAll() - slowJet->sizeJet() > 0 ) {
+        if( slowJet->dNext() > localQcutSq ) break;
+        slowJet->doStep();
+      }
+    // For MLM, cluster into hadronic jets until there are the same number as
+    // partons.
+    } else {
+      while ( slowJet->sizeAll() - slowJet->sizeJet() > nParton )
+        slowJet->doStep();
+    }
+
+    // Sort partons in pT.  Update local qCut value.
+    //  Hadronic jets are already sorted in pT.
+    localQcutSq = dOld;
+    if ( clFact >= 0. && nParton > 0 ) {
+       vector<double> partonPt;
+       for (int i = 0; i < nParton; ++i)
+         partonPt.push_back( eventProcess[typeIdx[0][i]].pT2() );
+       sort( partonPt.begin(), partonPt.end());
+       localQcutSq = max( qCutSq, partonPt[0]);
+    }
+    nJets = slowJet->sizeJet();
+    nClus = slowJet->sizeAll();
+  }
+  // Update scale if clustering factor is non-zero
+  if ( clFact != 0. ) localQcutSq *= pow2(clFact);
+
+  Event tempEvent;
+  tempEvent.init( "(tempEvent)", particleDataPtr);
+  int nPass = 0;
+  double pTminEstimate = -1.;
+  // Construct a master copy of the event containing only the
+  // hardest nParton hadronic clusters. While constructing the event,
+  // the parton type (ID_GLUON) and status (98,99) are arbitrary.
+  for (int i = nJets; i < nClus; ++i) {
+    tempEvent.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0, slowJet->p(i).px(),
+      slowJet->p(i).py(), slowJet->p(i).pz(), slowJet->p(i).e() );
+    ++nPass;
+    pTminEstimate = max( pTminEstimate, slowJet->pT(i));
+    if(nPass == nRequested) break;
+  }
+
+  int tempSize = tempEvent.size();
+  // This keeps track of which hadronic jets are matched to parton
+  vector<bool> jetAssigned;
+  jetAssigned.assign( tempSize, false);
+
+  // This keeps track of which partons are matched to which hadronic
+  // jets.
+  vector< vector<bool> > partonMatchesJet;
+  for (int i=0; i < nParton; ++i )
+    partonMatchesJet.push_back( vector<bool>(tempEvent.size(),false) );
+
+  // Begin matching.
+  // Do jet matching for FxFx.
+  // Make sure that the nPartonsNow hardest hadronic jets are matched to any
+  // of the nPartonsNow (+1) partons. This matching is done by attaching a jet
+  // from the list of unmatched hadronic jets, and appending a jet from the
+  // list of partonic jets, one at a time. The partonic jet will be clustered
+  // with the hadronic jet or the beam if the distance measure is below the
+  // cut. The hadronic jet is matched once this happens. Otherwise, another
+  // partonic jet is tried. When a hadronic jet is matched to a partonic jet,
+  // it is removed from the list of unmatched hadronic jets. This process
+  // continues until the nPartonsNow hardest hadronic jets are matched to
+  // partonic jets, or it is not possible to make a match for a hadronic jet.
+  int iNow = 0;
+  int nMatched = 0;
+  while ( doFxFx && iNow < tempSize ) {
+
+    // Check if this shower jet matches any partonic jet.
+    Event tempEventJet;
+    tempEventJet.init("(tempEventJet)", particleDataPtr);
+    for (int i=0; i < nParton; ++i ) {
+
+      //// Only assign a parton once.
+      //for (int j=0; j < tempSize; ++j )
+      //  if ( partonMatchesJet[i][j]) continue;
+
+      // Attach a single hadronic jet.
+      tempEventJet.clear();
+      tempEventJet.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0,
+        tempEvent[iNow].px(), tempEvent[iNow].py(),
+        tempEvent[iNow].pz(), tempEvent[iNow].e() );
+      // Attach the current parton.
+      Vec4 pIn = eventProcess[typeIdx[0][i]].p();
+      tempEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0,
+        pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
+
+      // Setup jet algorithm.
+      if ( !slowJet->setup(tempEventJet) ) {
+        infoPtr->errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
+          "Light: the SlowJet algorithm failed on setup");
+        return NONE;
+      }
+
+      // These are the conditions for the hadronic jet to match the parton
+      //  at the local qCut scale
+      if ( slowJet->iNext() == tempEventJet.size() - 1
+        && slowJet->jNext() > -1 && slowJet->dNext() < localQcutSq ) {
+        jetAssigned[iNow] = true;
+        partonMatchesJet[i][iNow] = true;
+      }
+
+    } // End loop over hard partons.
+
+    // Veto if the jet could not be assigned to any parton.
+    if ( jetAssigned[iNow] ) nMatched++;
+
+    // Continue;
+    ++iNow;
+  }
+
+  // Jet matching veto for FxFx
+  if (doFxFx) {
+    if ( nRequested <  nJetMax && nMatched != nRequested )
+      return UNMATCHED_PARTON;
+    if ( nRequested == nJetMax && nMatched <  nRequested )
+      return UNMATCHED_PARTON;
+  }
+
+  // Do jet matching for MLM.
+  // Take the list of unmatched hadronic jets and append a parton, one at
+  // a time. The parton will be clustered with the "closest" hadronic jet
+  // or the beam if the distance measure is below the cut. When a hadronic
+  // jet is matched to a parton, it is removed from the list of unmatched
+  // hadronic jets. This process continues until all hadronic jets are
+  // matched to partons or it is not possible to make a match.
+  iNow = 0;
+  while (!doFxFx && iNow < nParton ) {
+    Event tempEventJet;
+    tempEventJet.init("(tempEventJet)", particleDataPtr);
+    for (int i = 0; i < tempSize; ++i) {
+      if (jetAssigned[i]) continue;
+      Vec4 pIn = tempEvent[i].p();
+      // Append unmatched hadronic jets
+      tempEventJet.append( ID_GLUON, 98, 0, 0, 0, 0, 0, 0,
+        pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
+    }
+
+    Vec4 pIn = eventProcess[typeIdx[0][iNow]].p();
+    // Append the current parton
+    tempEventJet.append( ID_GLUON, 99, 0, 0, 0, 0, 0, 0,
+      pIn.px(), pIn.py(), pIn.pz(), pIn.e() );
+    if ( !slowJet->setup(tempEventJet) ) {
+      infoPtr->errorMsg("Warning in JetMatchingMadgraph:matchPartonsToJets"
+        "Light: the SlowJet algorithm failed on setup");
+      return NONE;
+    }
+    // These are the conditions for the hadronic jet to match the parton
+    //  at the local qCut scale
+    if ( slowJet->iNext() == tempEventJet.size() - 1
+      && slowJet->jNext() > -1 && slowJet->dNext() < localQcutSq ) {
+      int iKnt = -1;
+      for (int i = 0; i != tempSize; ++i) {
+        if (jetAssigned[i]) continue;
+        ++iKnt;
+        // Identify the hadronic jet that matches the parton
+        if (iKnt == slowJet->jNext() ) jetAssigned[i] = true;
+      }
+    } else {
+      return UNMATCHED_PARTON;
+    }
+    ++iNow;
+  }
+
+  // Minimal eT/pT (CellJet/SlowJet) of matched light jets.
+  // Needed later for heavy jet vetos in inclusive mode.
+  // This information is not used currently.
+  if (nParton > 0 && pTminEstimate > 0) eTpTlightMin = pTminEstimate;
+  else eTpTlightMin = -1.;
+
+  // Record the jet separations.
+  SetDJR(workEventJet);
+
+  // No veto
+  return NONE;
+}
+
+//--------------------------------------------------------------------------
+
+// Step(2c): heavy jets
+// Return codes are given indicating the reason for a veto.
+// Although not currently used, they are a useful debugging tool:
+//   0 = no veto as there are no extra jets present
+//   1 = veto as in exclusive mode and extra jets present
+//   2 = veto as in inclusive mode and extra jets were harder
+//       than any matched light jet
+
+inline int JetMatchingMadgraph::matchPartonsToJetsHeavy() {
+
+  // Currently, heavy jets are unmatched
+  // If there are no extra jets, then accept
+  if (jetMomenta.empty()) return NONE;
+
+  // No extra jets were present so no veto
+  return NONE;
+}
+
+
+} // end namespace Pythia8
+
diff -rupN pythia_8.212_original/src/ParticleData.cc pythia_8.212_patched_nohepmc/src/ParticleData.cc
--- pythia_8.212_original/src/ParticleData.cc	2015-09-23 17:35:08.000000000 +0200
+++ pythia_8.212_patched_nohepmc/src/ParticleData.cc	2020-09-09 20:16:05.260382498 +0200
@@ -572,6 +572,8 @@ void ParticleData::initCommon() {
 
 void ParticleData::initWidths( vector<ResonanceWidths*> resonancePtrs) {
 
+  cout<<" initialising widths with size "<<resonancePtrs.size()<<" pdt size "<<pdt.size()<<endl;
+  
   // Initialize some common data.
   initCommon();
 
@@ -776,8 +778,44 @@ void ParticleData::initWidths( vector<Re
 
 bool ParticleData::readXML(string inFile, bool reset) {
 
+  // Load XML file into memory
+  if (!loadXML(inFile,reset)) return false;
+
+  // Process XML file (now stored in memory)
+  if (!processXML(reset)) return false;
+
+  // Done.
+  return true;
+}
+
+  //--------------------------------------------------------------------------
+
+// Read in database from pre-initialised particleData object.
+
+bool ParticleData::copyXML(const ParticleData &particleDataIn) {
+
+  // First Reset everything.
+  pdt.clear();
+  xmlFileSav.clear();
+  isInit = false;
+  xmlFileSav=particleDataIn.xmlFileSav;
+
+  // Process XML file (now stored in memory)
+  if (!processXML(true)) return false;
+
+  // Done.
+  return true;
+}
+  
+  
+//--------------------------------------------------------------------------
+
+// Load a specific XML file into memory (which may refer to others).
+
+bool ParticleData::loadXML(string inFile, bool reset) {
+
   // Normally reset whole database before beginning.
-  if (reset) {pdt.clear(); isInit = false;}
+  if (reset) {pdt.clear(); xmlFileSav.clear(); isInit = false;}
 
   // List of files to be checked.
   vector<string> files;
@@ -805,73 +843,8 @@ bool ParticleData::readXML(string inFile
       string word1;
       getfirst >> word1;
 
-      // Check for occurence of a particle. Add any continuation lines.
-      if (word1 == "<particle") {
-        while (line.find(">") == string::npos) {
-          string addLine;
-          getline(is, addLine);
-          line += addLine;
-        }
-
-        // Read in particle properties.
-        int idTmp          = intAttributeValue( line, "id");
-        string nameTmp     = attributeValue( line, "name");
-        string antiNameTmp = attributeValue( line, "antiName");
-        if (antiNameTmp == "") antiNameTmp = "void";
-        int spinTypeTmp    = intAttributeValue( line, "spinType");
-        int chargeTypeTmp  = intAttributeValue( line, "chargeType");
-        int colTypeTmp     = intAttributeValue( line, "colType");
-        double m0Tmp       = doubleAttributeValue( line, "m0");
-        double mWidthTmp   = doubleAttributeValue( line, "mWidth");
-        double mMinTmp     = doubleAttributeValue( line, "mMin");
-        double mMaxTmp     = doubleAttributeValue( line, "mMax");
-        double tau0Tmp     = doubleAttributeValue( line, "tau0");
-
-        // Erase if particle already exists.
-        if (isParticle(idTmp)) pdt.erase(idTmp);
-
-        // Store new particle. Save pointer, to be used for decay channels.
-        addParticle( idTmp, nameTmp, antiNameTmp, spinTypeTmp, chargeTypeTmp,
-          colTypeTmp, m0Tmp, mWidthTmp, mMinTmp, mMaxTmp, tau0Tmp);
-        particlePtr = particleDataEntryPtr(idTmp);
-
-      // Check for occurence of a decay channel. Add any continuation lines.
-      } else if (word1 == "<channel") {
-        while (line.find(">") == string::npos) {
-          string addLine;
-          getline(is, addLine);
-          line += addLine;
-        }
-
-        // Read in channel properties - products so far only as a string.
-        int onMode      = intAttributeValue( line, "onMode");
-        double bRatio   = doubleAttributeValue( line, "bRatio");
-        int meMode      = intAttributeValue( line, "meMode");
-        string products = attributeValue( line, "products");
-
-        // Read in decay products from stream. Must have at least one.
-        istringstream prodStream(products);
-        int prod0 = 0; int prod1 = 0; int prod2 = 0; int prod3 = 0;
-        int prod4 = 0; int prod5 = 0; int prod6 = 0; int prod7 = 0;
-        prodStream >> prod0 >> prod1 >> prod2 >> prod3 >> prod4 >> prod5
-                   >> prod6 >> prod7;
-        if (prod0 == 0) {
-          infoPtr->errorMsg("Error in ParticleData::readXML:"
-            " incomplete decay channel", line);
-          return false;
-        }
-
-        // Store new channel (if particle already known).
-        if (particlePtr == 0) {
-          infoPtr->errorMsg("Error in ParticleData::readXML:"
-            " orphan decay channel", line);
-          return false;
-        }
-        particlePtr->addChannel(onMode, bRatio, meMode, prod0, prod1,
-          prod2, prod3, prod4, prod5, prod6, prod7);
-
       // Check for occurence of a file also to be read.
-      } else if (word1 == "<file") {
+      if (word1 == "<file") {
         string file = attributeValue(line, "name");
         if (file == "") {
           infoPtr->errorMsg("Error in ParticleData::readXML:"
@@ -879,7 +852,106 @@ bool ParticleData::readXML(string inFile
         } else files.push_back(file);
       }
 
-    // End of loop over lines in input file and loop over files.
+      // Else save line to memory
+      else {
+        xmlFileSav.push_back(line);
+      }
+    }
+  }
+
+  //Done.
+  return true;
+  
+}
+
+//--------------------------------------------------------------------------
+
+// Process XML contents stored in memory
+
+bool ParticleData::processXML(bool reset) {
+
+  // Number of lines saved
+  int nLines = xmlFileSav.size();
+
+  // Process each line sequentially
+  particlePtr = 0;
+  int i=-1;
+  while (++i < nLines) {
+    
+    // Retrieve line
+    string line = xmlFileSav[i];
+
+    // Get first word of a line.
+    istringstream getfirst(line);
+    string word1;
+    getfirst >> word1;
+
+    // Check for occurence of a particle. Add any continuation lines.
+    if (word1 == "<particle") {
+      while (line.find(">") == string::npos) {
+        if (++i >= nLines) break;
+        string addLine = xmlFileSav[i];        
+        line += addLine;
+      }
+      
+      // Read in particle properties.
+      int idTmp          = intAttributeValue( line, "id");
+      string nameTmp     = attributeValue( line, "name");
+      string antiNameTmp = attributeValue( line, "antiName");
+      if (antiNameTmp == "") antiNameTmp = "void";
+      int spinTypeTmp    = intAttributeValue( line, "spinType");
+      int chargeTypeTmp  = intAttributeValue( line, "chargeType");
+      int colTypeTmp     = intAttributeValue( line, "colType");
+      double m0Tmp       = doubleAttributeValue( line, "m0");
+      double mWidthTmp   = doubleAttributeValue( line, "mWidth");
+      double mMinTmp     = doubleAttributeValue( line, "mMin");
+      double mMaxTmp     = doubleAttributeValue( line, "mMax");
+      double tau0Tmp     = doubleAttributeValue( line, "tau0");
+      
+      // Erase if particle already exists.
+      if (isParticle(idTmp)) pdt.erase(idTmp);
+      
+      // Store new particle. Save pointer, to be used for decay channels.
+      addParticle( idTmp, nameTmp, antiNameTmp, spinTypeTmp, chargeTypeTmp,
+                   colTypeTmp, m0Tmp, mWidthTmp, mMinTmp, mMaxTmp, tau0Tmp);
+      particlePtr = particleDataEntryPtr(idTmp);
+      
+      // Check for occurence of a decay channel. Add any continuation lines.
+    } else if (word1 == "<channel") {
+      while (line.find(">") == string::npos) {
+        if (++i >= nLines) break;        
+        string addLine = xmlFileSav[i];
+        line += addLine;
+      }
+      
+      // Read in channel properties - products so far only as a string.
+      int onMode      = intAttributeValue( line, "onMode");
+      double bRatio   = doubleAttributeValue( line, "bRatio");
+      int meMode      = intAttributeValue( line, "meMode");
+      string products = attributeValue( line, "products");
+      
+      // Read in decay products from stream. Must have at least one.
+      istringstream prodStream(products);
+      int prod0 = 0; int prod1 = 0; int prod2 = 0; int prod3 = 0;
+      int prod4 = 0; int prod5 = 0; int prod6 = 0; int prod7 = 0;
+      prodStream >> prod0 >> prod1 >> prod2 >> prod3 >> prod4 >> prod5
+                 >> prod6 >> prod7;
+      if (prod0 == 0) {
+        infoPtr->errorMsg("Error in ParticleData::readXML:"
+                          " incomplete decay channel", line);
+        return false;
+      }
+
+      // Store new channel (if particle already known).
+      if (particlePtr == 0) {
+        infoPtr->errorMsg("Error in ParticleData::readXML:"
+                          " orphan decay channel", line);
+        return false;
+      }
+      particlePtr->addChannel(onMode, bRatio, meMode, prod0, prod1,
+                              prod2, prod3, prod4, prod5, prod6, prod7);
+      
+      // End of loop over lines in input file and loop over files.
     };
   };
 
diff -rupN pythia_8.212_original/src/PartonDistributions.cc pythia_8.212_patched_nohepmc/src/PartonDistributions.cc
--- pythia_8.212_original/src/PartonDistributions.cc	2015-09-23 17:35:08.000000000 +0200
+++ pythia_8.212_patched_nohepmc/src/PartonDistributions.cc	2020-09-09 20:16:05.260382498 +0200
@@ -2133,17 +2133,10 @@ void NNPDF::init(int iFitIn, string xmlP
   for (int iq = 0; iq < fNQ2; iq++) fLogQ2Grid[iq] = log(fQ2Grid[iq]);
 
   // Prepare grid array.
-  fPDFGrid = new double**[fNFL];
-  for (int i = 0; i < fNFL; i++) {
-    fPDFGrid[i] = new double*[fNX];
-    for (int j = 0; j < fNX; j++) {
-      fPDFGrid[i][j] = new double[fNQ2];
-      for (int z = 0; z < fNQ2; z++) fPDFGrid[i][j][z] = 0.0;
-    }
-  }
-
+    fPDFGrid = new double[fNFL*fNX*fNQ2];
+  
   // Check values of number of grid entries.
-  if (fNX<= 0 || fNX>100 || fNQ2<=0 || fNQ2>50) {
+  if (fNX<4 || fNX>100 || fNQ2<2 || fNQ2>50) {
     cout << "Error in NNPDF::init, Invalid grid values" << endl
          << "fNX = " << fNX << endl << "fNQ2 = " << fNQ2 << endl
          << "fNFL = " <<fNFL << endl;
@@ -2156,46 +2149,210 @@ void NNPDF::init(int iFitIn, string xmlP
   for (int ix = 0; ix < fNX; ix++)
     for (int iq = 0; iq < fNQ2; iq++)
       for (int fl = 0; fl < fNFL; fl++)
-        f >> fPDFGrid[fl][ix][iq];
+      {
+        f >> fPDFGrid[(fl*fNX + ix)*fNQ2 + iq];
+      }
   f.close();
 
   // Other vectors.
   fRes = new double[fNFL];
-
+  
 }
 
 //--------------------------------------------------------------------------
 
-void NNPDF::xfUpdate(int , double x, double Q2) {
+ void NNPDF::xfUpdate(int , double x, double Q2) {
+ 
+ // Update using NNPDF routine, within allowed (x, q) range.
+ xfxevolve(x,Q2);
+ 
+ // Then transfer to Pythia8 notation.
+ xg     = fRes[6];
+ xu     = fRes[8];
+ xd     = fRes[7];
+ xubar  = fRes[4];
+ xdbar  = fRes[5];
+ xs     = fRes[9];
+ xsbar  = fRes[3];
+ xc     = fRes[10];
+ xb     = fRes[11];
+ xgamma = fRes[13];
+ 
+ // Subdivision of valence and sea.
+ xuVal  = xu - xubar;
+ xuSea  = xubar;
+ xdVal  = xd - xdbar;
+ xdSea  = xdbar;
+ 
+ // idSav = 9 to indicate that all flavours reset.
+ idSav  = 9;
+ 
+ }
 
-  // Update using NNPDF routine, within allowed (x, q) range.
-  xfxevolve(x,Q2);
+ 
+//--------------------------------------------------------------------------
+/*
+ *  NNPDF::xfxevolve(double x, double Q2) optimized to improve performance by ~2x
+ *
+ *  Modified by Hrayr Matevosyan on 24/06/15.
+ *  2015 CSSM/CoEPP, University of Adelaide.
+ *
+ */
+void NNPDF::xfxevolve(double x, double Q2) {
 
-  // Then transfer to Pythia8 notation.
-  xg     = fRes[6];
-  xu     = fRes[8];
-  xd     = fRes[7];
-  xubar  = fRes[4];
-  xdbar  = fRes[5];
-  xs     = fRes[9];
-  xsbar  = fRes[3];
-  xc     = fRes[10];
-  xb     = fRes[11];
-  xgamma = fRes[13];
-
-  // Subdivision of valence and sea.
-  xuVal  = xu - xubar;
-  xuSea  = xubar;
-  xdVal  = xd - xdbar;
-  xdSea  = xdbar;
+  // Freeze outside x-Q2 grid.
+  if (x < fXMINGRID)
+    x = fXMINGRID;
+  else if (x > fXGrid[fNX-1])
+    x = fXGrid[fNX-1];
+  
+  if (Q2 < fQ2Grid[0])
+    Q2 = fQ2Grid[0];
+  else if (Q2 > fQ2Grid[fNQ2-1])
+    Q2 = fQ2Grid[fNQ2-1];
+  
+  // Find nearest points in the x-Q2 grid.
+  int min = 0;
+  int max = fNX-1;
+  int mid;
+  while (max-min > 1)
+  {
+    mid = (min+max)/2;
+    if (x < fXGrid[mid]) max = mid;
+    else min = mid;
+  };
+  
+  int ix1 = min-1; //ix-1
+  if (ix1 < 0)
+    ix1=0;
+  else if(ix1 > (fNX-4))
+    ix1 = (fNX-4);
+  
+  // Find nearest points in the Q2 grid.
+  min = 0;
+  max = fNQ2-1;
+  while (max-min > 1)
+  {
+    mid = (min+max)/2;
+    if (Q2 < fQ2Grid[mid]) max = mid;
+    else min = mid;
+  };
+    
+  int ix2 = min;
+  if (ix2 > (fNQ2-2))
+    ix2 = (fNQ2-2);
+ 
+  //x grid values used
+  double x1, *x1a;
+  if (x < static_cast<double>(1e-1))
+  {
+    x1 = log(x);
+    x1a = fLogXGrid + ix1;
+  }
+  else
+  {
+    x1 = x;
+    x1a = fXGrid + ix1;
+  }
+  
+  if(
+     (x1a[0] - x1a[1])*
+     (x1a[0] - x1a[2])*
+     (x1a[0] - x1a[3])*
+     (x1a[1] - x1a[2])*
+     (x1a[1] - x1a[3])*
+     (x1a[2] - x1a[3])
+      == 0
+     )
+  {
+    cout << "NNPDF::polint, failure" << endl;
+    return;
+  }
 
-  // idSav = 9 to indicate that all flavours reset.
-  idSav  = 9;
+  //Q2 grid values used
+  double x2 = log(Q2);
+  double* x2a = fLogQ2Grid+ix2;
+  if ( (x2a[0]-x2a[1]) == 0)
+  {
+    cout << "NNPDF::polint, failure" << endl;
+    return;
+  }
+  
+  //Interpolation Variables
+  int iShift= ( abs(x2-x2a[0]) < abs(x2-x2a[1]) ) ? 0 : 1;
+  
+  double denl = (x2a[iShift]-x2)/(x2a[0]-x2a[1]);
+
+  int ns0 =0;
+  double dif = abs(x1-x1a[0]);
+  for (int i = 1; i < 4; i++)
+  {
+    double dift = abs(x1-x1a[i]);
+    if (dift < dif)
+    {
+      ns0 = i;
+      dif = dift;
+    }
+  }
 
+  //Loop over flavor index
+  for (int ipdf = 0; ipdf < fNFL; ipdf++)
+  {
+    //
+    //Interpolation in Q2
+    //
+    
+    double ym[4];
+    int iIndPDF = (ipdf*fNX + ix1)*fNQ2 + ix2;
+    ym[0] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    iIndPDF+=fNQ2;
+    ym[1] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    iIndPDF+=fNQ2;
+    ym[2] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    iIndPDF+=fNQ2;
+    ym[3] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    //
+    //Interpolation in x
+    //
+    double c[4]={ym[0],ym[1],ym[2],ym[3]};
+    
+    int ns = ns0;
+    double y = ym[ns];
+    ns--;
+    double den;
+    for (int m = 1; m < 4; m++)
+    {
+      for (int i = 0; i < 4-m; i++)
+      {
+        den = (c[i+1]-ym[i])/(x1a[i]-x1a[i+m]);
+        c[i]  = (x1a[i]   - x1) * den;
+        ym[i] = (x1a[i+m] - x1) * den;
+      }
+      if (2*ns < 2-m)
+      {
+        y+= c[ns+1];
+      }
+      else
+      {
+        y+= ym[ns];
+        ns--;
+      }
+    }
+ 
+    fRes[ipdf] = y;
+  }
 }
 
-//--------------------------------------------------------------------------
 
+//--------------------------------------------------------------------------
+/*
+ *  NNPDF::xfxevolve(double x, double Q2) original code v8209
+ */
+/*
 void NNPDF::xfxevolve(double x, double Q2) {
 
   // Freeze outside x-Q2 grid.
@@ -2278,6 +2435,7 @@ void NNPDF::xfxevolve(double x, double Q
   }
 
 }
+*/
 
 //--------------------------------------------------------------------------
 
diff -rupN pythia_8.212_original/src/ProcessLevel.cc pythia_8.212_patched_nohepmc/src/ProcessLevel.cc
--- pythia_8.212_original/src/ProcessLevel.cc	2015-09-23 17:35:08.000000000 +0200
+++ pythia_8.212_patched_nohepmc/src/ProcessLevel.cc	2020-09-09 20:16:05.260382498 +0200
@@ -6,6 +6,20 @@
 // Function definitions (not found in the header) for the ProcessLevel class.
 
 #include "Pythia8/ProcessLevel.h"
+// NOTE: Gambit hack to limit infinite loops using threadsafe timers.
+#ifndef BOOST_CHRONO_HEADER_ONLY
+#define BOOST_CHRONO_HEADER_ONLY
+#ifndef BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#define BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#ifndef BOOST_SYSTEM_NO_DEPRECATED
+#define BOOST_SYSTEM_NO_DEPRECATED
+#include <boost/chrono.hpp>
+typedef boost::chrono::milliseconds ms;
+typedef boost::chrono::thread_clock thread_cl;
+typedef boost::chrono::thread_clock::time_point thread_tp;
+#endif // BOOST_SYSTEM_NO_DEPRECATED
+#endif // BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#endif // BOOST_CHRONO_HEADER_ONLY
 
 namespace Pythia8 {
 
@@ -182,9 +196,28 @@ bool ProcessLevel::init( Info* infoPtrIn
       &resonanceDecays, slhaInterfacePtr, userHooksPtr)) ++numberOn;
 
   // Sum maxima for Monte Carlo choice.
+  // NOTE: Gambit hack: Catch nans and infinities while summing up sigmas.
   sigmaMaxSum = 0.;
-  for (int i = 0; i < int(containerPtrs.size()); ++i)
-    sigmaMaxSum += containerPtrs[i]->sigmaMax();
+  bool valid = true;
+  for (int i = 0; i < int(containerPtrs.size()); ++i) {
+    if(std::isfinite(containerPtrs[i]->sigmaMax()))
+      sigmaMaxSum += containerPtrs[i]->sigmaMax();
+    else {
+      std::cerr<<"\n\n\n ERROR: in Pythia8::ProcessLevel::init:\n";
+      std::cerr<<"   Non-finite xsec: "<<containerPtrs[i]->sigmaMax()<<"\n";
+      std::cerr<<"   Process code: "<<containerPtrs[i]->code();
+      std::cerr<<",  Process: "<<containerPtrs[i]->name()<<"\n";
+      std::cerr<<"This model is invalid.\n\n\n";
+      delete containerPtrs[i];
+      containerPtrs.erase(containerPtrs.begin() + i);
+      i--;
+      valid = false;
+    }
+  }
+  if (!valid) {
+    infoPtr->errorMsg("Error in ProcessLevel::init: Non-finite xsecs");
+    return false;
+  }
 
   // Option to pick a second hard interaction: repeat as above.
   int number2On = 0;
@@ -282,12 +315,14 @@ bool ProcessLevel::init( Info* infoPtrIn
        <<"-------------*" << endl;
   }
 
+  /* NOTE: Gambit hack: ColliderBit has its own xsec veto... remove this:
   // If sum of maxima vanishes then refuse to do anything.
   if ( numberOn == 0  || sigmaMaxSum <= 0.) {
     infoPtr->errorMsg("Error in ProcessLevel::init: "
       "all processes have vanishing cross sections");
     return false;
   }
+  *** Gambit hack end */
   if ( doSecondHard && (number2On == 0  || sigma2MaxSum <= 0.) ) {
     infoPtr->errorMsg("Error in ProcessLevel::init: "
       "all second hard processes have vanishing cross sections");
@@ -615,8 +650,15 @@ bool ProcessLevel::nextOne( Event& proce
     physical = true;
 
     // Loop over tries until trial event succeeds.
-    for ( ; ; ) {
-
+    // NOTE: Gambit hack to limit infinite loops using threadsafe timers.
+    // TODO: configurable msTimeLimit...
+    double msTimer=0.;
+    double msTimeLimit = 1000.;
+    ms msDelta;
+    for (thread_tp start = thread_cl::now(); msTimer < msTimeLimit;
+         msDelta = boost::chrono::duration_cast<ms>(thread_cl::now() - start),
+         msTimer = msDelta.count())
+    {
       // Pick one of the subprocesses.
       double sigmaMaxNow = sigmaMaxSum * rndmPtr->flat();
       int iMax = containerPtrs.size() - 1;
@@ -630,6 +672,11 @@ bool ProcessLevel::nextOne( Event& proce
       // Check for end-of-file condition for Les Houches events.
       if (infoPtr->atEndOfFile()) return false;
     }
+    if (msTimer >= msTimeLimit) {
+      std::cerr<<"\n\n\n WARNING: in Pythia8::ProcessLevel::next:\n";
+      std::cerr<<"   Trial event stuck. Aborting event generation\n\n\n";
+      return false;
+    }
 
     // Update sum of maxima if current maximum violated.
     if (containerPtrs[iContainer]->newSigmaMax()) {
diff -rupN pythia_8.212_original/src/Pythia.cc pythia_8.212_patched_nohepmc/src/Pythia.cc
--- pythia_8.212_original/src/Pythia.cc	2015-09-23 17:35:08.000000000 +0200
+++ pythia_8.212_patched_nohepmc/src/Pythia.cc	2020-09-09 20:16:05.260382498 +0200
@@ -113,7 +113,9 @@ Pythia::Pythia(string xmlDir, bool print
     info.errorMsg("Abort from Pythia::Pythia: settings unavailable");
     return;
   }
-
+  // Also save XML path in settings
+  settings.addWord("xmlPath",xmlPath);
+  
   // Check that XML version number matches code version number.
   double versionNumberXML = parm("Pythia:versionNumber");
   isConstructed = (abs(versionNumberXML - VERSIONNUMBERCODE) < 0.0005);
@@ -157,6 +159,112 @@ Pythia::Pythia(string xmlDir, bool print
 
 //--------------------------------------------------------------------------
 
+// Constructor from pre-initialised ParticleData and Settings objects.
+
+Pythia::Pythia(ParticleData& particleDataIn, Settings& settingsIn,
+                 bool printBanner) {
+
+  // Initial values for pointers to PDF's.
+  useNewPdfA      = false;
+  useNewPdfB      = false;
+  useNewPdfHard   = false;
+  useNewPdfPomA   = false;
+  useNewPdfPomB   = false;
+  pdfAPtr         = 0;
+  pdfBPtr         = 0;
+  pdfHardAPtr     = 0;
+  pdfHardBPtr     = 0;
+  pdfPomAPtr      = 0;
+  pdfPomBPtr      = 0;
+
+  // Initial values for pointers to Les Houches Event objects.
+  doLHA           = false;
+  useNewLHA       = false;
+  lhaUpPtr        = 0;
+
+  //Initial value for couplings pointer
+  couplingsPtr    = &couplings;
+
+  // Initial value for pointer to external decay handler.
+  decayHandlePtr  = 0;
+
+  // Initial value for pointer to user hooks.
+  userHooksPtr    = 0;
+
+  // Initial value for pointer to merging hooks.
+  doMerging          = false;
+  hasMergingHooks    = false;
+  hasOwnMergingHooks = false;
+  mergingHooksPtr    = 0;
+
+  // Initial value for pointer to beam shape.
+  useNewBeamShape = false;
+  beamShapePtr    = 0;
+
+  // Initial values for pointers to timelike and spacelike showers.
+  useNewTimesDec  = false;
+  useNewTimes     = false;
+  useNewSpace     = false;
+  timesDecPtr     = 0;
+  timesPtr        = 0;
+  spacePtr        = 0;
+
+  // Copy XML path
+  const string key = "xmlPath";
+  xmlPath = settingsIn.word(key);
+  
+  // Copy settings database
+  settings = settingsIn;
+  // Reset pointers to pertain to this PYTHIA object
+  settings.initPtr( &info);
+  isConstructed = settings.getIsInit();
+  if (!isConstructed) {
+    info.errorMsg("Abort from Pythia::Pythia: settings unavailable");
+    return;
+  }
+
+  // Check that XML version number matches code version number.
+  double versionNumberXML = parm("Pythia:versionNumber");
+  isConstructed = (abs(versionNumberXML - VERSIONNUMBERCODE) < 0.0005);
+  if (!isConstructed) {
+    ostringstream errCode;
+    errCode << fixed << setprecision(3) << ": in code " << VERSIONNUMBERCODE
+            << " but in XML " << versionNumberXML;
+    info.errorMsg("Abort from Pythia::Pythia: unmatched version numbers",
+      errCode.str());
+    return;
+  }
+
+  // Check that header version number matches code version number.
+  isConstructed = (abs(VERSIONNUMBERHEAD - VERSIONNUMBERCODE) < 0.0005);
+  if (!isConstructed) {
+    ostringstream errCode;
+    errCode << fixed << setprecision(3) << ": in code " << VERSIONNUMBERCODE
+            << " but in header " << VERSIONNUMBERHEAD;
+    info.errorMsg("Abort from Pythia::Pythia: unmatched version numbers",
+      errCode.str());
+    return;
+  }
+
+  // Read in files with all particle data.
+  particleData.initPtr( &info, &settings, &rndm, couplingsPtr);
+  isConstructed = particleData.init( particleDataIn);
+  if (!isConstructed) {
+    info.errorMsg("Abort from Pythia::Pythia: particle data unavailable");
+    return;
+  }
+
+  // Write the Pythia banner to output.
+  if (printBanner) banner();
+
+  // Not initialized until at the end of the init() call.
+  isInit = false;
+  info.addCounter(0);
+
+}
+
+//--------------------------------------------------------------------------
+  
 // Destructor.
 
 Pythia::~Pythia() {
@@ -338,7 +446,7 @@ bool Pythia::setPDFPtr( PDF* pdfAPtrIn,
 
 // Routine to initialize with the variable values of the Beams kind.
 
-bool Pythia::init() {
+bool Pythia::init(ostream& os) {  // NOTE: <== os is a Gambit hack
 
   // Check that constructor worked.
   isInit = false;
@@ -677,7 +785,7 @@ bool Pythia::init() {
   // Send info/pointers to process level for initialization.
   if ( doProcessLevel && !processLevel.init( &info, settings, &particleData,
     &rndm, &beamA, &beamB, couplingsPtr, &sigmaTot, doLHA, &slhaInterface,
-    userHooksPtr, sigmaPtrs, phaseSpacePtrs) ) {
+    userHooksPtr, sigmaPtrs, phaseSpacePtrs, os) ) {  // NOTE: <== os is a Gambit hack
     info.errorMsg("Abort from Pythia::init: "
       "processLevel initialization failed");
     return false;
@@ -1618,12 +1726,12 @@ void Pythia::banner(ostream& os) {
      << "ische Physik,                         |  | \n"
      << " |  |     Universitaet Heidelberg, Philosophe"
      << "nweg 16, D-69120 Heidelberg, Germany; |  | \n"
-     << " |  |      e-mail: n.desai@thphys.uni-heidelb"
+     << " |  |      e-mail: n.desai@thuni-heidelb"
      << "erg.de                                |  | \n"
      << " |  |   Philip Ilten;  Massachusetts Institut"
      << "e of Technology,                      |  | \n"
-     << " |  |      stationed at CERN, CH-1211 Geneva "
-     << "23, Switzerland;                      |  | \n"
+     << " |  |      77 Massachusetts Ave, Cambridge, M"
+     << "A 02139, USA;                         |  | \n"
      << " |  |      e-mail: philten@cern.ch           "
      << "                                      |  | \n"
      << " |  |   Stephen Mrenna;  Computing Division, "
diff -rupN pythia_8.212_original/src/ResonanceDecays.cc pythia_8.212_patched_nohepmc/src/ResonanceDecays.cc
--- pythia_8.212_original/src/ResonanceDecays.cc	2015-09-23 17:35:09.000000000 +0200
+++ pythia_8.212_patched_nohepmc/src/ResonanceDecays.cc	2020-09-09 20:16:05.260382498 +0200
@@ -92,6 +92,10 @@ bool ResonanceDecays::next( Event& proce
           idProd.push_back( idNow);
         }
 
+
+        // GAMBIT fix for Pythia bug. (To be fixed in Pythia versions > 8.212)
+        mProd.resize(1);
+
         // Pick masses. Pick new channel if fail.
         if (!pickMasses()) continue;
         foundChannel = true;
@@ -191,11 +195,15 @@ bool ResonanceDecays::pickMasses() {
     mSumMin     += mMinBW[i];
   }
 
-  // If sum of minimal masses above mother mass then give up.
-  if (mSumMin + MSAFETY > mMother) return false;
+  // GAMBIT modification to allow decays at small mass splittings:
+  // Switched order of the two next if-statements and changed
+  // 0.5*MSAFETY to 0.01*MSAFETY.
 
   // If sum of masses below and no Breit-Wigners then done.
-  if (mSum + 0.5 * MSAFETY < mMother && nBW == 0) return true;
+  if (mSum + 0.01 * MSAFETY < mMother && nBW == 0) return true;
+
+  // If sum of minimal masses above mother mass then give up.
+  if (mSumMin + MSAFETY > mMother) return false;
 
   // Else if below then retry Breit-Wigners, with simple treshold.
   if (mSum + MSAFETY < mMother) {
diff -rupN pythia_8.212_original/src/SusyLesHouches.cc pythia_8.212_patched_nohepmc/src/SusyLesHouches.cc
--- pythia_8.212_original/src/SusyLesHouches.cc	2015-09-23 17:35:10.000000000 +0200
+++ pythia_8.212_patched_nohepmc/src/SusyLesHouches.cc	2020-09-09 20:16:05.264382523 +0200
@@ -20,23 +20,34 @@ namespace Pythia8 {
 int SusyLesHouches::readFile(string slhaFileIn, int verboseIn,
   bool useDecayIn) {
 
-  slhaFile = slhaFileIn;
-  // Check that input file is OK.
-  const char* cstring = slhaFile.c_str();
-  igzstream file(cstring);
-
-  // Exit if input file not found. Else print file name.
-  if (!file.good()) {
-    message(2,"readFile",slhaFile+" not found",0);
-    return -1;
-    slhaRead=false;
-  }
-  if (verboseSav >= 3) {
-    message(0,"readFile","parsing "+slhaFile,0);
-    filePrinted = true;
-  }
+  // NOTE: Gambit hack for slhaea support:
+  // If the slhaeaCollPtr is set, get the SLHA content as a stringstream
+  // from that pointer and pass this to Pythia's readFile function.
+  if (slhaeaCollPtr) // GAMBIT hack
+  {
+    std::istringstream slhaea_content(slhaeaCollPtr->str());
+    return readFile( slhaea_content, verboseIn, useDecayIn );
+  }
+  else  // Pythia original
+  {
+    slhaFile = slhaFileIn;
+    // Check that input file is OK.
+    const char* cstring = slhaFile.c_str();
+    igzstream file(cstring);
+
+    // Exit if input file not found. Else print file name.
+    if (!file.good()) {
+      message(2,"readFile",slhaFile+" not found",0);
+      return -1;
+      slhaRead=false;
+    }
+    if (verboseSav >= 3) {
+      message(0,"readFile","parsing "+slhaFile,0);
+      filePrinted = true;
+    }
 
-  return readFile( file, verboseIn, useDecayIn );
+    return readFile( file, verboseIn, useDecayIn );
+  }
 }
 
 int SusyLesHouches::readFile(istream& is, int verboseIn,
@@ -635,7 +646,7 @@ int SusyLesHouches::readFile(istream& is
     return 102;
   }
   else return iFailFile;
-
+    
 }
 
 //--------------------------------------------------------------------------
@@ -679,6 +690,13 @@ void SusyLesHouches::printFooter() {
 
 void SusyLesHouches::printSpectrum(int ifail) {
 
+// NOTE: Gambit hack for debugging
+  // Print a debugging message
+  if (ifail == 999) {
+    std::cout<<"\n\n!! SusyLesHouches within libpythia has been touched. !!\n\n";
+    return;
+  }
+
   // Exit if output switched off
   if (verboseSav <= 0) return;
 
@@ -1467,6 +1485,8 @@ int SusyLesHouches::checkSpectrum() {
     }
   }
 
+  // GAMBIT NMSSM hack
+  /*
   // CPV
   if (modsel(5) != 0) {
     if (!cvhmix.exists()) {
@@ -1474,6 +1494,7 @@ int SusyLesHouches::checkSpectrum() {
       ifail=-1;
     }
   }
+  */ 
 
   // FLV (regardless of whether RPV or not)
   if (modsel(6) != 0) {
@@ -1596,18 +1617,22 @@ int SusyLesHouches::checkSpectrum() {
   }
 
   //NMIX
-  if (nmix.exists()) {
-    for (int i=1;i<=4;i++) {
-      double cn1=0.0;
-      double cn2=0.0;
-      for (int j=1;j<=4;j++) {
-        cn1 += pow(nmix(i,j),2);
-        cn2 += pow(nmix(j,i),2);
-      }
-      if (abs(1.0-cn1) > 1e-3 || abs(1.0-cn2) > 1e-3) {
-        ifail=2;
-        message(2,"checkSpectrum","NMIX is not unitary (wrong format?)",0);
-        break;
+  // GAMBIT NMSSM hack: don't perform check for 4x4 NMIX block when the
+  // NMSSM i used, i.e. when modsel(3) == 1.
+  if (modsel(3) != 1) {
+    if (nmix.exists()) {
+      for (int i=1;i<=4;i++) {
+        double cn1=0.0;
+        double cn2=0.0;
+        for (int j=1;j<=4;j++) {
+          cn1 += pow(nmix(i,j),2);
+          cn2 += pow(nmix(j,i),2);
+        }
+        if (abs(1.0-cn1) > 1e-3 || abs(1.0-cn2) > 1e-3) {
+          ifail=2;
+          message(2,"checkSpectrum","NMIX is not unitary (wrong format?)",0);
+          break;
+        }
       }
     }
   }
@@ -1657,6 +1682,10 @@ int SusyLesHouches::checkSpectrum() {
 
   }
 
+  // GAMBIT hack: these unitarity checks don't include
+  // the corresponding IM- blocks with the imaginary components.
+  // (Fixed in later Pythia versions.) 
+  /*
   //STOPMIX, SBOTMIX
   if (stopmix.exists() && sbotmix.exists()) {
     for (int i=1;i<=2;i++) {
@@ -1749,7 +1778,11 @@ int SusyLesHouches::checkSpectrum() {
         break;
       }
     }
-  }  //NMSSM:
+  }  
+  */ 
+
+
+  //NMSSM:
   if (modsel(3) == 1) {
     //NMNMIX
     if ( nmnmix.exists() ) {
diff -rupN pythia_8.212_original/src/SigmaProcess.cc pythia_8.212_patched/src/SigmaProcess.cc
--- pythia_8.212_original/src/SigmaProcess.cc	2015-09-23 17:35:10.000000000 +0200
+++ pythia_8.212_patched/src/SigmaProcess.cc	2021-05-21 13:11:52.469990009 +1000
@@ -1204,7 +1204,7 @@ bool Sigma3Process::setupForME() {
   } else if (id4Tmp != 0 && id5Tmp == id4Tmp) {
     mME[3] = sqrtpos(0.5 * (pow2(mME[3]) + pow2(mME[4]))
            - 0.25 * pow2(pow2(mME[3]) - pow2(mME[4])) / sH);
-    mME[4] = mME[2];
+    mME[4] = mME[3];
   }
 
   // Iterate rescaled three-momenta until convergence.
@@ -1224,6 +1224,7 @@ bool Sigma3Process::setupForME() {
   while ( abs(esum - mH) > COMPRELERR * mH && iStep < NCOMPSTEP ) {
     ++iStep;
     double compFac = 1. + 2. * (mH - esum) / p2rat;
+    if (compFac < 0) break;
     p2ME3 *= compFac;
     p2ME4 *= compFac;
     p2ME5 *= compFac;
