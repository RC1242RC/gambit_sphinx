diff -rupN darksusy-5.1.3/configure ../installed/darksusy/5.1.3/configure
--- darksusy-5.1.3/configure	2015-04-07 10:23:05.000000000 +0100
+++ ../installed/darksusy/5.1.3/configure	2018-07-04 22:31:57.218503877 +0100
@@ -3337,11 +3337,11 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 if test "${FCSET}" = "false" ; then
   if test "${FC}" = "ifort"; then
     echo "Fortran compiler is $FC"
-    FCFLAGS=${FCFLAGS+-O -extend_source}
+    FCFLAGS=${FCFLAGS+-O -extend_source -openmp -fPIC}
   fi
   if test "${FC}" = "gfortran"; then
     echo "Fortran compiler is $FC"
-    FCFLAGS=${FCFLAGS+-O -ffixed-line-length-none}
+    FCFLAGS=${FCFLAGS+-O -ffixed-line-length-none -fopenmp -fPIC}
   fi
 fi
 
diff -rupN darksusy-5.1.3/configure.ac ../installed/darksusy/5.1.3/configure.ac
--- darksusy-5.1.3/configure.ac	2015-04-07 10:23:05.000000000 +0100
+++ ../installed/darksusy/5.1.3/configure.ac	2018-07-04 22:31:57.218503877 +0100
@@ -28,11 +28,11 @@ AC_PROG_FC([ifort gfortran])
 if test "${FCSET}" = "false" ; then
   if test "${FC}" = "ifort"; then 
     echo "Fortran compiler is $FC"
-    FCFLAGS=${FCFLAGS+-O -extend_source}
+    FCFLAGS=${FCFLAGS+-O -extend_source -openmp -fPIC}
   fi 
   if test "${FC}" = "gfortran"; then
     echo "Fortran compiler is $FC"
-    FCFLAGS=${FCFLAGS+-O -ffixed-line-length-none}
+    FCFLAGS=${FCFLAGS+-O -ffixed-line-length-none -fopenmp -fPIC}
   fi
 fi
 
diff -rupN darksusy-5.1.3/contrib/FeynHiggs-2.9.4/makefile.in ../installed/darksusy/5.1.3/contrib/FeynHiggs-2.9.4/makefile.in
--- darksusy-5.1.3/contrib/FeynHiggs-2.9.4/makefile.in	2013-02-10 06:43:34.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/FeynHiggs-2.9.4/makefile.in	2018-07-04 22:31:57.218503877 +0100
@@ -31,6 +31,9 @@ ARGS = $(PARALLEL) \
 default all lib frontend mma: force
 	cd $(BLD) && $(MAKE) $(ARGS) $@
 
+lib_shared: lib
+	$(FC) $(FFLAGS) -shared -o $(DS_LIB)/libFH.so build/*.o
+
 install: default
 	-mkdir "$(PREFIX)"
 	-mkdir "$(LIBDIR)" "$(INCLUDEDIR)" "$(BINDIR)"
diff -rupN darksusy-5.1.3/contrib/FeynHiggs-2.9.4/src/Decays/VecSet.F ../installed/darksusy/5.1.3/contrib/FeynHiggs-2.9.4/src/Decays/VecSet.F
--- darksusy-5.1.3/contrib/FeynHiggs-2.9.4/src/Decays/VecSet.F	2013-02-10 06:43:34.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/FeynHiggs-2.9.4/src/Decays/VecSet.F	2018-07-04 22:31:57.218503877 +0100
@@ -27,7 +27,7 @@
 #define EpsL(x,y)  vec_(x,y, 3, i)
 #define EpsTL(x,y) vec_(x,y, 4, i)
 
-	ComplexType spi_(2, 6:7, nvec, 1)
+	ComplexType spi_(2, 6:7, nvec, LEGS)
 	equivalence (vec, spi_)
 
 #define Spi(hel,om,x) spi_(x, om, hel+6, i)
diff -rupN darksusy-5.1.3/contrib/galprop/v50p/Configure.cc ../installed/darksusy/5.1.3/contrib/galprop/v50p/Configure.cc
--- darksusy-5.1.3/contrib/galprop/v50p/Configure.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/contrib/galprop/v50p/Configure.cc	2018-07-04 22:32:02.611805950 +0100
@@ -0,0 +1,24 @@
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+// * Configure.cc *                                galprop package * 4/14/2000 
+//**"****!****"****!****"****!****"****!****"****!****"****!****"****!****"****|
+using namespace std;//AWS20050624
+#include<iostream>
+#include"Configure.h"
+
+int Configure::init()
+{
+   cout<<">>>>Configure"<<endl;
+   directory_length=100;
+   galdef_directory=new char[directory_length];
+   fits_directory=new char[directory_length];
+   adjunct_directory=new char[directory_length];
+   strcpy(galdef_directory, "/home/pat/gambit/Backends/installed/darksusy/5.1.3/share/DarkSUSY/GALDEF/");
+   strcpy(  fits_directory, "/home/pat/gambit/Backends/installed/darksusy/5.1.3/share/DarkSUSY/FITS/"  );
+   strcpy(adjunct_directory,"/home/pat/gambit/Backends/installed/darksusy/5.1.3/share/DarkSUSY/adjunct/"  );
+   cout<<"Configure: galdef_directory:  "<< galdef_directory<<endl;
+   cout<<"Configure:   fits_directory:  "<<   fits_directory<<endl;
+   cout<<"Configure:adjunct_directory:  "<<adjunct_directory<<endl;
+   cout<<"<<<<Configure"<<endl;
+   return 0;
+}
diff -rupN darksusy-5.1.3/contrib/galprop/v50p/nuc_package.cc ../installed/darksusy/5.1.3/contrib/galprop/v50p/nuc_package.cc
--- darksusy-5.1.3/contrib/galprop/v50p/nuc_package.cc	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/contrib/galprop/v50p/nuc_package.cc	2018-07-04 22:32:02.639791951 +0100
@@ -0,0 +1,834 @@
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+// * nuc_package.cc *                              galprop package * 2001/08/16
+//**"****!****"****!****"****!****"****!****"****!****"****!****"****!****"****|
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+// This file contains 4 routines on c++ which read the nuclear data from files,
+// evaluate the isotopic cross sections and take care of the unstable nuclei
+// decay channels. A sample driver program is in the bottom of this file.
+// The isotope_cs routine uses Webber's and Tsao & Silberberg fortran codes,
+// wsigma and yieldx.
+//                            ### Igor Moskalenko, NASA/GSFC ### 2001/08/16 ###
+//
+// Description of routines
+// ^^^^^^^^^^^^^^^^^^^^^^^
+//1 void read_nucdata() - reads 3D data arrays from files, it is organized
+//1 as following:
+//1 a constant N_DATA_FILES defines the total number of data-files to read;
+//1 an array of pointers data_filename[N_DATA_FILES] specifies the file names;
+//1 the dimensions of arrays in files are read into n_data[3][N_DATA_FILES];
+//1 the correspondence between data files and routines is established by  
+//1 file_no[N_DATA_FILES] = {0,1,2}, where 0=isotope_cs.dat, 1=nucdata.dat etc.;
+//1 finally an array of pointers data_file[N_DATA_FILES] indicates the areas
+//1 allocated for the data arrays which store the data from files.
+//1 The DATA FILES to read by the read_nucdata are organized as following:
+//1 in the beginning there are comments with basic description (any line number),
+//1 which follows by 3 integer numbers - array dimensions, which follows by
+//1 the data lines with some lines commented.
+//1 The comments should contain any simbol in the 1st column (not space !), 
+//1 space in the 1st column will mean the data line.
+//
+//2 float nucdata
+//2   (int ksp,int iz,int ia,int K_electron,int izf,int iaf,int* izl,int* ial,float* To) -
+//2 for any given primary nucleus (iz,ia) and any stable (or long-lived) 
+//2 final nucleus (izf,iaf) calculates the decay chain and returns branching ratio.
+//2    input:
+//2 ksp =0 - network of decays compiled from [NDS]; =1 from [GM87];
+//2 iz,ia - primary charge and atomic number (iz<29, ia<65);
+//2 K_electron =0 for the naked (iz,ia) nucleus; =1 for H-like atoms.
+//2 izf,iaf - final charge and atomic number;
+//2 uses file_no[1] as indicator of the data array.
+//2    output:
+//2 izl,ial - return charge and atomic number of an INTERMEDIATE long-lived 
+//2           isotope (if any); otherwise (izl,ial)=(0,0);
+//2 To  - if (izl,ial)#0, returns half-lifetime of (izl,ial) in sec; 
+//2       if (izl,ial)=0, but primary (iz,ia) is a long-lived isotope,
+//2          To gives its half-lifetime;
+//2       =0 otherwise;
+//2 branching ratio is returned by nucdata: 
+//2 if (iz,ia)=(izf,iaf), B =1 for stables and long-lived nuclei; =0 otherwise.
+//2    comments:
+//2 For each Z and A boundary nuclei are chosen (on the left and right), so that
+//2 outside of this area all decay treated as proton- or neutron-emission.
+//2 Inside this area all decays treated as beta(+/-) decays unless there are
+//2 special decay channels - see file nucdata.dat. The program allows up
+//2 to 4 generations in any of the special decay channels (up to 3^4 nuclei
+//2 in the final state !), beta,p,n-decays - no limits, and returns the final
+//2 branching for specified nucleus and To for intermediate long-lived isotope 
+//2 if exists.
+//2 The nucdata.dat file contains zi.ai,zf1.af1,br1,zf2.af2,br2,zf3.af3,br3:
+//2 decay channels with their branchings in order of increasing ai; and zi 
+//2 for the same ai.
+//2 Rule - secondary zf.af can appear ONLY BELOW the line where it was primary !
+//2 Any character in the 1st column can be used to comment the line.
+//2 Data on the lifetime T1/2 of long-live isotopes in cosmic rays include
+//2 reanalysis of their decay probabilities. This is particular important for
+//2 secondary K-electron capture isotopes which is suppressed in CR where 
+//2 the main channel is to be beta(+/-) decay.
+//2    references:
+//2 [B76]  Berenyi, D. et al. 1976, NPA 256, 87
+//2 [F99]  Fisker,J.L., Martinez-Pinedo,G., Langamke,K. 1999, Eur.Phys.J. A5, 229
+//2 [GM87] Garcia-Munoz M. et al. 1987, ApJS 64, 269 (non-beta decays & branch.)
+//2 [M98]  Martinez-Pinedo G., Vogel P. 1998, PRL 81, 281
+//2 [NDS]  Nuclear Data Sheets
+//2 [ToI]  Table of Isotopes, 8th Ed., by R.B.Firestone etal.(J.Wiley & Sons,Inc.),1996. 
+//2 [W98]  Wuosmaa A.H. et al. 1998, PRL 80, 2085 (54Mn[b+ & b-] half lifetime)  
+//
+//3 float isotope_cs(float emev,int iz,int ia,int izf,int iaf,int kopt,int* info)
+//3 For any given primary nucleus (iz,ia) and any final nucleus (izf,iaf) 
+//3 returns the cross section (mb) of the reaction p+(zi,ai) -> (zf,af) +X.
+//3    input:
+//3 emev  - energy of the primary nucleus in MeV/nucleon;
+//3 iz,ia - primary charge and atomic number;
+//3 izf,iaf - final charge and atomic number/ izf=0 is alloyed, gives fits of
+//3           isobaric cross sections (only with kopt = 11, 21);
+//3 kopt  =0 - uses best alghorithm described in comments below (not recommended);
+//3       =1 - forces to use Webber'93 code (no renormalization etc.);
+//3       =2 - forces to use TS00 code (no renormalization etc.);
+//3       =3 - forces to use a const cross section fitted to the data.
+//3       =10- forces to use Webber'93 code (renormalized if data exists);
+//3       =11- forces to use cross section fit if exists (otherwise equiv. 10);
+//3       =12- forces to use a numerical table if exists (otherwise equiv. 11);
+//3       =20- forces to use TS00 code (renormalized if data exists).
+//3       =21- forces to use cross section fit if exists (otherwise equiv. 20).
+//3       =22- forces to use a numerical table if exists (otherwise equiv. 21);
+//3 The best values recommended are kopt = 12, 22 (12 is preferrable).
+//3 uses file_no[1] and file_no[3] as indicators of the data array and fit params.
+//3    output:
+//3 info  =0 if no data exists, the Webber'93 or TS00 evaluation is used;
+//3       =1 if data exist and the renormalized Webber's formulae were used;
+//3       =2 if data exist and the renormalized TS00 formulae were used;
+//3       =3 if data exist and a const cross section is fitted to the data;
+//3       =10 Webber'93 code used in all cases (renormalized if data exists);
+//3       =20 TS00 code used in all cases (renormalized if data exists);
+//3       =-11,-21 if used the cross section fit;
+//3    comments:
+//3 The CS_DATA array containts the following data:
+//3 Zi.Ai, Zf.Af, emev/n, CSmb, CSerr.
+//3 if CSerr>0, it is the absolute error of the measurement;
+//3 if CSerr<0, it is the relative error and the abs. err. will be calculated 
+//3 automatically in the subroutine.
+//3 Any character in the 1st column can be used to comment the line.
+//3 isobaric cross sections (zf = 0):
+//3 *-marks the errors corrected by imos
+//3 #-marks where the data summed (e.g. B11+C11) are taken at close 
+//3   (but not equal) energies. 
+//3 kopt =0 alghorithm (not recommended): when no data exists for the required
+//3 channel, the Webber's evaluation is used. When Webber's code give 0, the result 
+//3 of TS00 code is used. When the data exist, it calculates the renormalization
+//3 coefficient for the two approximations (Webber's and TS00) using the
+//3 least-square method. Then Xi2 test is used to choose the best approximation.
+//3 When both (Webber and TS98) approximations give 0, but the experimental
+//3 value is non zero, uses a const cross section fitted to the data.
+//3    references:
+//3 [Ab94] Abdullin S.K. et al. 1994, Nucl. Phys. A 569, 753
+//3 [Gl93] Glagolev V.V. et al. 1993, Z. Phys. C 60, 421
+//3 [Ko99] Korejwo A. et al. 1999, Proc. 26th ICRC (Salt Lake City), OG 3.2.22 
+//3 [LM69] Lebowitz E., Miller J.M. 1969, Phys. Rev. 177, 1548
+//3 [Ni72] Nicholls J.E. et al. 1972, Nucl. Phys. A 181, 329
+//3 [Ol83] Olson D.L., et al. 1983, Phys.Rev.C 28, 1602 (the same as [ 17.])
+//3 [Ra79] Radin J.R., Gradsztajn E., Smith A.R. 1979, Phys. Rev. C 20, 787
+//3 [RV84] Read S.M., Viola V.E., Jr. 1984, Atom. Data Nucl. Data Tables 31, 359
+//3        if no err. is shown, relative err. 0.1 (cs>10mb), 0.2 (cs<10mb), 
+//3        0.3 (cs<1mb) are assumed; sometimes I made it differently /imos.
+//3 [TS98] Silberberg R., Tsao C.H., Barghouty A.F. 1998, ApJ 501, 911 
+//3 [We90] Webber W.R. 1990, in AIP Conf. Proc. 203, ed. W.V.Jones et al.
+//3          (NY: AIP), 294
+//3 [We96] Webber W.R. 1996, private comm.(from Ramaty R. et al.1997,ApJ 488,730)
+//3    !  relative err. 0.1 (cs>10mb), 0.2 (cs<10mb) are assumed.
+//3 [We98] Webber W.R., et al. 1998, ApJ 508, 949
+//3    !!RELATIVE ERRORS adopted: B =0.04; C =0.08; D =0.16; E =0.26
+//3 [We98prc] Webber W.R. et al. 1998, PRC 58, 3539 (Tables 7,12-15)
+//3    ! For Table 7 relative err. 0.1 (cs>10mb), 0.2 (cs<10mb) are assumed;
+//3    !!REL. ERR. adopted: A =0.03; B =0.04; C =0.07; D =0.10; E =0.18; F =0.26
+//3 -- All the following data are taken from the Transport Collab. on 21.04.99:
+//3 [ 17.] EXCLUDED - Lindstorm P.J., et al. 1975, Report LBL-3650 (see [Ol83])
+//3 [105.] Webber W.R., Kish J.C., Schrier D.A. 1990, Phys.Rev. C 41, 547
+//3 [108.] Chen C.-X., et al. 1997, ApJ 479, 504
+//3 [109.] Knott C.N., et al. 1997, Phys.Rev. C 56, 398
+//3 [110.] Chen C.-X., et al. 1997, Phys.Rev. C 56, 1536
+//3 [111.] ???
+//3 [MM03] Moskalenko I.V., Mashnik S.G. 2003, Proc. 28th ICRC (Tsukuba), p.1969
+//
+//4 double eval_cs(double emev,int za1,int za2,int* info)
+//4 the routine checks if there exists a channel with a cross section (mb) given
+//4 by a table and if so interpolates it linearly.
+//4    input:
+//4 emev  - energy of the primary nucleus in MeV/nucleon;
+//4 za1= (100*z1+a1) - primary charge and atomic number;
+//4 za2= (100*z2+a2) - final charge and atomic number;
+//4    output:
+//4 info =-1 - no channel found in the table, returns 0;
+//4      = 1 - channel found, but emev < the lowest grid pt, returns 0;
+//4      = 2 - channel found, but emev > the highest grid pt, returns cs at max energy given;
+//4      = 3 - emev falls exactly on the grid, returns cs;
+//4      = 4 - returns interpolated value.
+//=="====!===="====!===="====!===="====!===="====!===="====!===="====!===="====!
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+// GLOBAL definitions
+using namespace std;//AWS20050624
+#include<iostream>//AWS20031223
+#include<cstdlib> //IMOS20020112 AWS20050624
+#include<string>
+#include<cctype>               //AWS20050624
+#include<fstream>
+#include<cmath>
+#include "fort_interface.h"
+#include "constants.h"
+#define max(a,b) (((a) > (b)) ? (a) : (b))
+#define fnuc(z,a) (100 * (z) + (a))
+#define inuc(b) (int)(100 * (b) + 0.1)
+
+#define N_DATA_FILES 4                 // total number of data-files to read
+
+char  *data_filename[N_DATA_FILES]     // data-files to read
+         ={"/home/pat/gambit/Backends/installed/darksusy/5.1.3/share/DarkSUSY/isotope_cs.dat",
+	   "/home/pat/gambit/Backends/installed/darksusy/5.1.3/share/DarkSUSY/nucdata.dat",
+	   "/home/pat/gambit/Backends/installed/darksusy/5.1.3/share/DarkSUSY/p_cs_fits.dat",
+	   "/home/pat/gambit/Backends/installed/darksusy/5.1.3/share/DarkSUSY/eval_iso_cs.dat"};
+int   n_data[3][N_DATA_FILES],         // their dimensions n1,n2,n3  
+    file_no[N_DATA_FILES] = {0,1,2,3}; // 0=isotope_cs.dat, 1=nucdata.dat etc.
+float *data_file[N_DATA_FILES];        // pointers to the data arrays
+
+double eval_cs(double,int,int,int*);
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+void read_nucdata()
+{
+   float *tmp,*tmp1;
+   int i,j,k,size;
+   const int BufferSize=200;
+   char readBuffer[BufferSize];
+   ifstream data;
+
+   for(j=0; j<N_DATA_FILES; j++)
+   {
+      data.open(data_filename[j]);                    // open file if exists
+      if(data.fail())
+      {
+         cerr<<"read_nucdata: Error opening file "<<data_filename[j]<<endl;
+         exit(1);
+      }
+
+      while(!isspace(data.get()) && !data.eof())      // skip comments:
+         data.getline(readBuffer,BufferSize,'\n');    // any symbol in 1st col. 
+
+      for(i=0; i<3; data >> n_data[i++][j]);          // read array's sizes
+      data.getline(readBuffer,BufferSize,'\n');       // skip the rest of line
+
+      for(size=1, i=0; i<3; size*=n_data[i++][j]);    // allocate space
+//      data_file[j] = (float*) calloc( (size_t) size, (size_t) sizeof(float));
+      data_file[j] = new float[size];
+      
+      for(k = 0; k < size && !data.eof();)            // read data loop
+      {
+         while(!isspace(data.get()) && !data.eof())   // skip comments:
+            data.getline(readBuffer,BufferSize,'\n'); // any symbol in 1st col. 
+         for(i=0; i < n_data[0][j]; i++) data >> *(data_file[j]+k++);
+         data.getline(readBuffer,BufferSize,'\n');    // skip the rest of line
+      }
+      data.close();
+   }
+   return;
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+//IMOS20060420 cleanup arrays to prevent memory leaks
+void cleanup_nucdata()
+{
+  for(int j=0; j<N_DATA_FILES; j++) delete data_file[j];
+  return;
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+double nucdata(int ksp,int iz,int ia,int K_electron,int izf,int iaf,int* izl,int* ial,double* To)
+{
+   int i,j,k,l,m,n,iy,iz0,ia0,iz4,ia4,iz5,ia5,iw[121],
+       nksp=ksp*n_data[0][file_no[1]]*n_data[1][file_no[1]];
+   float w[2][121], *decay = data_file[file_no[1]]+nksp;
+   double b, xxx;
+
+// STABLE & LONG-LIVED ISOTOPES (numbers in the table are the proton numbers)
+// The long-lived isotopes listed in "longliv" table are included as stable;
+   int stable[64][3] = {      // second index changes faster
+       1,  0,  1,     1,  0,  1,     1,  0,  2,     2,  0,  2, //  A = 1- 4
+       0,  0,  0,     3,  0,  3,     3,  0,  4,     0,  0,  0, //  A = 5- 8
+       4,  0,  4,     4,  0,  5,     5,  0,  5,     6,  0,  6, //  A = 9-12
+       6,  0,  6,     6,  0,  7,     7,  0,  7,     8,  0,  8, //  A =13-16
+       8,  0,  8,     8,  0,  8,     9,  0,  9,    10,  0, 10, //  A =17-20
+      10,  0, 10,    10,  0, 11,    11,  0, 11,    12,  0, 12, //  A =21-24
+      12,  0, 12,    12,  0, 13,    13,  0, 13,    14,  0, 14, //  A =25-28
+      14,  0, 14,    14,  0, 14,    15,  0, 15,    14,  0, 16, //  A =29-32
+      16,  0, 16,    16,  0, 16,    17,  0, 17,    16, 17, 18, //  A =33-36
+      17,  0, 18,    18,  0, 18,    18,  0, 19,    18, 19, 20, //  A =37-40
+      19,  0, 20,    18,  0, 20,    20,  0, 20,    20,  0, 22, //  A =41-44
+      21,  0, 21,    20,  0, 22,    22,  0, 22,    20,  0, 22, //  A =45-48
+      22,  0, 23,    22, 23, 24,    23,  0, 24,    24,  0, 24, //  A =49-52
+      24,  0, 25,    24, 25, 26,    25,  0, 26,    26,  0, 28, //  A =53-56
+      26,  0, 27,    26,  0, 28,    27,  0, 28,    26, 27, 28, //  A =57-60
+      28,  0, 28,    28,  0, 28,    28,  0, 29,    28,  0, 28  //  A =61-64
+   };
+
+// LONG-LIVED ISOTOPES (>~1y): Zi.Ai T_1/2(y) Zf.Af - [][][0] half-life shown for naked nucleus
+   int nll = 25;                                 // - [][][1] half-life shown for H2-like atoms
+   float longliv[25][2][3] = {   // third index changes faster
+      1.03,  12.33,    2.03,     //  3H (b-) 3He   100% [ToI]
+      1.03,  12.33,    2.03,     // no EC
+
+      4.07,  0.,       4.07,     // stable
+      4.07,  0.1459,   3.07,     //  7Be(EC) 7Li   100% [ToI]
+
+      4.10,  1.60e6,   5.10,     // 10Be(b-)10B    100% [ToI]
+      4.10,  1.60e6,   5.10,     // no EC
+
+      6.14,  5.73e3,   7.14,     // 14C (b-)14N    100% [ToI]
+      6.14,  5.73e3,   7.14,     // no EC
+
+     11.22,  4.80e3,  10.22,     // 22Na(b+)22Ne        [M98]
+     11.22,  2.60e0,  10.22,     // 22Na(EC?)22Ne       [ToI] T1/2(Lab)=2.60e0 y
+
+     13.26,  9.10e5,  12.26,     // 26Al(b+)26Mg        [M98]
+     13.26,  4.075e6, 12.26,     // 26Al(EC)26Mg        [M98] T1/2(Lab)=7.4e5 y [ToI]
+
+     14.32,  172.,    16.32,     // 32Si(2b-)32S   100% [ToI] Si-P -S 
+     14.32,  172.,    16.32,     // no EC
+
+     17.36,  3.07e5,  18.36,     // 36Cl(b-)36Ar        [ToI]
+     17.36,  1.58e7,  16.36,     // 36Cl(EC)36S         [ToI] T1/2(Lab)=3.01e5 y
+
+     18.37,  0.,      18.37,     // stable
+     18.37,  0.1,     17.37,     // 37Ar(EC)37Cl   100% [ToI] T1/2(Lab)=35.04 d
+
+     18.39,  2.69e2,  19.39,     // 39Ar(b-)39K    100% [ToI]
+     18.39,  2.69e2,  19.39,     // no EC
+
+     19.40,  1.43e9,  20.40,     // 40K (b-)40Ca   89.3%[ToI] T1/2(Lab)=1.277e9 y incl 10.7% ECb+
+     19.40,  1.43e9,  20.40,     // no EC
+
+     20.41,  0.,      20.41,     // stable
+     20.41,  1.03e5,  19.41,     // 41Ca(EC)41K    100% [ToI]
+
+     18.42,  32.9,    20.42,     // 42Ar(2b-)42Ca  100% [ToI] Ar-K -Ca
+     18.42,  32.9,    20.42,     // no EC
+
+     22.44,  0.,      22.44,     // stable
+     22.44,  49.,     20.44,     // 44Ti(ECb+)44Ca 100% [ToI] Ti(EC)Sc(b+)Ca
+
+     23.49,  0.,      23.49,     // stable
+     23.49,  0.903,   22.49,     // 49V (EC)49Ti   100% [ToI] 
+
+     24.51,  0.,      24.51,     // stable
+     24.51,  0.076,   23.51,     // 51Cr(EC)51V   <100% [ToI] 
+
+     25.53,  0.,      25.53,     // stable
+     25.53,  3.74e6,  24.53,     // 53Mn(EC)53Cr   100% [ToI]
+
+     25.54,  6.30e5,  26.54,     // 54Mn(b-)54Fe        [W98]
+     25.54,  0.855,   24.54,     // 54Mn(EC)54Cr        [ToI] T1/2(Lab)=312.3 d
+
+     26.55,  0.,      26.55,     // stable
+     26.55,  2.73e0,  25.55,     // 55Fe(EC)55Mn   100% [ToI]
+
+     28.56,  4.00e4,  26.56,     // 56Ni(2b+)56Fe <100% [F99] Ni-Co-Fe
+     28.56,  0.1,     26.56,     // 56Ni(ECb+)56Fe      [ToI] T1/2(Lab)=~30 d Ni(EC)Co(b+)Fe
+
+     27.57,  0.,      27.57,     // stable
+     27.57,  0.744,   26.57,     // 57Co(EC)57Fe   100% [ToI]
+
+     28.59,  0.,      28.59,     // stable
+     28.59,  7.60e4,  27.59,     // 59Ni(EC)59Co  <100% [ToI] [B76]
+
+     27.60,  5.27e0,  28.60,     // 60Co(b-)60Ni   100% [ToI]
+     27.60,  5.27e0,  28.60,     // no EC
+
+     26.60,  1.50e6,  27.60,     // 60Fe(b-)60Co   100% [ToI]
+     26.60,  1.50e6,  27.60,     // no EC
+
+     28.63,  1.00e2,  29.63,     // 63Ni(b-)63Cu   100% [ToI]
+     28.63,  1.00e2,  29.63      // no EC
+   };
+// K-capture nuclei - factor of 2 because only 1 electron
+   for(i=0;i<nll;i++) if(longliv[i][0][1]!=longliv[i][1][1]) longliv[i][1][1] *=2.; 
+   
+// BOUNDARY NUCLEI 
+// on the left side from the left boundary, the proton-emission is assumed;
+// on the right side from the right boundary, the neutron-emission is assumed.
+// ZB.AB; left boundary[][0]: Nn=0(1)28; right boundary[][1]: Np=1(1)28 
+    int nb = 29;
+    float boundary[29][2] = {  // second index changes faster
+       1.01,  1.04,    3.04,  2.08,
+       3.05,  3.11,    6.09,  4.14,
+       6.10,  5.15,    8.13,  6.16,
+       8.14,  7.21,   10.17,  8.22,
+      12.20,  9.24,   12.21, 10.26,
+      14.24, 11.30,   14.25, 12.30,
+      15.27, 13.34,   16.29, 14.35,
+      16.30, 15.38,   18.33, 16.40,
+      20.36, 17.43,   20.37, 18.46,
+      20.38, 19.48,   22.41, 20.51,
+      22.42, 21.52,   24.45, 22.53,
+      24.46, 23.55,   24.47, 24.59,
+      25.49, 25.63,   26.51, 26.65,
+      27.53, 27.69,   27.54, 28.69,
+      28.56, 00.99
+   };
+
+   b = *To = *izl = *ial = 0;
+   if(iz <= 0 || ia <= 0) return(0.);    // check against negative numbers,
+   if(iz*ia > 1 && iz >= ia) return(0.); // non-existed nuclei,
+   if(2864 < fnuc(iz,ia)) return(0.);    // Ni64 is the heaviest nucleus
+   if(64 < ia) return(0.);               // A=64 is the maximal atomic number
+
+// CHECK FOR NUCLEI OUTSIDE THE BOUNDARIES (p/n decay)
+   iz0 = iz;
+   ia0 = ia;
+   if(ia>inuc(boundary[iz-1][1]-iz)) ia0=inuc(boundary[iz-1][1]-iz); // n -decay
+   if(29>ia-iz) if(ia>inuc(modf(boundary[ia-iz][0], &xxx)))          // p -decay
+   { 
+      iz0=(int)boundary[ia-iz][0];
+      ia0=inuc(boundary[ia-iz][0]-iz0);
+   }
+
+   for(i=0; i<121; iw[i++]=-1)  for(j=0; j<2; w[j++][i]=0.);
+
+// SEARCH FOR A SPECIAL CASE (non beta decay)
+   for(i=0; i<n_data[1][file_no[1]]; i++)
+      if(fnuc(iz0,ia0) == inuc(*(decay +i*n_data[0][file_no[1]] +0)))
+      {
+          iw[0]  = i;            // if found, save the line number
+          w[1][0]= 1.00;         // assign 1 to the branching ratio
+          break;
+      }
+
+// STANDARD CASE (beta decay & long-lived isotopes)
+   if(iw[0] < 0)
+   {
+      iz5 = iz0;
+      ia5 = ia0;
+// *** BETA DECAY ***
+      if(iz0 > stable[ia0-1][2]) iz5 = stable[ia0-1][2];   // b+ decay
+      if(iz0 < stable[ia0-1][0]) iz5 = stable[ia0-1][0];   // b- decay
+// *** LONG-LIVED ISOTOPES (>~1 y) ***
+      for(i=0; i<nll; i++)
+         if(fnuc(iz5,ia5) == inuc(longliv[i][K_electron][0]))
+         {
+            *izl = iz5;
+            *ial = ia5;
+            *To = longliv[i][K_electron][1]*year2sec;
+            if(!*To) *izl=*ial=0;
+            iz5 = (int) longliv[i][K_electron][2];
+            ia5 = inuc(longliv[i][K_electron][2]-iz5);
+            break;
+         }
+      if(fnuc(izf,iaf)==fnuc(iz5,ia5) || fnuc(izf,iaf)==fnuc(*izl,*ial)) b = 1.;
+      if(fnuc(iz0,ia0) == fnuc(*izl,*ial)) *izl = *ial = 0;
+      return(b);
+   }
+
+// DEVELOPING A NETWORK OF DECAYS
+   for(l=-1, m=0, ia4=1, i=0; i<4; ia4 =(int) pow(3.,++i))
+   {
+      for(l+=ia4, iy=0, n=0; n<ia4; n++, m++)
+      {                                                      // check if there is
+         if(iw[m] < 0) continue;                             // a required channel
+         for(w[0][m]=0., k=2; k<8; k+=2)
+         {
+            w[0][l+3*n+k/2]                                  // store sec.nuclei
+               =*(decay +iw[m]*n_data[0][file_no[1]] +k-1);
+            w[1][l+3*n+k/2]                                  // store branchings
+               =*(decay +iw[m]*n_data[0][file_no[1]] +k)*w[1][m];
+            for(j=0; j<iw[m]; j++)                           // check if sec.nucleus
+               if(*(decay +iw[m]*n_data[0][file_no[1]] +k-1) // also develops a
+                  == *(decay +j*n_data[0][file_no[1]] +0))   // network of decays
+               {
+                  iw[l+3*n+k/2] = j;                         // store such a nucleus
+                  iy = l+3*n+k/2;
+               }  ///printf("%d %d %d %d %d %d\n",l,n,m,k,j,iy);
+         }
+      }
+      if(iy == 0) break;
+   }
+
+// CHECK FOR STABILITY OF THE FINAL NUCLEI
+   for(k=0; k<=l+3*n; k++)
+   {
+      *To = *izl = *ial = 0;
+      if(w[0][k] == 0.) continue;
+      iz4 = (int) w[0][k];
+      ia4 = inuc(w[0][k]-iz4);
+      iz5 = iz4;
+      ia5 = ia4;
+// *** BETA DECAY ***
+      if(iz4 > stable[ia4-1][2]) iz5 = stable[ia4-1][2];   // b+ decay
+      if(iz4 < stable[ia4-1][0]) iz5 = stable[ia4-1][0];   // b- decay
+// *** LONG-LIVED ISOTOPES (>~1 y) ***
+      for(i=0; i<nll; i++)
+      {
+         if(fnuc(iz5,ia5) != inuc(longliv[i][K_electron][0])) continue;
+         *izl = iz5;
+         *ial = ia5;
+         *To = longliv[i][K_electron][1]*year2sec;
+         if(!*To) *izl=*ial=0;
+         iz5 = (int) longliv[i][K_electron][2];
+         ia5 = inuc(longliv[i][K_electron][2]-iz5);
+         break;
+      }
+      if(fnuc(izf,iaf) == fnuc(*izl,*ial) || fnuc(izf,iaf) == fnuc(iz5,ia5))
+         return(w[1][k]);
+   }
+   return(b);
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+double isotope_cs(double emev,int iz,int ia,int izf,int iaf,int kopt,int* info)
+{
+   int a1,a2,i,j,size, itable=0, info1;
+   float e1,y,err2,xi1,xi2, CSmb=0., f1=0., f2=0., T[11], a[3]={1.,1.,0.}, b[6];
+   float *cs_data = data_file[file_no[0]], *p_cs = data_file[file_no[2]], *tp=T;
+   double ej;
+   
+   e1 = emev;
+   *info = kopt;
+
+// CHECK if user wants to use specific program (the value of "kopt")
+   if(kopt == 1) CSmb = wsigma_cc(iz,ia,izf,iaf,emev);       // Webber's code IMOS20020502
+   if(kopt == 2) CSmb = yieldx_cc(iz,ia,izf,iaf,e1);         // TS code       IMOS20020502
+   CSmb = max(0.,CSmb);
+   if(kopt == 1 || kopt == 2) return(CSmb);
+
+   a1 = fnuc(iz, ia);
+   a2 = fnuc(izf,iaf);
+
+// EVALUATED CROSS SECTIONS
+
+   if(kopt == 12 || kopt == 22)
+   {      
+      CSmb = eval_cs(emev,a1,a2,&info1);
+      if (info1 > 0) return(max(0.,CSmb));
+      kopt--;                                          // if evaluation doesn't exist,  
+   }                                                   // try other options
+
+// if user wants, use THE CROSS SECTION FITS
+
+   if(kopt == 11 || kopt == 21)
+   {      
+// special cases: Be, B - recursion calls
+      if(izf != 0)
+      {
+// A = 10
+         if(10 == iaf)  // B10 = B10 + C10 = a10 - Be10
+         {
+            b[0] = isotope_cs(emev,iz,ia,0,iaf,21,&j);
+            if(j == -21)
+            {                                          // B10
+                if(510 == a2) 
+                {
+                   b[0]-=isotope_cs(emev,iz,ia,4,iaf,21,&j);
+                   return(max(0.,b[0]));
+                }
+                if(5 < izf) return(0.);                // C10, =0
+            }
+         }
+// A = 11
+         if(11 == iaf)  // B11 = a11 = Be11 + B11 + C11
+         {
+            b[0] = isotope_cs(emev,iz,ia,0,iaf,21,&j);
+            if(j == -21) 
+            {
+               if(511 == a2) return(max(0.,b[0]));     // B11
+               return(0.);                             // =0 for the rest
+            }
+         }
+      }
+// straight search in the table
+      for(i=0; i<n_data[1][file_no[2]]; i++, p_cs+=n_data[0][file_no[2]])
+         if(a1 == inuc(*p_cs) && a2 == inuc(*(p_cs+1)))
+         {
+            for(p_cs+=2, j=0; j<6; b[j++]=*p_cs++);    // take the parameters
+            if(b[0] >= 0.)                             // if positive use fit
+            {
+               *info=-kopt;
+               if(emev < b[5]) return(0);              // fitting function
+               b[0]*=(1.+sin(b[1]*pow(log10(emev),1.*b[2]))*exp(-b[3]*(emev-b[4])));
+               return(max(0.,b[0]));
+            }
+            kopt = (int)(-b[0]+0.1);                   // negative b[0] gives kopt
+         }
+      if(izf == 0) return(0.);
+   }
+
+// CHECK if user wants to use specific program (the value of "kopt")
+   if(kopt == 1) CSmb = wsigma_cc(iz,ia,izf,iaf,emev);       // Webber's code IMOS20020502
+   if(kopt == 2) CSmb = yieldx_cc(iz,ia,izf,iaf,e1);         // TS code       IMOS20020502
+   CSmb = max(0.,CSmb);
+   if(kopt == 1 || kopt == 2) return(CSmb);
+
+// STARTING THE ALGHORITHM
+
+   for(i=0; i<11; T[i++] = 0.);
+
+// CHECK the array: cs_data (is there a channel we are looking for ?)
+
+   for(size=1, i=0; i<3; size*=n_data[i++][file_no[0]]);
+   for(tp = T, i=0; i<size; i+=n_data[0][file_no[0]], tp = T, f1=0., f2=0.)
+   {
+      if(a1 != inuc(*(cs_data+i)))   continue;
+      if(a2 != inuc(*(cs_data+i+1))) continue;
+
+// if there is such a channel then the LEAST-SQUARE FIT
+
+      itable++;
+      if(*(cs_data+i+4) < 0.) *(cs_data+i+4) *= -*(cs_data+i+3);  // calc.abs.err.
+      err2 = pow(*(cs_data+i+4),2);                               // err^2
+      y = *(cs_data+i+3);                                         // cs measured
+      ej = *(cs_data+i+2);                                        // @ energy
+
+      if(kopt/10 != 2) f1=wsigma_cc(iz,ia,izf,iaf,ej);             // Webber IMOS20020502
+      if(kopt/10 != 1) f2=yieldx_cc(iz,ia,izf,iaf,*(cs_data+i+2)); // TS     IMOS20020502
+
+// calculations of the separate terms:
+      *tp++ += f1*y /err2;       // Webber
+      *tp++ += f1*f1/err2;
+      *tp++ += f2*y /err2;       // TS
+      *tp++ += f2*f2/err2;
+      *tp++ += y    /err2;       // const cs
+      *tp++ += 1.   /err2;
+      
+// calculation of terms for the Xi2 estimates
+      *tp++ += y*y    /err2;
+      *tp++ += 2.*f1*y/err2;
+      *tp++ += f1*f1  /err2;
+      *tp++ += 2.*f2*y/err2;
+      *tp   += f2*f2  /err2;
+
+// calculation of renormalization coefficients 
+      for(j=0; j<3; j++) a[j]= (T[2*j+1] != 0.) ? T[2*j]/T[2*j+1]: a[j];
+   }
+   if(kopt == 3 && a[2] != 0.) return(a[2]);                  // const cr.sect.
+   if(kopt/10 == 1) CSmb = wsigma_cc(iz,ia,izf,iaf,emev);     // Webber code IMOS20020502
+   if(kopt/10 == 2) CSmb = yieldx_cc(iz,ia,izf,iaf,e1);       // TS code     IMOS20020502
+   if(kopt/10 == 1 || kopt/10 == 2) return(max(0.,CSmb*a[kopt/10-1]));
+
+// CHOOSE THE BEST APPROXIMATION (kopt = 0)
+   if(itable < 2)                                         // no data or 1 pt.
+   {  
+      *info = itable;
+      CSmb = a[0]*wsigma_cc(iz,ia,izf,iaf,emev);          // use Webber code     IMOS20020502
+      if(CSmb <= 0.) 
+      {                                                   // if W-code give 0,
+         CSmb = a[1]*yieldx_cc(iz,ia,izf,iaf,e1);         // take the TS approx. IMOS20020502
+         if(CSmb != 0. && itable == 1) *info = 2;
+      }
+   } else                                                 // data exists
+   {
+      xi1= T[6] -a[0]*T[7] +a[0]*a[0]*T[8];               // Xi2 evaluation 1
+      xi2= T[6] -a[1]*T[9] +a[1]*a[1]*T[10];              // Xi2 evaluation 2
+      if(xi1 < xi2)
+      {
+         *info = 1;
+         CSmb = a[0]*wsigma_cc(iz,ia,izf,iaf,emev);       // renorm. Webber approx. IMOS20020502
+      } else
+      {
+         *info = 2;
+         CSmb = a[1]*yieldx_cc(iz,ia,izf,iaf,e1);         // renorm. TS approx.     IMOS20020502
+      }
+   }
+   return(max(0.,CSmb));
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+double eval_cs(double emev,int za1,int za2,int* info)
+{
+   int i,size;
+   float *eval = data_file[file_no[3]];
+   double x[2]={-1.e10,1.e10},y[2]={0.,0.};
+
+// CHECK the array: eval (is there a channel we are looking for ?)
+
+   for(size=1, i=0; i<3; size*=n_data[i++][file_no[3]]);
+   for(*info=0, i=0; i<size; i+=n_data[0][file_no[3]])
+   {
+      if(za1 != inuc(*(eval+i)))   continue;
+      if(za2 != inuc(*(eval+i+1))) continue;
+
+      if(x[0] < *(eval+i+2) && *(eval+i+2) <= emev)   // find lower energy pt
+      { 
+         x[0] = *(eval+i+2); 
+         y[0] = *(eval+i+3);
+      }
+      if(emev <= *(eval+i+2) && *(eval+i+2) < x[1])   // find higher energy pt 
+      { 
+         x[1] = *(eval+i+2); 
+         y[1] = *(eval+i+3);
+      }
+   }
+
+   if(x[0]*x[1] < -1.e19) { *info = -1; return(0.); } // no evaluation found, return 0
+
+   if(x[0] <   0.) { *info = 1; return(0.); }         // no lower grid pt, return 0
+   if(x[1] > 9.e9) { *info = 2; return(y[0]); }       // no higher grid pt, extrapolate
+
+   if(x[1]-x[0] == 0.) { *info = 3; return(y[1]); }   // emev falls exactly on the grid
+
+   for(*info = 4, i=0; i<2; i++) x[i] = log10(x[i]);
+   return(y[0]+(log10(emev)-x[0])*(y[1]-y[0])/(x[1]-x[0]));// interpolate
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+// A SAMPLE TEST PROGRAM
+/*
+#include<stdio.h>
+#define min(a,b) (((a) > (b)) ? (b) : (a))
+extern "C" void   set_sigma__(int*);                           // Webber's init IMOS20020502
+extern "C" void   yieldx_(int*,int*,int*,int*,float*,float*);  // TS code       IMOS20020502
+extern "C" double wsigma_(int*,int*,int*,int*,double*);        // Webber's code IMOS20020502
+main()
+{
+   FILE *f1,*f2;
+   int i,j,k,n,m,info,iz,ia,jz,ja,sz[9],sa[9],izl,ial, ksp=0, cdr=51, 
+      kopt[9]={0,1,2,10,11,12,20,21,22};
+   float *tmp;
+   double ej,b,To,cs;
+   char filename[20], ch;                  // IMOS20020502
+
+   cout<<"\nTESTING THE NUCLEAR PACKAGE / version of 3/23/2000, imos \n\n";
+
+// test read_nucdata
+   
+   cout<<"read_nucdata: I am starting\n";
+   read_nucdata();                                // read data from files
+   cout<<"read_nucdata: I am finishing\n";
+
+   f1=fopen("test_cs.1","w");                     // print data to a file
+   for(fprintf(f1,"\n"), n=0; n<N_DATA_FILES; n++, fprintf(f1,"\n")) 
+      for(tmp = data_file[n], k=0; k<n_data[2][n]; k++, fprintf(f1,"\n")) 
+         for(i=0; i<n_data[1][n]; i++, fprintf(f1,"\n")) 
+            for(j=0; j<n_data[0][n]; j++) fprintf(f1,"%11.3f",*tmp++);
+   fclose(f1);
+   cout<<"read_nucdata: test finished, check file test_cs.1\n\n";
+         
+// test nucdata
+
+   cout<<"test nuclear reaction network ?(y/n)\n";
+   cin>>ch;
+   if(ch != 'y' && ch != 'Y') goto test3;
+
+   cout<<"nucdata: start testing\n";
+   f1=fopen("test_cs.2","w");
+   f2=fopen("test_cs.2K","w");
+   for(iz=1; iz<29; iz++)                               // check all the reactions
+   {
+      for(i=0;i<20; fprintf(f1,"-"), i++); 
+      for(fprintf(f1,"%4d  ",iz), i=0;i<20; fprintf(f1,"-"), i++); fprintf(f1,"\n");
+      for(i=0;i<20; fprintf(f2,"-"), i++); 
+      for(fprintf(f2,"%4d  ",iz), i=0;i<20; fprintf(f2,"-"), i++); fprintf(f2,"\n");
+      for(ia=2*iz-2; ia<2.5*iz+4.2; ia++)
+         for(jz=1; jz<29; jz++)
+            for(ja=2*jz-4; ja<2.5*jz+4.2; ja++)
+	    {
+               b = nucdata(ksp,iz,ia,0,jz,ja,&izl,&ial,&To);
+               if(b == 0.) continue;
+               fprintf(f1,"%5d.%2d%5d.%2d%5d.%2d%14.3E%8.3f\n",iz,ia,jz,ja,izl,ial,To,b);
+               printf("%5d.%2d%5d.%2d%5d.%2d%14.3E%8.3f\n",iz,ia,jz,ja,izl,ial,To,b);
+
+               b = nucdata(ksp,iz,ia,1,jz,ja,&izl,&ial,&To);
+               if(b == 0.) continue;
+               fprintf(f2,"%5d.%2d%5d.%2d%5d.%2d%14.3E%8.3f\n",iz,ia,jz,ja,izl,ial,To,b);
+               printf("%5d.%2d%5d.%2d%5d.%2d%14.3E%8.3f\n",iz,ia,jz,ja,izl,ial,To,b);
+            }
+   }
+   cout<<"nucdata: test finished, check file test_cs.2\n\n";
+
+// test isotope_cs
+
+test3:
+   cout<<"test cross sections ?(y/n)\n";
+   cin>>ch;
+   if(ch != 'y' && ch != 'Y') goto test4;
+   
+   cout<<"cross sections: start testing \n";
+   set_sigma__(&cdr);           // initialization of Webber's code IMOS20020502
+   
+   f1=fopen("test_cs.3","w");
+   for(ej=900., iz=1; iz<29; iz++)
+      for(ia=2*iz-2; ia<2.5*iz+4.2; ia++)
+      {
+         if(!nucdata(0,iz,ia,0,iz,ia,&izl,&ial,&To)) continue;
+         for(jz=2; jz<iz+1; jz++)
+            for(ja=max(1,2*jz-2); ja<min(2*jz+4,ia); ja++, fprintf(f1,"\n"))
+            {
+               fprintf(f1,"%7.2f%7.2f%12.3E",iz+ia/100.,jz+ja/100.,ej); 
+               printf("%7.2f%7.2f%12.3e",iz+ia/100.,jz+ja/100.,ej); 
+               for(i=0; i<3; i++) 
+                  printf("%12.3e",isotope_cs(ej,iz,ia,jz,ja,kopt[i],&j)); 
+               cout<<endl;
+               for(i=0; i<9; i++) 
+                  fprintf(f1,"%12.3E",isotope_cs(ej,iz,ia,jz,ja,kopt[i],&j));
+            }
+      }
+   fclose(f1);
+   cout<<"cross sections: test finished, check file test_cs.3\n\n";
+
+// testing cross section fits
+
+test4:
+   cout<<"test cross section fits ?(y/n)\n";
+   cin>>ch;
+   if(ch != 'y' && ch != 'Y') exit(0);
+   set_sigma__(&cdr);          // initialization of Webber's code IMOS20020502
+test4_1:   
+   cout<<"cross section fits: start testing \n\n"
+       <<"give IZ IA  IZF IAF IZF IAF... 0 0:\n";
+   cin>>iz>>ia>>jz>>ja;
+   for(n=0;n<3;n++) 
+   {
+      cin>>sz[n]>>sa[n];
+      if(!(sz[n]*sa[n])) break;
+   }
+   filename[0]='\0';
+   sprintf(filename,"x%1d%1d%1d%1d_%1d%1d%1d%1d",iz/10,iz%10,ia/10,ia%10,jz/10,jz%10,ja/10,ja%10);
+   
+   f1=fopen(filename,"w");
+   for(ej=1, k=0; k<100; k++, ej*=1.1, printf("%12.3e\n",ej))
+   {
+      fprintf(f1,"\n%12.3e",ej);
+      for(i=0; i<9; i++) 
+      { 
+         cs=isotope_cs(ej,iz,ia,jz,ja,kopt[i],&j);
+	 for(m=0; m<n; m++) cs+=isotope_cs(ej,iz,ia,sz[m],sa[m],kopt[i],&j);
+         fprintf(f1,"%12.3e",cs);
+      }
+   }
+   fprintf(f1,"\n");
+   fclose(f1);
+   cout<<"output file: "<<filename<<endl;   
+   cout<<"do you want one more channel ?(y/n)\n";
+   cin>>ch;
+   if(ch == 'y' || ch == 'Y') goto test4_1;
+}
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+// Webber's isotopic production cross section  IMOS20020502
+double wsigma_cc(int IZ, int IA, int IZF, int IAF, double E)
+{
+   return( wsigma_(&IZ,&IA,&IZF,&IAF,&E) );
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+// Silberberg & Tsao isotopic production cross section  IMOS20020502
+double yieldx_cc(int IZ, int IA, int IZF, int IAF, float E)
+{
+   float CSmb;
+   yieldx_(&IZ,&IA,&IZF,&IAF,&E,&CSmb);
+   return( 1.*CSmb );
+}
+*/
+
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/access_SM.f90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/access_SM.f90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/access_SM.f90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/access_SM.f90	2018-07-04 22:31:57.218503877 +0100
@@ -321,13 +321,13 @@ subroutine testBRSM(M)
    write(*,*)'calling the subroutines'
    write(*,*)'initialize_HiggsBounds and'
    write(*,*)'finish_HiggsBounds'
-   stop'error (see standard output for more info)'
+   stop 'error (see standard output for more info)'
   endif
 
   !if(M.gt.0.0D0)then
    !ok
   !else !M is negative or NaN
-  ! stop'wrong mass given to function'
+  ! stop 'wrong mass given to function'
   !endif
 end subroutine testBRSM
 !*********************************
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/channels.F90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/channels.F90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/channels.F90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/channels.F90	2018-07-04 22:31:57.222501877 +0100
@@ -67,7 +67,7 @@ module channels
      case('TEV','LHC7')
       req= 0 * req
      case default
-      stop'error in error in setup_channels (1)'
+      stop 'error in error in setup_channels (1)'
      end select
    case('onlyH')
      select case(WhichColliderString(expt))
@@ -76,14 +76,14 @@ module channels
      case('LEP')
       req= 0 * req
      case default
-      stop'error in error in setup_channels (2)'
+      stop 'error in error in setup_channels (2)'
      end select
    case('LandH')
      select case(WhichColliderString(expt))
      case('LEP','TEV','LHC7')
       req= 1 * req
      case default
-      stop'error in error in setup_channels (3)'
+      stop 'error in error in setup_channels (3)'
      end select
    case('onlyP')
      if(pub)then
@@ -103,7 +103,7 @@ module channels
       endif
      enddo
    case default 
-    stop'error in setup_channels (A)'
+    stop 'error in setup_channels (A)'
    end select            
 
    l_analyses(i)%req=req
@@ -117,7 +117,7 @@ module channels
    case('TEV','LHC7')
      l_analyses(i)%in_first_set=.False.
    case default
-      stop'error in error in setup_channels (a)'
+      stop 'error in error in setup_channels (a)'
    end select
  
   enddo
@@ -196,7 +196,7 @@ module channels
   rep=size(r%obsratio)
   !if((size(r%chan).ne.rep).or.(size(r%allowed95).ne.rep))then
   ! write(*,*)'wrong input to subroutine check_channels in module channels'
-  ! stop
+  ! stop 
   !endif                  
   
   if( t%gooddataset )then ! labels a physical parameter point               
@@ -217,7 +217,7 @@ module channels
    ! compare with fact(mlratio) with experimental S95 value
    count_clsb=0        
    do ii=1,rep       
-    if(count_clsb.gt.0)stop'should not occur. To generalise, use a pointer.' ! should also not use 'full' after a 'clsb'
+    if(count_clsb.gt.0)stop 'should not occur. To generalise, use a pointer.' ! should also not use 'full' after a 'clsb'
     select case(r%channelselection(ii))
     case('full')
        ! do nothing        
@@ -231,7 +231,7 @@ module channels
       enddo 
       count_clsb=count_clsb+1
     case default
-       stop'problem in subroutine check_channels'
+       stop 'problem in subroutine check_channels'
     end select
 
     mlratio=maxloc(predratio,dim=1)
@@ -306,8 +306,8 @@ module channels
   ! This section is just to assist with debugging
 
      ! x=3
-     ! if(x.gt.ubound(t%particle(Hneut)%M,dim=1))stop 'error in subroutine print_stuff_for_debugging a' 
-     ! if(x.gt.ubound(t%particle(Hplus)%M,dim=1))stop 'error in subroutine print_stuff_for_debugging b' 
+     ! if(x.gt.ubound(t%particle(Hneut)%M,dim=1))stop  'error in subroutine print_stuff_for_debugging a' 
+     ! if(x.gt.ubound(t%particle(Hplus)%M,dim=1))stop  'error in subroutine print_stuff_for_debugging b' 
      ! write(*,*)'hello subroutine print_stuff_for_debugging'
 
      fileid=file_id_debug2
@@ -317,7 +317,7 @@ module channels
      !elseif(np(Hneut).ge.1)then
      !  write(n,'(" * Mhplus:",1E16.7)')t%particle(Hplus)%M(1)
      else
-       !stop'error in subroutine print_stuff_for_debugging B'
+       !stop 'error in subroutine print_stuff_for_debugging B'
      endif
 
      ! write(n,*)'********************' 
@@ -376,7 +376,7 @@ module channels
     !write(*,'(1I6,2E12.3)')maxloc(predratio,dim=1),maxval(predratio,dim=1),r%obsratio(1)
     !write(*,*)'********************'
     
-    !stop'just debugging at the moment'
+    !stop 'just debugging at the moment'
 
   end subroutine print_stuff_for_debugging
   !******************************************
@@ -419,7 +419,7 @@ module channels
     case(2)
      add_this_analysis_now =.not.l_analyses(x)%in_first_set
     case default
-     stop'error in subroutine fill_pr (a)'
+     stop 'error in subroutine fill_pr (a)'
     end select
  
     if(add_this_analysis_now)then
@@ -452,19 +452,19 @@ module channels
          enddo 
         enddo 
        case default
-        stop'error in subroutine fill_pr (3)'
+        stop 'error in subroutine fill_pr (3)'
        end select
          
       case(0)
        !leave analyses out
       case default
-       stop'error in subroutine fill_pr (1)'
+       stop 'error in subroutine fill_pr (1)'
       end select
     endif
    enddo
   enddo  
 
-  if(n.ne.ntot)stop'error in subroutine fill_pr (2)'
+  if(n.ne.ntot)stop 'error in subroutine fill_pr (2)'
 
   if(allocated(allocate_if_stats_required))then
    do n=1,ntot
@@ -551,7 +551,7 @@ module channels
   enddo
   close(n)
   
-  stop'subroutine check_tables should only be used when debugging'
+  stop 'subroutine check_tables should only be used when debugging'
 
  end subroutine check_tables
  !************************************************************
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/extra_bits_for_SLHA.f90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/extra_bits_for_SLHA.f90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/extra_bits_for_SLHA.f90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/extra_bits_for_SLHA.f90	2018-07-04 22:31:57.222501877 +0100
@@ -52,22 +52,22 @@ module extra_bits_for_SLHA
   !-------------------------------------------              
  
   if((np(Hneut).lt.0).or.(np(Hneut).gt.5))then
-    stop'can not use subroutine getSLHAdata if number of neutral Higgs is not in range 0:5'
+    stop 'can not use subroutine getSLHAdata if number of neutral Higgs is not in range 0:5'
   endif
   if((np(Hplus).lt.0).or.(np(Hplus).gt.1))then
-    stop'can not use subroutine getSLHAdata if number of charged Higgs is not in range 0:1'
+    stop 'can not use subroutine getSLHAdata if number of charged Higgs is not in range 0:1'
   endif
   if((np(Chineut).lt.0).or.(np(Chineut).gt.5))then
-    stop'can not use subroutine getSLHAdata if number of neutralinos is not in range 0:5'
+    stop 'can not use subroutine getSLHAdata if number of neutralinos is not in range 0:5'
   endif
   if((np(Chiplus).lt.0).or.(np(Chiplus).gt.2))then
-    stop'can not use subroutine getSLHAdata if number of charginos is not in range 0:2'
+    stop 'can not use subroutine getSLHAdata if number of charginos is not in range 0:2'
   endif
 
   open(file_id_common,file=trim(infile),status='old',action='read',iostat=ios) 
   if(ios.ne.0)then 
    write(*,*)'problem opening the SLHA file: $'//trim(adjustl(infile))//'$'
-   !stop'problem opening SLHA input file'
+   !stop 'problem opening SLHA input file'
   else
 
    call readSLHAfile(file_id_common)
@@ -79,7 +79,7 @@ module extra_bits_for_SLHA
     Rparityviolation =get_modsel(4)
     CPviolation      =get_modsel(5)
 
-    if(Rparityviolation.ne.0)stop'HB can not yet use SLHA files with R parity violation'
+    if(Rparityviolation.ne.0)stop 'HB can not yet use SLHA files with R parity violation'
 
     select case(particlecontent)
     case(0)
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/HiggsBounds_subroutines.F90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/HiggsBounds_subroutines.F90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/HiggsBounds_subroutines.F90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/HiggsBounds_subroutines.F90	2018-07-04 22:31:57.222501877 +0100
@@ -68,7 +68,7 @@ subroutine initialize_HiggsBounds(nHiggs
  np(Chiplus)=0! do not change this without contacting us first!
 
  if(allocated(theo))then
-  stop 'subroutine HiggsBounds_initialize has already been called once'
+  stop  'subroutine HiggsBounds_initialize has already been called once'
  endif
 
  whichanalyses=whichanalyses_in
@@ -156,7 +156,7 @@ subroutine attempting_to_use_an_old_HB_v
   write(*,*)'The subroutine run_HiggsBounds_'//subroutineid//' has been discontinued in this'
   write(*,*)'version of HiggsBounds.'
  case default
-  stop'wrong input to subroutine attempting_to_use_an_old_HB_version'
+  stop 'wrong input to subroutine attempting_to_use_an_old_HB_version'
  end select
 
  write(*,*)'If you have code written for use with HB 1.*.*, you have two choices:'
@@ -172,7 +172,7 @@ subroutine attempting_to_use_an_old_HB_v
  write(*,*)'     generally the most useful when constraining new physics models.'
  write(*,*)'     We will continue to support this code.'
 
- stop'Incorrect call to a HiggsBounds subroutine.'
+ stop 'Incorrect call to a HiggsBounds subroutine.'
 
 end subroutine attempting_to_use_an_old_HB_version
 !************************************************************      
@@ -206,7 +206,7 @@ subroutine HiggsBounds_input_SLHA(infile
  n=1  
 
  if(.not.allocated(theo))then
-  stop 'subroutine HiggsBounds_initialize must be called first'
+  stop  'subroutine HiggsBounds_initialize must be called first'
  endif
  
  infile1=infile   
@@ -257,13 +257,13 @@ subroutine HiggsBounds_neutral_input_eff
  inputsub(subtype)%stat=inputsub(subtype)%stat+1
 
  if(.not.allocated(theo))then
-  stop 'subroutine HiggsBounds_initialize must be called first'
+  stop  'subroutine HiggsBounds_initialize must be called first'
  endif
 
  if(np(Hneut).eq.0)then
   write(*,*)'subroutine HiggsBounds_neutral_input_effC should'
   write(*,*)'only be called if np(Hneut)>0'
-  stop 'error in subroutine HiggsBounds_neutral_input_effC'
+  stop  'error in subroutine HiggsBounds_neutral_input_effC'
  endif
 
  theo(n)%particle(Hneut)%M       = Mh 
@@ -359,13 +359,13 @@ subroutine HiggsBounds_neutral_input_par
  inputsub(subtype)%stat=inputsub(subtype)%stat+1
       
  if(.not.allocated(theo))then
-  stop 'subroutine HiggsBounds_initialize must be called first'
+  stop  'subroutine HiggsBounds_initialize must be called first'
  endif
 
  if(np(Hneut).eq.0)then
   write(*,*)'subroutine HiggsBounds_neutral_input_part should'
   write(*,*)'only be called if np(Hneut)>0'
-  stop 'error in subroutine HiggsBounds_neutral_input_part'
+  stop  'error in subroutine HiggsBounds_neutral_input_part'
  endif
 
 
@@ -468,13 +468,13 @@ subroutine HiggsBounds_neutral_input_had
  inputsub(subtype)%stat=inputsub(subtype)%stat+1
 
  if(.not.allocated(theo))then
-  stop 'subroutine HiggsBounds_initialize must be called first'
+  stop  'subroutine HiggsBounds_initialize must be called first'
  endif
 
  if(np(Hneut).eq.0)then
   write(*,*)'subroutine HiggsBounds_neutral_input_hadr should'
   write(*,*)'only be called if np(Hneut)>0'
-  stop 'error in subroutine HiggsBounds_neutral_input_hadr'
+  stop  'error in subroutine HiggsBounds_neutral_input_hadr'
  endif
 
  theo(n)%particle(Hneut)%M       = Mh  
@@ -544,13 +544,13 @@ subroutine HiggsBounds_charged_input(Mhp
  inputsub(subtype)%stat=inputsub(subtype)%stat+1
 
  if(.not.allocated(theo))then
-  stop 'subroutine HiggsBounds_initialize must be called first'
+  stop  'subroutine HiggsBounds_initialize must be called first'
  endif
 
  if(np(Hplus).eq.0)then
   write(*,*)'subroutine HiggsBounds_charged_input should'
   write(*,*)'only be called if np(Hplus)>0'
-  stop 'error in subroutine HiggsBounds_charged_input'
+  stop  'error in subroutine HiggsBounds_charged_input'
  endif
 
  theo(n)%particle(Hplus)%M       = Mhplus 
@@ -600,13 +600,13 @@ subroutine SUSYBounds_neutralinoonly_inp
  inputsub(subtype)%stat=inputsub(subtype)%stat+1
 
  if(.not.allocated(theo))then
-  stop 'subroutine HiggsBounds_initialize must be called first'
+  stop  'subroutine HiggsBounds_initialize must be called first'
  endif
 
  if(np(Chineut).eq.0)then
    write(*,*)'subroutine SUSYBounds_neutralinoonly_input should'
    write(*,*)'only be called if np(Chineut)>0'
-   stop'error in SUSYBounds_neutralinoonly_input'
+   stop 'error in SUSYBounds_neutralinoonly_input'
  endif
 
  theo(n)%particle(Chineut)%M       = MN
@@ -655,13 +655,13 @@ subroutine SUSYBounds_neutralinochargino
  inputsub(subtype)%stat=inputsub(subtype)%stat+1
 
  if(.not.allocated(theo))then
-  stop 'subroutine HiggsBounds_initialize must be called first'
+  stop  'subroutine HiggsBounds_initialize must be called first'
  endif
 
  if((np(Chineut).eq.0).or.(np(Chiplus).eq.0))then
    write(*,*)'subroutine SUSYBounds_neutralinochargino_input should'
    write(*,*)'only be called if np(Chineut)>0 and np(Chiplus)>0'
-   stop 'error in subroutine SUSYBounds_neutralinochargino_input'
+   stop  'error in subroutine SUSYBounds_neutralinochargino_input'
  endif
 
  theo(n)%particle(Chineut)%M       = MC
@@ -710,7 +710,7 @@ subroutine run_HiggsBounds( HBresult,cha
  n=1
 
  if(.not.allocated(theo))then
-  stop 'subroutine HiggsBounds_initialize must be called first'
+  stop  'subroutine HiggsBounds_initialize must be called first'
  endif
 
  do i=1,ubound(inputsub,dim=1)
@@ -718,7 +718,7 @@ subroutine run_HiggsBounds( HBresult,cha
        write(*,*)'subroutine '//trim(adjustl(inputsub(i)%desc))
        write(*,*)'should be called once and only once before each call to'
        write(*,*)'subroutine run_HiggsBounds.'
-       stop'error in subroutine run_HiggsBounds'
+       stop 'error in subroutine run_HiggsBounds'
    endif
    inputsub(i)%stat=0!now we have used this input, set back to zero
  enddo
@@ -747,14 +747,14 @@ use usefulbits, only : whichinput,just_a
 use output, only : do_output
 
   if(.not.just_after_run)then
-   stop'subroutine run_HiggsBounds should be called before subroutine HiggsBounds_SLHA_output' 
+   stop 'subroutine run_HiggsBounds should be called before subroutine HiggsBounds_SLHA_output' 
   endif  
 
   select case(whichinput)
   case('SLHA')
     call do_output
   case default
-    stop'The subroutine HiggsBounds_SLHA_output should only be used when whichinput=SLHA'
+    stop 'The subroutine HiggsBounds_SLHA_output should only be used when whichinput=SLHA'
   end select
 
 end subroutine HiggsBounds_SLHA_output
@@ -768,9 +768,9 @@ subroutine initialize_HiggsBounds_chisqt
  implicit none            
  
  if(allocated(theo))then
-  stop 'subroutine initialize_HiggsBounds_chisqtables should be called before subroutine HiggsBounds_initialize'
+  stop  'subroutine initialize_HiggsBounds_chisqtables should be called before subroutine HiggsBounds_initialize'
  elseif(allocated(clsb_t3))then
-  stop 'subroutine initialize_HiggsBounds_chisqtables has already been called once'
+  stop  'subroutine initialize_HiggsBounds_chisqtables has already been called once'
  endif 
 
  allocate(clsb_t3(ntable3))
@@ -781,7 +781,7 @@ subroutine initialize_HiggsBounds_chisqt
  call readclsbfiles_binary
 
  if(allocated(allocate_if_stats_required))then
-   stop'error in subroutine initialize_HiggsBounds_chisqtables'
+   stop 'error in subroutine initialize_HiggsBounds_chisqtables'
  else
    allocate(allocate_if_stats_required(1))
  endif
@@ -798,7 +798,7 @@ subroutine finish_HiggsBounds_chisqtable
  integer :: x      
 
  if(.not.allocated(clsb_t3))then
-  stop 'initialize_HiggsBounds_chisqtables should be called first'
+  stop  'initialize_HiggsBounds_chisqtables should be called first'
  endif
 
  do x=lbound(clsb_t3,dim=1),ubound(clsb_t3,dim=1)
@@ -833,11 +833,11 @@ subroutine HB_calc_stats(theory_uncertai
   low_chisq=1.0D-2
 
   if(.not.allocated(theo))then
-   stop 'subroutine HiggsBounds_initialize must be called first'
+   stop  'subroutine HiggsBounds_initialize must be called first'
   elseif(.not.allocated(clsb_t3))then
-   stop 'subroutine initialize_HiggsBounds_chisqtables must be called first'
+   stop  'subroutine initialize_HiggsBounds_chisqtables must be called first'
   elseif(.not.just_after_run)then
-   stop 'subroutine run_HiggsBounds must be called first'
+   stop  'subroutine run_HiggsBounds must be called first'
   endif
 
   sigma=theory_uncertainty_1s
@@ -871,7 +871,7 @@ subroutine HB_calc_stats(theory_uncertai
 
    else
      write(*,*)'hello y=',y
-     stop'problem here with y'
+     stop 'problem here with y'
    endif
 
   else
@@ -901,7 +901,7 @@ subroutine finish_HiggsBounds
  endif
 
  if(.not.allocated(theo))then
-  stop 'HiggsBounds_initialize  should be called first'
+  stop  'HiggsBounds_initialize  should be called first'
  endif
 
  if(debug)write(*,*)'finishing off...'                      ; call flush(6)
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/input.F90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/input.F90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/input.F90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/input.F90	2018-07-04 22:31:57.222501877 +0100
@@ -69,7 +69,7 @@ module input
    !haven't yet set whichanalyses,whichinput
    infile1=''
   case default
-   stop'incorrect value for inputmethod'
+   stop 'incorrect value for inputmethod'
   end select
 
   !getting ndat and n_additional...
@@ -92,19 +92,19 @@ module input
      write(*,*)'Check that <prefix> was specified correctly'
      write(*,*)'and that file exists.'
      call flush(6)
-     stop'Problem opening file: see standard output for more info'
+     stop 'Problem opening file: see standard output for more info'
     endif
 
     ndat=getfilelength(f) ! number of data sets (i.e. lines) in input 
  
-    if((ndat.le.0))stop 'error getting ndat'         
+    if((ndat.le.0))stop  'error getting ndat'         
     close(f)
 
     g=ubound(stem_array,dim=1)
     stem=stem_array(g)
     f=f_orig+g
     !the last element in stem_array should be 'additional'
-    if(trim(stem_array(g)).ne.'additional')stop'Error in subroutine setup_input (a)'
+    if(trim(stem_array(g)).ne.'additional')stop 'Error in subroutine setup_input (a)'
 
     required(g)=.False.
     open(f,file=trim(infile1)//trim(stem)//'.dat',status='old',action='read',iostat=ios)  
@@ -125,12 +125,12 @@ module input
    case('SLHA')
     ndat=1  ;  n_additional=0 
    case default
-    stop'error in subroutine do_input (1a)'
+    stop 'error in subroutine do_input (1a)'
    end select
   case('website','subrout')
    ndat=1   ;  n_additional=0
   case default
-   stop'error in subroutine do_input (1b)'
+   stop 'error in subroutine do_input (1b)'
   end select
   !...finished getting ndat and n_additional
 
@@ -183,12 +183,12 @@ module input
    case('SLHA') 
      n=1      
      if(ndat.ne.1)then
-       stop'error in subroutine do_input (4): need to specify infile1 for each SLHA file somehow'
+       stop 'error in subroutine do_input (4): need to specify infile1 for each SLHA file somehow'
      endif          
      call getSLHAdata(theo(n),g2(n),infile1)
      !call test_input(n)
    case default
-    stop'error in subroutine do_input (1)'
+    stop 'error in subroutine do_input (1)'
    end select
 
   case('website')   
@@ -198,7 +198,7 @@ module input
    if(webdebugmode) call test_input(n)
 
   case default
-   stop'error in subroutine do_input (3)'
+   stop 'error in subroutine do_input (3)'
   end select    
 
  end subroutine do_input
@@ -257,7 +257,7 @@ module input
    call fill('CP_values'                  ,   1,   1,   0,     1,    1,    1,    1,    0, 1,     1,    1) 
    call fill('additional'                 ,   1,   1,   1,     1,    1,    1,    1,    1, 1,     1,    1) 
 
-   if(n.ne.nt+1)stop'Error in subroutine fill_stem_array A'
+   if(n.ne.nt+1)stop 'Error in subroutine fill_stem_array A'
  
    !write(*,*)'hello whichinput',whichinput
    !write(*,*)'hello whichanalyses',whichanalyses
@@ -266,7 +266,7 @@ module input
    !do n=1,nt
    ! write(*,*)'hello ',stem_array(n),required(n)
    !enddo 
-   !stop'hello ending here for now'
+   !stop 'hello ending here for now'
 
 
    contains
@@ -293,7 +293,7 @@ module input
     case('effC')
      req= effC * req
     case default
-     stop'error in subroutine fill(whichinput)'
+     stop 'error in subroutine fill(whichinput)'
     end select
 
     select case(whichanalyses)
@@ -306,7 +306,7 @@ module input
     case('onlyP')
      req= onlyP * req
     case default
-     stop'error in subroutine fill(whichanalyses)'
+     stop 'error in subroutine fill(whichanalyses)'
     end select
 
     if(np(Hneut)==0)  req= Hneu  * req
@@ -320,7 +320,7 @@ module input
     case(1)
      required(n)=.True.
     case default
-     stop'error in subroutine fill(req)' 
+     stop 'error in subroutine fill(req)' 
     end select
    
     n=n+1
@@ -358,7 +358,7 @@ module input
 
     if(ios.ne.0)then
      call file_name_msg(f)
-     stop'problem opening file: see standard output for more info'
+     stop 'problem opening file: see standard output for more info'
     endif
 
    if((ndat.ne.getfilelength(f)))then
@@ -366,7 +366,7 @@ module input
      write(*,*)'It had',getfilelength(f),'lines'
      write(*,*)'but should have been',ndat
      call file_name_msg(f)
-     stop 'error in input file length (see standard output for filename).'
+     stop  'error in input file length (see standard output for filename).'
    endif
 
    if(get_ncol(stem).ne.count_columns(f))then
@@ -375,7 +375,7 @@ module input
      write(*,*)'but should have been',get_ncol(stem)
      write(*,*)'including line ID number'
      call file_name_msg(f)
-     stop 'error in input file format (see standard output for filename).'
+     stop  'error in input file format (see standard output for filename).'
    endif
 
    select case(trim(stem))
@@ -598,7 +598,7 @@ module input
      read(f,*)  nc, (theo(jj)%additional(i),i=1,n_additional)                 
     enddo 
   case default
-    stop'problem in subroutine readthefile (2)'
+    stop 'problem in subroutine readthefile (2)'
   end select 
   
   close(f)
@@ -606,7 +606,7 @@ module input
   if(ndat.ne.nint(nc))then 
      write(*,*)'last line read in was not labled ndat'
      call file_name_msg(f)
-     stop 'error in input file (see standard output for filename and more details).'    
+     stop  'error in input file (see standard output for filename and more details).'    
   endif 
   
   endif
@@ -646,13 +646,13 @@ module input
    wrong_args= (number_args .lt. (2+ ubound(np,dim=1)))
   else
    write(*,*)'inputmethod=',inputmethod
-   stop 'error in getbasiccommandline'
+   stop  'error in getbasiccommandline'
   endif
 
   if( wrong_args )then
    write(*,*) "Incorrect number of parameters given on command line"
    call command_line_how2
-   stop "Error: command line entered incorrectly (see standard output for more info)"
+   stop  "Error: command line entered incorrectly (see standard output for more info)"
   endif
       
   ! Read arguments into text strings.
@@ -689,7 +689,7 @@ module input
     write(*,*)'(you entered n'//trim(adjustl(pdesc(x)%short))//'="'//trim(adjustl(nHtemp))//'")'
     write(*,*)'n'//trim(adjustl(pdesc(x)%short))//' is the number of '//trim(adjustl(pdesc(x)%long))//'s'
     call command_line_how2
-    stop "Error: command line entered incorrectly (see standard output for more info)"
+    stop  "Error: command line entered incorrectly (see standard output for more info)"
    endif
 
    read(nHtemp,*) np(x)
@@ -713,7 +713,7 @@ module input
      write(*,*)'e.g.'
      write(*,*)' ./HiggsBounds LandH part 3 1 4 2 T ...'
     else
-     stop'error in subroutine command_line_how2'
+     stop 'error in subroutine command_line_how2'
     endif
    elseif(.not.official)then
     if(ubound(np,dim=1).eq.4)then
@@ -721,7 +721,7 @@ module input
      write(*,*)'e.g.'
      write(*,*)' ./HiggsBounds LandH part 3 1 4 2 mhmax'
     else
-     stop'error in subroutine command_line_how2'
+     stop 'error in subroutine command_line_how2'
     endif
    else !official, datfile
     write(*,*)' ./HiggsBounds whichanalyses whichinput nHneut nHplus prefix'
@@ -751,7 +751,7 @@ module input
    write(*,*)'            Tevatron and LHC hadronic cross sections'
    write(*,*)'SLHA        SUSY Les Houches Accord files'     
    call flush(6)                  
-   stop 'error: input type selected incorrectly (see standard output for more info)'   
+   stop  'error: input type selected incorrectly (see standard output for more info)'   
   end select 
 
  end subroutine check_whichinput 
@@ -766,17 +766,17 @@ module input
    if(np(x).lt.0)then     
     write(*,*) 'number of '//trim(adjustl(pdesc(x)%long))//'s must be greater than zero'         
     if(inputmethod.eq.'datfile')call command_line_how2        
-    stop 'error in subroutine check_number_of_particles (a) (see standard output for more info)'
+    stop  'error in subroutine check_number_of_particles (a) (see standard output for more info)'
    elseif(np(x)>nHmax)then
     write(*,*) 'number of '//trim(adjustl(pdesc(x)%long))//'s must be less than',nHmax
     write(*,*) ' (if you need more than this, please contact us)'         
     if(inputmethod.eq.'datfile')call command_line_how2        
-    stop 'error in subroutine check_number_of_particles (b) (see standard output for more info)'
+    stop  'error in subroutine check_number_of_particles (b) (see standard output for more info)'
    endif
   enddo
 
   if(sum(np).eq.0)then
-    stop'There should be a non-zero number of particles'
+    stop 'There should be a non-zero number of particles'
   endif
 
   if((inputmethod.eq.'datfile').and.(official))then
@@ -786,7 +786,7 @@ module input
          &//trim(adjustl(pdesc(x)%long))//'s must be zero'   
       write(*,*)'and you have entered the number',np(x)  
       write(*,*)'Please contact us if you would like more information.'
-      stop'error in subroutine check_number_of_particles (c) (see standard output for more info)'
+      stop 'error in subroutine check_number_of_particles (c) (see standard output for more info)'
      endif
     enddo
   endif
@@ -795,12 +795,12 @@ module input
     if((np(Hneut).lt.0).or.(np(Hneut).gt.5))then
       write(*,*)'If a SLHA file is used as input,'
       write(*,*)'number of neutral Higgs must be in the range 0:5'
-      stop'error in subroutine check_number_of_particles (d) (see standard output for more info)'
+      stop 'error in subroutine check_number_of_particles (d) (see standard output for more info)'
     endif
     if((np(Hplus).lt.0).or.(np(Hplus).gt.1))then
       write(*,*)'If a SLHA file is used as input,'
       write(*,*)'number of charged Higgs must be in the range 0:1'
-      stop'error in subroutine check_number_of_particles (e) (see standard output for more info)'
+      stop 'error in subroutine check_number_of_particles (e) (see standard output for more info)'
     endif
   endif
 
@@ -822,7 +822,7 @@ module input
    write(*,*)'LandH         LEP, Tevatron and LHC results used'
    write(*,*)'onlyP         use all analyses with an arXiv number'    
    call flush(6)                  
-   stop 'error: experiment selected incorrectly (see standard output for more info)'  
+   stop  'error: experiment selected incorrectly (see standard output for more info)'  
   end select
 
  end subroutine check_whichanalyses 
@@ -849,7 +849,7 @@ module input
   number_args = IARGC() 
   
   if( number_args .ne. nargs_datfile)then
-   stop "Incorrect number of parameters given (getshortcommandline)"
+   stop  "Incorrect number of parameters given (getshortcommandline)"
   endif
 
   ! Read last argument into text string.
@@ -898,16 +898,16 @@ module input
     exit
    elseif(ios.gt.0) then
     call file_name_msg(fileid)
-    stop 'error in input file: see standard output'
+    stop  'error in input file: see standard output'
    elseif(trim(adjustl(sample)).eq.'')then
     write(*,*)'No blank lines allowed in input file.' 
     call file_name_msg(fileid)
-    stop 'no blank lines allowed in input file: see standard output'
+    stop  'no blank lines allowed in input file: see standard output'
    endif
    n = n + 1               
   enddo            
 
-  if(n.eq.0)stop'File is empty'
+  if(n.eq.0)stop 'File is empty'
       
   getfilelength=n
   rewind(fileid)
@@ -922,7 +922,7 @@ module input
 
   if(m.ne.n)then !checking that every line end in a newline character
     call file_name_msg(fileid)
-    stop'Error: file needs to end with a newline character (see standard output for filename)'
+    stop 'Error: file needs to end with a newline character (see standard output for filename)'
   endif
 
  end function getfilelength
@@ -1079,7 +1079,7 @@ module input
    case default 
     write(*,*)'stem=',stem
     call flush(6)
-    stop 'error in function get_ncol'
+    stop  'error in function get_ncol'
    end select
 
    ! each file has the line number as the first column
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/interpolate.f90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/interpolate.f90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/interpolate.f90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/interpolate.f90	2018-07-04 22:31:57.222501877 +0100
@@ -414,9 +414,9 @@ module interpolate
   !-------------------------------------------
 
   if(lbound(interpol_array, dim=1).ne.lbound(ftype_selection, dim=1))then
-    stop'problem in interpolate_tabletype3_longer (a)'
+    stop 'problem in interpolate_tabletype3_longer (a)'
   elseif(ubound(interpol_array, dim=1).ne.lbound(ftype_selection, dim=1))then
-    stop'problem in interpolate_tabletype3_longer (b)'  
+    stop 'problem in interpolate_tabletype3_longer (b)'  
   endif
 
   ! check if mass is within z range of table:
@@ -516,7 +516,7 @@ module interpolate
   c_y   =  -1.0D6
   c_f   =  -1.0D6
 
-  if(size(slices_t2,dim=1).ne.2)stop'wrong input to slices_t2 (1)'
+  if(size(slices_t2,dim=1).ne.2)stop 'wrong input to slices_t2 (1)'
 
   ! check if mass is within z range of table:
 
@@ -643,7 +643,7 @@ module interpolate
     endif
    else ! x1 and x2 are the same point, but x is somewhere else
      write(*,*)'x,x1,x2',x,x1,x2
-     stop'error in function interpol1D' 
+     stop 'error in function interpol1D' 
    endif
 
  end function interpol1D
@@ -688,7 +688,7 @@ module interpolate
    elseif(abs(denom).lt.small)then  
      if(  ((x1-x2)**2.0D0 + (y1-y2)**2.0D0 &
        & + (x1-x3)**2.0D0 + (y1-y3)**2.0D0).lt. small )then ! (x1,y1),(x2,y2),(x3,y3) are in the same place but (x,y) is at a different place
-       stop'error in function interpol2D (case 1d)' 
+       stop 'error in function interpol2D (case 1d)' 
 
      elseif( ((x1-x2)**2.0D0 + (y1-y2)**2.0D0) .lt. small )then ! (x1,y1) and (x2,y2) are the same points
        if( abs((x2-x3)*(y-y3)-(y2-y3)*(x-x3)) .lt.sqrt(small) .or. &
@@ -704,7 +704,7 @@ module interpolate
 
          interpol2D= interpol1D(r,r2,f2,r3,f3)
        else
-         stop'error in function interpol2D (case 2aii)' 
+         stop 'error in function interpol2D (case 2aii)' 
        endif
      elseif( ((x1-x3)**2.0D0 + (y1-y3)**2.0D0) .lt. small )then ! (x1,y1) and (x3,y3) are the same points
        if( abs((x2-x1)*(y-y1)-(y2-y1)*(x-x1)) .lt.sqrt(small) .or. &
@@ -719,7 +719,7 @@ module interpolate
 
          interpol2D= interpol1D(r,r1,f1,r2,f2)
        else
-         stop'error in function interpol2D (case 2bii)' 
+         stop 'error in function interpol2D (case 2bii)' 
        endif
 
      elseif( ((x2-x3)**2.0D0 + (y2-y3)**2.0D0) .lt. small )then ! (x2,y2) and (x3,y3) are the same points
@@ -736,15 +736,15 @@ module interpolate
 
          interpol2D= interpol1D(r,r1,f1,r3,f3)
        else
-         stop'error in function interpol2D (case 2cii)'
+         stop 'error in function interpol2D (case 2cii)'
        endif
 
      elseif( abs((x2-x1)*(y-y1)-(y2-y1)*(x-x1)) .lt.small )then !the points are all in a line, but none are in exactly the same place
          !first, need to work out which 2 points to use
          !then, use interpol1D
-         stop'error: have not implemented this bit yet (case 2d)'
+         stop 'error: have not implemented this bit yet (case 2d)'
      else !(x1,y1),(x2,y2),(x3,y3) are in a line but (x,y) is not in that line
-         stop'error in function interpol2D (case 2e)'
+         stop 'error in function interpol2D (case 2e)'
      endif
    else !case 3
    ! write(*,*)'hello: case 3'
@@ -851,9 +851,9 @@ module interpolate
    !------------------------------------------- 
 
    if(    (lbound(f1,dim=1).ne.1) .or. (lbound(f2,dim=1).ne.1) .or. (lbound(f3,dim=1).ne.1) )then
-     stop'problem in function interpol3D (1)'
+     stop 'problem in function interpol3D (1)'
    elseif((ubound(f1,dim=1).ne.2) .or. (ubound(f2,dim=1).ne.2) .or. (ubound(f3,dim=1).ne.2) )then  
-     stop'problem in function interpol3D (2)'      
+     stop 'problem in function interpol3D (2)'      
    endif
 
    f1mid = interpol1D(z,z1(1),f1(1),z1(2),f1(2))
@@ -893,7 +893,7 @@ module interpolate
   double precision,allocatable :: dat(:)
   !-------------------------------------------        
 
-  if(size(m_interpol,dim=1).ne.n_points_max)stop'wrong input to interpolate_1D_inv 1'
+  if(size(m_interpol,dim=1).ne.n_points_max)stop 'wrong input to interpolate_1D_inv 1'
 
  !table 1
  !fact=   1.2001890350471742     
@@ -912,10 +912,10 @@ module interpolate
    m_interpol= - 4.0D0
   elseif(m_in.gt.t1%xmax)then !m_in should also be in table
    m_interpol= - 4.0D0
-   stop'wrong input to interpolate_1D_inv a' 
+   stop 'wrong input to interpolate_1D_inv a' 
   elseif(m_in.lt.t1%xmin)then
    m_interpol= - 4.0D0
-   stop'wrong input to interpolate_1D_inv b'
+   stop 'wrong input to interpolate_1D_inv b'
 
   else
    do i=1,t1%nx-1 ! the case where targt is exactly on last data point is dealt with separately below
@@ -993,11 +993,11 @@ module interpolate
   integer :: c_xint(3),c_yint(3)
   !-------------------------------------------        
 
-  if(ubound(t2%dat,dim=1).ne.ubound(relevent_points,dim=1))stop'wrong input to mask_for_2D_inv 1'
-  if(ubound(t2%dat,dim=2).ne.ubound(relevent_points,dim=2))stop'wrong input to mask_for_2D_inv 2'
+  if(ubound(t2%dat,dim=1).ne.ubound(relevent_points,dim=1))stop 'wrong input to mask_for_2D_inv 1'
+  if(ubound(t2%dat,dim=2).ne.ubound(relevent_points,dim=2))stop 'wrong input to mask_for_2D_inv 2'
 
-  if(lbound(relevent_points,dim=1).ne.1)stop'wrong input to mask_for_2D_inv 3'
-  if(lbound(relevent_points,dim=2).ne.1)stop'wrong input to mask_for_2D_inv 4'
+  if(lbound(relevent_points,dim=1).ne.1)stop 'wrong input to mask_for_2D_inv 3'
+  if(lbound(relevent_points,dim=2).ne.1)stop 'wrong input to mask_for_2D_inv 4'
 
   relevent_points = 0
 
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/makefile_darksusy.in ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/makefile_darksusy.in
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/makefile_darksusy.in	2015-04-07 10:23:05.000000000 +0100
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/makefile_darksusy.in	2018-07-04 22:31:57.222501877 +0100
@@ -106,10 +106,10 @@ OBJSsubroutines =  $(OBJSbasic) \
 default: HiggsBounds
 
 %.o: %.f
-	$(F77C) -c $< -o $@
+	$(F77C) $(F90FLAGS) -c $< -o $@
 
 %.o: %.F
-	$(F77C) -c $< -o $@
+	$(F77C) $(F90FLAGS) -c $< -o $@
 
 %.o %.mod: %.f90
 	$(F90C) $(F90FLAGS) $(ADDITIONALDEFINE) -c $< 
@@ -138,6 +138,17 @@ libHB:  $(MODS) $(OBJSsubroutines)
 
 libHB.a: libHB
 
+libHB_shared:  $(MODS) $(OBJSsubroutines)
+	$(F90C) $(F90FLAGS) -shared -o $(DS_LIB)/libHB.so $(OBJSsubroutines)
+	rm -f Expt_tables/S95_t1.binary 
+	rm -f Expt_tables/S95_t2.binary 
+	rm -f Theory_tables/BRSM.binary 	
+	touch Expt_tables/S95_t1.binary 
+	touch Expt_tables/S95_t2.binary 
+	touch Theory_tables/BRSM.binary 
+
+libHB.so: libHB_shared
+
 HBwithFH:  libHB.a
 	$(F77C) $(FHINCLUDE) example_programs/HBwithFH.F -o example_programs/HBwithFH $(FHLIBS) $(HBLIBS)
 	$(F90C) $(FHINCLUDE) example_programs/HBSLHAinputblocksfromFH_extras.F example_programs/HBSLHAinputblocksfromFH.F90 -o example_programs/HBSLHAinputblocksfromFH $(FHLIBS) $(HBLIBS)
@@ -157,10 +168,9 @@ clean:
 	rm -f *.o *.mod *.MOD *.a
 	rm -f store_pathname.f90
 
-hyperclean:
-	rm -f *.o *.mod *.MOD *.a *~ 
+hyperclean: clean
+	rm -f *~ 
 	rm -f example_programs/*~ 
-	rm -f store_pathname.f90
 	rm -f example_programs/HBwithFH
 	rm -f example_programs/HBwithCPsuperH
 	rm -f example_programs/example-SM_vs_4thGen
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/output.F90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/output.F90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/output.F90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/output.F90	2018-07-04 22:31:57.226499877 +0100
@@ -30,7 +30,7 @@ module output
   !-------------------------------------------
 
   if(len(start_of_filename).lt.len(infile1))then
-     stop'problem in subroutine setup_output 2'
+     stop 'problem in subroutine setup_output 2'
   endif
 
   select case(inputmethod)
@@ -43,7 +43,7 @@ module output
    case('SLHA')
     start_of_filename=''
    case default 
-     stop'problem in subroutine setup_output 1'
+     stop 'problem in subroutine setup_output 1'
    end select
    call createKey(start_of_filename)
 
@@ -151,7 +151,7 @@ module output
       endif
      enddo
    else
-    stop'error in subroutine do_output(1)'
+    stop 'error in subroutine do_output(1)'
    endif
  
    format43='(1I14,'
@@ -256,7 +256,7 @@ module output
    close(file_id_common)
    deallocate(Mhall) 
   case default
-   stop'error in subroutine do_output (*2)'    
+   stop 'error in subroutine do_output (*2)'    
   end select
  case('website')               
     do jj=1,ndat 
@@ -267,10 +267,10 @@ module output
     case('SLHA')
        call outputSLHAdata(infile1)
     case default
-       stop'error in subroutine do_output(c)'
+       stop 'error in subroutine do_output(c)'
     end select
  case default
-    stop'error in subroutine do_output (*1)'                                              
+    stop 'error in subroutine do_output (*1)'                                              
  end select  
                                                
  end subroutine do_output
@@ -338,7 +338,7 @@ module output
       write(file_id_common,*)trim(descrip)
     endif 
    else 
-    stop 'error in subroutine createKey'
+    stop  'error in subroutine createKey'
    endif
         
    select case(pr(n)%ttype)
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables.f90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables.f90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables.f90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables.f90	2018-07-04 22:31:57.226499877 +0100
@@ -129,7 +129,7 @@ module S95tables
   do i=lbound(S95_t1,dim=1),ubound(S95_t1,dim=1)
    if(WhichColliderElement(S95_t1(i)%expt).eq.0)then
      write(*,*)'~'//trim(adjustl(S95_t1(i)%expt))//'~ is not a valid experiment name'
-     stop 'error in setup_S95tables (a)'
+     stop  'error in setup_S95tables (a)'
    endif
   enddo
 
@@ -137,7 +137,7 @@ module S95tables
   do i=lbound(S95_t2,dim=1),ubound(S95_t2,dim=1)
    if(WhichColliderElement(S95_t2(i)%expt).eq.0)then
      write(*,*)'~'//trim(adjustl(S95_t2(i)%expt))//'~ is not a valid experiment name'
-     stop 'error in setup_S95tables (b)'
+     stop  'error in setup_S95tables (b)'
    endif
   enddo 
 
@@ -146,7 +146,7 @@ module S95tables
    if( count(S95_t1%id.eq.S95_t1(i)%id) &
       +count(S95_t2%id.eq.S95_t1(i)%id).ne.1)then
     write(*,*)'the id',S95_t1(i)%id,'is repeated'
-    stop 'error in setup_S95tables (c1)'
+    stop  'error in setup_S95tables (c1)'
    endif
   enddo 
   
@@ -155,7 +155,7 @@ module S95tables
    if( count(S95_t1%id.eq.S95_t2(i)%id)&
       +count(S95_t2%id.eq.S95_t2(i)%id).ne.1)then
     write(*,*)'the id',S95_t2(i)%id,'is repeated'
-    stop 'error in setup_S95tables (c2)'
+    stop  'error in setup_S95tables (c2)'
    endif
   enddo 
 
@@ -163,7 +163,7 @@ module S95tables
   do i=lbound(S95_t1,dim=1),ubound(S95_t1,dim=1)
    if(S95_t1(i)%particle_x.eq.not_a_particle)then
     write(*,*)S95_t1(i)%id,'particle_x=not_a_particle.'
-    stop 'error in setup_S95tables (d1)'  
+    stop  'error in setup_S95tables (d1)'  
    endif
   enddo
 
@@ -171,7 +171,7 @@ module S95tables
   do i=lbound(S95_t2,dim=1),ubound(S95_t2,dim=1)
    if(S95_t2(i)%particle_x2.eq.not_a_particle)then
     write(*,*)S95_t2(i)%id,'particle_x2=not_a_particle.'
-    stop 'error in setup_S95tables (d2)'  
+    stop  'error in setup_S95tables (d2)'  
    endif
   enddo
   
@@ -256,7 +256,7 @@ module S95tables
      delta_x_default(Hneut,c)=delta_Mh_LHC
      delta_x_default(Hplus,c)=delta_Mhplus_LHC
    else
-     stop'error in subroutine setup_S95tables'
+     stop 'error in subroutine setup_S95tables'
    endif
   enddo
 
@@ -309,29 +309,29 @@ module S95tables
 
   !we need tevXS_SM_functions to have a big enough range to cover the tables
   if(Exptrange_Mhmax_forSMXS(get_collider_element_number('TEV')).gt.tevXS_SM_functions_xmax)then
-   stop'need to extend upper range of tevXS_SM_functions or reduce delta_M_TEV'
+   stop 'need to extend upper range of tevXS_SM_functions or reduce delta_M_TEV'
   endif
 
   if(Exptrange_Mhmin_forSMXS(get_collider_element_number('TEV')).lt.tevXS_SM_functions_xmin)then
    write(*,*)Exptrange_Mhmin_forSMXS(get_collider_element_number('TEV')),tevXS_SM_functions_xmin
-   stop'need to extend lower range of tevXS_SM_functions'
+   stop 'need to extend lower range of tevXS_SM_functions'
   endif
 
   !we need lhc7XS_SM_functions to have a big enough range to cover the tables
   if(Exptrange_Mhmax_forSMXS(get_collider_element_number('LHC7')).gt.lhc7XS_SM_functions_xmax)then
-   stop'need to extend upper range of lhc7XS_SM_functions or reduce delta_M_LHC'
+   stop 'need to extend upper range of lhc7XS_SM_functions or reduce delta_M_LHC'
   endif
 
   if(Exptrange_Mhmin_forSMXS(get_collider_element_number('LHC7')).lt.lhc7XS_SM_functions_xmin)then
-   stop'need to extend lower range of lhc7XS_SM_functions'
+   stop 'need to extend lower range of lhc7XS_SM_functions'
   endif
   
   ! we need the branching ratios for all the colliders
   if(    maxval(Exptrange_Mhmax_forSMdecays).gt.BRSMt1Mhmax)then
-   stop'need to extend upper range of BRfunctions or reduce delta_M_(LEP/TEV)'
+   stop 'need to extend upper range of BRfunctions or reduce delta_M_(LEP/TEV)'
   elseif(minval(Exptrange_Mhmin_forSMdecays).lt.BRSMt1Mhmin)then
    write(*,*)'hello',minval(Exptrange_Mhmin_forSMdecays),BRSMt1Mhmin
-   stop'need to extend lower range of BRfunctions'
+   stop 'need to extend lower range of BRfunctions'
   endif
 
   deallocate(Expttables_Mhmin_forSMXS)
@@ -399,7 +399,7 @@ module S95tables
    endif
   enddo
 
-  if(y.ne.1)stop'problem in function get_collider_element_number'
+  if(y.ne.1)stop 'problem in function get_collider_element_number'
 
  end function get_collider_element_number
  !****************************************************************** 
@@ -453,7 +453,7 @@ module S95tables
   case(2)      
    call calcfact_t2(proc%tlist,proc%findj,proc%findi,t,cfact,axis_i,axis_j,nc)
   case default
-   stop 'wrong input to function calcfact in module channels'
+   stop  'wrong input to function calcfact in module channels'
   end select            
 
  end subroutine calcfact
@@ -497,7 +497,7 @@ module S95tables
   case(2)
    call outputproc_t2(proc%tlist,i,j,k,descrip) 
   case default
-   stop 'wrong input to subroutine outputproc in module channels'
+   stop  'wrong input to subroutine outputproc in module channels'
   end select              
             
  end subroutine outputproc 
@@ -532,7 +532,7 @@ module S95tables
     call interpolate_tabletype2(Mi,Mj,S95_t2(proc%tlist),predobs,interpol)
    case default
     write(*,*)'wrong input to subroutine check_against_bound in module channels'
-    stop
+    stop 
    end select      
   endif      
 
@@ -769,7 +769,7 @@ module S95tables
     case(6224,6225,6226)
      call model_likeness(j,S95_t1(c)%id,t,model_like(j),fact(j))
     case default
-     stop 'wrong input to function calcfact_t1 in module S95tables'
+     stop  'wrong input to function calcfact_t1 in module S95tables'
     end select
 
    endif
@@ -908,7 +908,7 @@ module S95tables
     case(2011135) 
     case(6224,6225,6226)
     case default
-     stop 'error calculating denom. in calcfact_t1'
+     stop  'error calculating denom. in calcfact_t1'
     end select
    
     cfact_t1=sum(fact)
@@ -1025,7 +1025,7 @@ module S95tables
     endif
 
    case default
-    stop 'wrong input to function calcfact_t2 in module S95tables'
+    stop  'wrong input to function calcfact_t2 in module S95tables'
    end select  
 
    if(S95_t2(c)%particle_x1.eq.not_a_particle)then
@@ -1033,7 +1033,7 @@ module S95tables
      case(6227)
      axis_i=t%BR_hjtautau(jj) 
      case default 
-      stop'Problem in subroutine calcfact_t2 (y1)'
+      stop 'Problem in subroutine calcfact_t2 (y1)'
      end select
    else
      axis_i=Mi_av
@@ -1042,7 +1042,7 @@ module S95tables
    if(S95_t2(c)%particle_x2.eq.not_a_particle)then
      select case(S95_t2(c)%id)
      case default 
-       stop'Problem in subroutine calcfact_t2 (y2)'
+       stop 'Problem in subroutine calcfact_t2 (y2)'
      end select
    else
      axis_j=Mj_av
@@ -1111,7 +1111,7 @@ module S95tables
       test_appl=x 
      endif
     case default
-      stop'error in function test_appl'
+      stop 'error in function test_appl'
     end select              
 
   end function test_appl
@@ -1301,7 +1301,7 @@ module S95tables
   case(2011103,11012)  
    descrip=' (p p)->V(h'//j//')->V (b b-bar)   '  //label        
   case default
-   stop 'wrong input to function outputproc_t1 in module S95tables (1)'  
+   stop  'wrong input to function outputproc_t1 in module S95tables (1)'  
   end select   
 
 ! New description string based on data file input
@@ -1384,7 +1384,7 @@ module S95tables
   case(6227)  
    descrip=' (p p-bar)->h'//j//'(b/b-bar)->(b b-bar) (b/b-bar) or (tau tau) (b/b-bar) '     //label 
   case default
-   stop 'wrong input to function outputproc_t2 in module S95tables (2)' 
+   stop  'wrong input to function outputproc_t2 in module S95tables (2)' 
   end select        
             
  end subroutine outputproc_t2
@@ -1432,7 +1432,7 @@ module S95tables
   case default
    if(S95_t1(n)%deltax.gt.0.0D0)then
      write(*,*)'hello id=',id,'deltax=',S95_t1(n)%deltax
-     stop'error in subroutine model_likeness (1)'
+     stop 'error in subroutine model_likeness (1)'
    endif
   end select
 
@@ -2988,21 +2988,21 @@ module S95tables
 
   case default
    write(*,*)'hello id=',id
-   stop 'error in subroutine model_likeness (2)'
+   stop  'error in subroutine model_likeness (2)'
   end select
 
 !----------------------------------------------------------
 !--New model likeness check (TS 23/03/2012)
 !----------------------------------------------------------
   if(allocated(channel_rat)) then
-    if(nc.ne.ubound(channel_rat,dim=1))stop'error in subroutine model_likeness (3a)'
-    if(nc.ne.ubound(channel_SM,dim=1))stop'error in subroutine model_likeness (3a)'
+    if(nc.ne.ubound(channel_rat,dim=1))stop 'error in subroutine model_likeness (3a)'
+    if(nc.ne.ubound(channel_SM,dim=1))stop 'error in subroutine model_likeness (3a)'
 !   Check if the channels have been filled correctly
     do ic=1,nc    
-     if(abs(channel_rat(ic,1)-unset).lt.1.0D-3)stop'error in subroutine model_likeness (4a)'      
-     if(abs(channel_rat(ic,2)-unset).lt.1.0D-3)stop'error in subroutine model_likeness (4a)'         
-     if(abs(channel_SM(ic,1)-unset).lt.1.0D-3)stop'error in subroutine model_likeness (4a)'         
-     if(abs(channel_SM(ic,2)-unset).lt.1.0D-3)stop'error in subroutine model_likeness (4a)'         
+     if(abs(channel_rat(ic,1)-unset).lt.1.0D-3)stop 'error in subroutine model_likeness (4a)'      
+     if(abs(channel_rat(ic,2)-unset).lt.1.0D-3)stop 'error in subroutine model_likeness (4a)'         
+     if(abs(channel_SM(ic,1)-unset).lt.1.0D-3)stop 'error in subroutine model_likeness (4a)'         
+     if(abs(channel_SM(ic,2)-unset).lt.1.0D-3)stop 'error in subroutine model_likeness (4a)'         
     enddo
 !---Eliminate irrelevant channels (=channels with very small SM prediction).
 !---Construct mean value of the ratio for the relevant channels
@@ -3070,14 +3070,14 @@ module S95tables
 !-If channel_rat is not allocated, use old method:  
   else
 
-    if(ns.ne.ubound(XS_rat,dim=1))stop'error in subroutine model_likeness (3a)'
-    if(nb.ne.ubound(BR_rat,dim=1))stop'error in subroutine model_likeness (3b)'
+    if(ns.ne.ubound(XS_rat,dim=1))stop 'error in subroutine model_likeness (3a)'
+    if(nb.ne.ubound(BR_rat,dim=1))stop 'error in subroutine model_likeness (3b)'
 
     do is=1,ns    
-     if(abs(XS_rat(is)-unset).lt.1.0D-3)stop'error in subroutine model_likeness (4a)'
+     if(abs(XS_rat(is)-unset).lt.1.0D-3)stop 'error in subroutine model_likeness (4a)'
     enddo
     do ib=1,nb    
-     if(abs(BR_rat(ib)-unset).lt.1.0D-3)stop'error in subroutine model_likeness (4b)'
+     if(abs(BR_rat(ib)-unset).lt.1.0D-3)stop 'error in subroutine model_likeness (4b)'
     enddo
   
     s=sum(XS_rat)/ns 
@@ -3176,7 +3176,7 @@ module S95tables
    double precision, intent(in) :: ft1_sep,vmasslower,vmasshigher,vmass_xmin,vmass_xmax,vmass_sep,valueoutsidetable
    type(table1) :: ft1
     
-    if(abs(vmass_xmin-vmass_xmax).lt.small)stop'problem in f_from_t3 (4)'
+    if(abs(vmass_xmin-vmass_xmax).lt.small)stop 'problem in f_from_t3 (4)'
     ft1%sep=ft1_sep
 
     ! we want f_t1%xmin to be lower  than x1lower
@@ -3218,7 +3218,7 @@ module S95tables
   !-------------------------------------------
 
   if(vmasslower.gt.vmasshigher)then
-    stop'problem in f_from_t1 (1)'
+    stop 'problem in f_from_t1 (1)'
   endif
 
   f_t1%id          =  t1%id  
@@ -3280,7 +3280,7 @@ module S95tables
   !-------------------------------------------
 
   if(vmasslower.gt.vmasshigher)then
-    stop'problem in f_from_t2 (1)'
+    stop 'problem in f_from_t2 (1)'
   endif
 
   if(abs(m1_at_ref_point_1-m1_at_ref_point_2).lt.small)then
@@ -3305,19 +3305,19 @@ module S95tables
 
   select case(vmassm1orm2)
   case(1)
-    if(const_m1)stop'problem in f_from_t2 (3a)'
+    if(const_m1)stop 'problem in f_from_t2 (3a)'
     vmass_xmin      =  t2%xmin1
     vmass_xmax      =  t2%xmax1
     vmass_sep       =  t2%sep1
     f_t1%sep        =  t2%sep1*sepmultfactor
   case(2)
-    if(const_m2)stop'problem in f_from_t2 (3b)'
+    if(const_m2)stop 'problem in f_from_t2 (3b)'
     vmass_xmin      =  t2%xmin2
     vmass_xmax      =  t2%xmax2
     vmass_sep       =  t2%sep2
     f_t1%sep        =  t2%sep2*sepmultfactor
   case default 
-    stop'problem in f_from_t2 (3)'
+    stop 'problem in f_from_t2 (3)'
   end select
 
   call fill_blank_ft1_dat(f_t1,f_t1%sep,vmasslower,vmasshigher,vmass_xmin,vmass_xmax,vmass_sep,valueoutsidetable) 
@@ -3415,7 +3415,7 @@ module S95tables
   double precision :: z_below,z_above
 
   if(vmasslower.gt.vmasshigher)then
-    stop'problem in f_from_slices_t2 (1)'
+    stop 'problem in f_from_slices_t2 (1)'
   endif
 
   if(abs(m1_at_ref_point_1-m1_at_ref_point_2).lt.small)then
@@ -3436,12 +3436,12 @@ module S95tables
     f_t1%deltax      =  slices_t2(1)%deltax
 
     if((slices_t2(1)%nx2.eq.1).or.(vmassm1orm2.eq.1))then
-       if(const_m1)stop'problem in f_from_slices_t2 (1a)'
+       if(const_m1)stop 'problem in f_from_slices_t2 (1a)'
        vmass_xmin      =  slices_t2(1)%xmin1
        vmass_sep       =  slices_t2(1)%sep1
        f_t1%sep        =  slices_t2(1)%sep1*sepmultfactor
     else
-       if(const_m2)stop'problem in f_from_slices_t2 (1b)'
+       if(const_m2)stop 'problem in f_from_slices_t2 (1b)'
        vmass_xmin      =  slices_t2(1)%xmin2
        vmass_sep       =  slices_t2(1)%sep2
        f_t1%sep        =  slices_t2(1)%sep2*sepmultfactor
@@ -3485,7 +3485,7 @@ module S95tables
        vmass_sep       =  slices_t2(1)%sep1
        f_t1%sep        =  slices_t2(1)%sep1*sepmultfactor
     else
-       if(const_m2)stop'problem in f_from_slices_t2 (3b)'
+       if(const_m2)stop 'problem in f_from_slices_t2 (3b)'
        vmass_xmin      =  slices_t2(1)%xmin2
        vmass_xmax      =  slices_t2(1)%xmax2
        vmass_sep       =  slices_t2(1)%sep2
@@ -3513,7 +3513,7 @@ module S95tables
             mass1 = (mass2 - line_const)/line_grad
           endif
        case default
-          stop'problem in f_from_slices_t2 (4b)'
+          stop 'problem in f_from_slices_t2 (4b)'
        end select
      endif
 
@@ -3561,7 +3561,7 @@ module S95tables
   double precision :: z_below,z_above
 
   if(vmasslower.gt.vmasshigher)then
-    stop'problem in f_from_t3 (1)'
+    stop 'problem in f_from_t3 (1)'
   endif
 
   if(abs(m1_at_ref_point_1-m1_at_ref_point_2).lt.small)then
@@ -3582,12 +3582,12 @@ module S95tables
     f_t1%deltax      =  t3%deltax
 
     if((t3%nx2.eq.1).or.(vmassm1orm2.eq.1))then
-       if(const_m1)stop'problem in f_from_t3 (1a)'
+       if(const_m1)stop 'problem in f_from_t3 (1a)'
        vmass_xmin      =  t3%xmin1
        vmass_sep       =  t3%sep1
        f_t1%sep        =  t3%sep1*sepmultfactor
     else
-       if(const_m2)stop'problem in f_from_t3 (1b)'
+       if(const_m2)stop 'problem in f_from_t3 (1b)'
        vmass_xmin      =  t3%xmin2
        vmass_sep       =  t3%sep2
        f_t1%sep        =  t3%sep2*sepmultfactor
@@ -3646,13 +3646,13 @@ module S95tables
   double precision :: dati,datiplus1
   !-------------------------------------------  
   if((datcomp.lt.lbound(t1%dat,dim=2)).or.(datcomp.gt.ubound(t1%dat,dim=2)))then
-   stop'wrong datcomp inputted to subroutine convolve_with_gaussian'
+   stop 'wrong datcomp inputted to subroutine convolve_with_gaussian'
   elseif(t1%nx.le.1)then
-   stop'wrong t1%nx inputted to subroutine convolve_with_gaussian (2)'
+   stop 'wrong t1%nx inputted to subroutine convolve_with_gaussian (2)'
   elseif(sigma.le.vsmall)then
-   stop'wrong sigma inputted to subroutine convolve_with_gaussian'
+   stop 'wrong sigma inputted to subroutine convolve_with_gaussian'
   elseif(abs(t1%sep).le.vsmall)then
-   stop'wrong t1%sep inputted to subroutine convolve_with_gaussian'
+   stop 'wrong t1%sep inputted to subroutine convolve_with_gaussian'
   endif
 
   big_number_instead_of_infinity=1.0D5
@@ -3667,7 +3667,7 @@ module S95tables
      ilow  = lbound(t1%dat,dim=1)
      ihigh = ubound(t1%dat,dim=1)
 
-     if(ilow.eq.ihigh)stop'problem in subroutine convolve_with_gaussian'
+     if(ilow.eq.ihigh)stop 'problem in subroutine convolve_with_gaussian'
 
      newsep=t1%sep/dble(divisions)
    
@@ -3766,7 +3766,7 @@ module S95tables
      case(2)  
        S95_t1_or_S95_t2_idfromelementnumber=S95_t2(tlist)%id
      case default
-       stop'wrong input to function S95_t1_or_S95_t2_idfromelementnumber'
+       stop 'wrong input to function S95_t1_or_S95_t2_idfromelementnumber'
      end select
  end function S95_t1_or_S95_t2_idfromelementnumber
  !************************************************************      
@@ -3785,7 +3785,7 @@ module S95tables
   case(2)
     S95_t1_or_S95_t2_elementnumberfromid= t2elementnumberfromid(S95_t2,id)
   case default
-    stop'problem with function S95_t1_or_S95_t2_elementnumberfromid'
+    stop 'problem with function S95_t1_or_S95_t2_elementnumberfromid'
   end select
 
  end function S95_t1_or_S95_t2_elementnumberfromid
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type1.F90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type1.F90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type1.F90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type1.F90	2018-07-04 22:31:57.226499877 +0100
@@ -86,7 +86,7 @@ module S95tables_type1
    endif
   enddo
 
-  if(n.ne.1)stop'problem in function t3elementnumberfromid 1'
+  if(n.ne.1) stop 'problem in function t3elementnumberfromid 1'
 
  end function t1elementnumberfromid
 
@@ -3530,7 +3530,7 @@ module S95tables_type1
 
   ! checks we've filled the whole array
   if(x.ne.xend)then
-   stop'error in initializetables1 (a)'
+   stop 'error in initializetables1 (a)'
   endif 
  
   ! do loop to read in S95 tables 
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type2.F90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type2.F90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type2.F90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type2.F90	2018-07-04 22:31:57.230497877 +0100
@@ -272,11 +272,11 @@ module S95tables_type2
 
      do k=lbound(file_id_arr,dim=1),ubound(file_id_arr,dim=1)
        read(file_id_arr(k),*)( testrow(i), i=0,S95_t2(x)%nx1 )
-       if((testrow(0)+100.0D0).gt.small)stop'error in initializetables2 (d)' !top left number should be -100
+       if((testrow(0)+100.0D0).gt.small)stop 'error in initializetables2 (d)' !top left number should be -100
        do i=1,S95_t2(x)%nx1      
          if( abs(testrow(i)- (S95_t2(x)%xmin1 + dble(i-1)*S95_t2(x)%sep1) ).gt.small*S95_t2(x)%sep1 )then
             write(*,*)S95_t2(x)%id,testrow(i),(S95_t2(x)%xmin1 + dble(i-1)*S95_t2(x)%sep1)
-            stop'error in initializetables2 (e)'  
+            stop 'error in initializetables2 (e)'  
          endif
        enddo
      enddo
@@ -285,11 +285,11 @@ module S95tables_type2
      do j=1,S95_t2(x)%nx2  
       read(file_id_2_exp,*) dummy, ( S95_t2(x)%dat(j,i,2), i=1,S95_t2(x)%nx1 )
       if( abs(dummy- (S95_t2(x)%xmin2 + dble(j-1)*S95_t2(x)%sep2) ).gt.small*S95_t2(x)%sep2 ) then
-       stop'error in initializetables2 (f)'
+       stop 'error in initializetables2 (f)'
       endif
       read(file_id_2_obs,*) dummy, ( S95_t2(x)%dat(j,i,1), i=1,S95_t2(x)%nx1 )   
       if( abs(dummy- (S95_t2(x)%xmin2 + dble(j-1)*S95_t2(x)%sep2) ).gt.small*S95_t2(x)%sep2 ) then
-       stop'error in initializetables2 (g)'
+       stop 'error in initializetables2 (g)'
       endif
      end do
    
@@ -335,7 +335,7 @@ module S95tables_type2
    endif
   enddo
 
-  if(n.ne.1)stop'problem in function t2elementnumberfromid 1'
+  if(n.ne.1)stop 'problem in function t2elementnumberfromid 1'
 
  end function t2elementnumberfromid
  !*********************************************************** 
@@ -358,15 +358,15 @@ module S95tables_type2
   n_ftype_selection=ubound(ftype_selection,dim=1)
 
   do n=lbound(ftype_selection,dim=1),n_ftype_selection
-     if(ftype_selection(n).lt.lbound(t2%dat,dim=3))stop'problem in fill_slices_t1_from_slices_of_t2 3a'
-     if(ftype_selection(n).gt.ubound(t2%dat,dim=3))stop'problem in fill_slices_t1_from_slices_of_t2 3b'
+     if(ftype_selection(n).lt.lbound(t2%dat,dim=3))stop 'problem in fill_slices_t1_from_slices_of_t2 3a'
+     if(ftype_selection(n).gt.ubound(t2%dat,dim=3))stop 'problem in fill_slices_t1_from_slices_of_t2 3b'
   enddo
 
   if(lbound(xy_selection,dim=1).ne.lbound(slices_t1,dim=1))then
-     stop'problem in fill_slices_t1_from_slices_of_t2 1a'
+     stop 'problem in fill_slices_t1_from_slices_of_t2 1a'
   endif
   if(ubound(xy_selection,dim=1).ne.ubound(slices_t1,dim=1))then
-     stop'problem in fill_slices_t1_from_slices_of_t2 1b'
+     stop 'problem in fill_slices_t1_from_slices_of_t2 1b'
   endif
 
   select case(v1orv2)
@@ -374,8 +374,8 @@ module S95tables_type2
 
     do n=lbound(slices_t1,dim=1),ubound(slices_t1,dim=1)
 
-     if(xy_selection(n).lt.lbound(t2%dat,dim=1))stop'problem in fill_slices_t1_from_slices_of_t2 4a'
-     if(xy_selection(n).gt.ubound(t2%dat,dim=1))stop'problem in fill_slices_t1_from_slices_of_t2 4b'
+     if(xy_selection(n).lt.lbound(t2%dat,dim=1))stop 'problem in fill_slices_t1_from_slices_of_t2 4a'
+     if(xy_selection(n).gt.ubound(t2%dat,dim=1))stop 'problem in fill_slices_t1_from_slices_of_t2 4b'
 
      slices_t1(n)%id          =  t2%id    
      slices_t1(n)%nx          =  t2%nx1  
@@ -398,8 +398,8 @@ module S95tables_type2
 
     do n=lbound(slices_t1,dim=1),ubound(slices_t1,dim=1)
 
-     if(xy_selection(n).lt.lbound(t2%dat,dim=2))stop'problem in fill_slices_t1_from_slices_of_t2 4aa'
-     if(xy_selection(n).gt.ubound(t2%dat,dim=2))stop'problem in fill_slices_t1_from_slices_of_t2 4bb'
+     if(xy_selection(n).lt.lbound(t2%dat,dim=2))stop 'problem in fill_slices_t1_from_slices_of_t2 4aa'
+     if(xy_selection(n).gt.ubound(t2%dat,dim=2))stop 'problem in fill_slices_t1_from_slices_of_t2 4bb'
 
      slices_t1(n)%id          =  t2%id    
      slices_t1(n)%nx          =  t2%nx2  
@@ -419,7 +419,7 @@ module S95tables_type2
 
     enddo
   case default
-   stop'problem in fill_slices_t1_from_slices_of_t2 5'
+   stop 'problem in fill_slices_t1_from_slices_of_t2 5'
   end select
 
  end subroutine fill_slices_t1_from_slices_of_t2
@@ -445,8 +445,8 @@ module S95tables_type2
   n_ftype_selection=ubound(ftype_selection,dim=1)
 
   do n=lbound(ftype_selection,dim=1),n_ftype_selection
-     if(ftype_selection(n).lt.lbound(t2%dat,dim=3))stop'problem in fill_t1_from_t2 3a'
-     if(ftype_selection(n).gt.ubound(t2%dat,dim=3))stop'problem in fill_t1_from_t2 3b'
+     if(ftype_selection(n).lt.lbound(t2%dat,dim=3))stop 'problem in fill_t1_from_t2 3a'
+     if(ftype_selection(n).gt.ubound(t2%dat,dim=3))stop 'problem in fill_t1_from_t2 3b'
   enddo
 
   t1%id          =  t2%id 
@@ -455,8 +455,8 @@ module S95tables_type2
   select case(v1orv2)
   case(1)
 
-     if(xy_selection.lt.lbound(t2%dat,dim=1))stop'problem in fill_t1_from_t2 4a'
-     if(xy_selection.gt.ubound(t2%dat,dim=1))stop'problem in fill_t1_from_t2 4b'
+     if(xy_selection.lt.lbound(t2%dat,dim=1))stop 'problem in fill_t1_from_t2 4a'
+     if(xy_selection.gt.ubound(t2%dat,dim=1))stop 'problem in fill_t1_from_t2 4b'
   
      t1%nx          =  t2%nx1  
      t1%xmax        =  t2%xmax1 
@@ -474,8 +474,8 @@ module S95tables_type2
 
   case(2)
 
-     if(xy_selection.lt.lbound(t2%dat,dim=2))stop'problem in fill_t1_from_t2 4aa'
-     if(xy_selection.gt.ubound(t2%dat,dim=2))stop'problem in fill_t1_from_t2 4bb'
+     if(xy_selection.lt.lbound(t2%dat,dim=2))stop 'problem in fill_t1_from_t2 4aa'
+     if(xy_selection.gt.ubound(t2%dat,dim=2))stop 'problem in fill_t1_from_t2 4bb'
 
      t1%nx          =  t2%nx2  
      t1%xmax        =  t2%xmax2 
@@ -492,7 +492,7 @@ module S95tables_type2
      enddo
 
   case default
-   stop'problem in fill_t1_from_t2 5'
+   stop 'problem in fill_t1_from_t2 5'
   end select
 
  end subroutine fill_t1_from_t2
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type3.F90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type3.F90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type3.F90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/S95tables_type3.F90	2018-07-04 22:31:57.230497877 +0100
@@ -249,7 +249,7 @@ module S95tables_type3
 
   ! checks we've filled the whole array
   if(x.ne.xend)then
-   stop'error in initializetables3 (a)'
+   stop 'error in initializetables3 (a)'
   endif
  
   do x=xbeg,xend
@@ -261,12 +261,12 @@ module S95tables_type3
    clsb_t3(x)%nx1     = nint((clsb_t3(x)%xmax1-clsb_t3(x)%xmin1)/clsb_t3(x)%sep1)+1
    clsb_t3(x)%nz      = nint((clsb_t3(x)%zmax -clsb_t3(x)%zmin )/clsb_t3(x)%zsep)+1
 
-   if(abs(clsb_t3(x)%sep1).lt.small)stop'problem in subroutine initializetables3 b1'
-   if(abs(clsb_t3(x)%sep2).lt.small)stop'problem in subroutine initializetables3 b2'
-   if(abs(clsb_t3(x)%zsep).lt.small)stop'problem in subroutine initializetables3 b3'
-   if(clsb_t3(x)%xmax1.lt.clsb_t3(x)%xmin1)stop'problem in subroutine initializetables3 b4'
-   if(clsb_t3(x)%xmax2.lt.clsb_t3(x)%xmin2)stop'problem in subroutine initializetables3 b5'
-   if(clsb_t3(x)%zmax .lt.clsb_t3(x)%zmin )stop'problem in subroutine initializetables3 b6'
+   if(abs(clsb_t3(x)%sep1).lt.small)stop 'problem in subroutine initializetables3 b1'
+   if(abs(clsb_t3(x)%sep2).lt.small)stop 'problem in subroutine initializetables3 b2'
+   if(abs(clsb_t3(x)%zsep).lt.small)stop 'problem in subroutine initializetables3 b3'
+   if(clsb_t3(x)%xmax1.lt.clsb_t3(x)%xmin1)stop 'problem in subroutine initializetables3 b4'
+   if(clsb_t3(x)%xmax2.lt.clsb_t3(x)%xmin2)stop 'problem in subroutine initializetables3 b5'
+   if(clsb_t3(x)%zmax .lt.clsb_t3(x)%zmin )stop 'problem in subroutine initializetables3 b6'
 
    !problem: can't set clsb_t3(x)%needs_M2_gt_2M1 here because it needs 
    !S95_t2
@@ -315,7 +315,7 @@ module S95tables_type3
    endif
   enddo
 
-  if(n.ne.1)stop'problem in function t3elementnumberfromid 1'
+  if(n.ne.1)stop 'problem in function t3elementnumberfromid 1'
 
  end function t3elementnumberfromid
 
@@ -335,49 +335,49 @@ module S95tables_type3
   !-------------------------------------------
 
   if(    t1%sep.eq.0)then
-    stop'problem in fill_t1dat_from_t3 (2a)'
+    stop 'problem in fill_t1dat_from_t3 (2a)'
   elseif(t1%nx.eq.0)then
-    stop'problem in fill_t1dat_from_t3 (2b)'
+    stop 'problem in fill_t1dat_from_t3 (2b)'
   elseif(nint((t1%xmax-t1%xmin)/t1%sep)+1.ne.t1%nx)then
-    stop'problem in fill_t1dat_from_t3 (2c)'
+    stop 'problem in fill_t1dat_from_t3 (2c)'
   endif
 
-  if(t1%sep.ne.t3%sep1)stop'problem in fill_t1dat_from_t3 (2d)'
+  if(t1%sep.ne.t3%sep1)stop 'problem in fill_t1dat_from_t3 (2d)'
 
-  if(ftype.lt.lbound(t3%dat,dim=3))stop'problem in fill_t1dat_from_t3 (2a)'
-  if(ftype.gt.ubound(t3%dat,dim=3))stop'problem in fill_t1dat_from_t3 (2b)'
+  if(ftype.lt.lbound(t3%dat,dim=3))stop 'problem in fill_t1dat_from_t3 (2a)'
+  if(ftype.gt.ubound(t3%dat,dim=3))stop 'problem in fill_t1dat_from_t3 (2b)'
 
-  if(zi.lt.lbound(t3%dat,dim=2))stop'problem in fill_t1dat_from_t3 (3a)'
-  if(zi.gt.ubound(t3%dat,dim=2))stop'problem in fill_t1dat_from_t3 (3b)'
+  if(zi.lt.lbound(t3%dat,dim=2))stop 'problem in fill_t1dat_from_t3 (3a)'
+  if(zi.gt.ubound(t3%dat,dim=2))stop 'problem in fill_t1dat_from_t3 (3b)'
   
-  if(ubound(t1%dat,dim=1).ne.t1%nx)stop'problem in fill_t1dat_from_t3 (5a)'
+  if(ubound(t1%dat,dim=1).ne.t1%nx)stop 'problem in fill_t1dat_from_t3 (5a)'
 
   select case(t3%type_of_assoc_table)
   case(1)
-    if(t1%xmin.lt.t3%xmin1)stop'problem in fill_t1dat_from_t3 (4a)'
-    if(t1%xmax.gt.t3%xmax1)stop'problem in fill_t1dat_from_t3 (4b)'
+    if(t1%xmin.lt.t3%xmin1)stop 'problem in fill_t1dat_from_t3 (4a)'
+    if(t1%xmax.gt.t3%xmax1)stop 'problem in fill_t1dat_from_t3 (4b)'
 
 
     ! at the moment, want t1%xmin, t1%xmax to correspond to points in t3
     ! can edit this later if needed
     if(abs((t1%xmin-t3%xmin1)/t3%sep1-dble(nint((t1%xmin-t3%xmin1)/t3%sep1))).gt.1.0D-3)then
-     stop'problem in fill_t1dat_from_t3 (6a)'
+     stop 'problem in fill_t1dat_from_t3 (6a)'
     endif
     if(abs((t1%xmax-t3%xmax1)/t3%sep1-dble(nint((t1%xmax-t3%xmax1)/t3%sep1))).gt.1.0D-3)then
-     stop'problem in fill_t1dat_from_t3 (6b)'
+     stop 'problem in fill_t1dat_from_t3 (6b)'
     endif
   case(2)
-    if(t1%xmin.lt.t3%xmin2)stop'problem in fill_t1dat_from_t3 (5a)'
-    if(t1%xmax.gt.t3%xmax2)stop'problem in fill_t1dat_from_t3 (5b)'
+    if(t1%xmin.lt.t3%xmin2)stop 'problem in fill_t1dat_from_t3 (5a)'
+    if(t1%xmax.gt.t3%xmax2)stop 'problem in fill_t1dat_from_t3 (5b)'
 
     if(abs((t1%xmin-t3%xmin2)/t3%sep2-dble(nint((t1%xmin-t3%xmin2)/t3%sep2))).gt.1.0D-3)then
-     stop'problem in fill_t1dat_from_t3 (5c)'
+     stop 'problem in fill_t1dat_from_t3 (5c)'
     endif
     if(abs((t1%xmax-t3%xmax2)/t3%sep2-dble(nint((t1%xmax-t3%xmax2)/t3%sep2))).gt.1.0D-3)then
-     stop'problem in fill_t1dat_from_t3 (5d)'
+     stop 'problem in fill_t1dat_from_t3 (5d)'
     endif
   case default
-    stop'problem in fill_t1dat_from_t3 (1a)'
+    stop 'problem in fill_t1dat_from_t3 (1a)'
   end select 
 
 
@@ -397,14 +397,14 @@ module S95tables_type3
     t1%dat(a,1)=t3%dat(ji,zi,ftype)
    enddo
 
-   if(a.ne.ubound(t1%dat,dim=1))stop'problem in fill_t1dat_from_t3 (10)'
+   if(a.ne.ubound(t1%dat,dim=1))stop 'problem in fill_t1dat_from_t3 (10)'
 
   case(2)
    !This would need extra arguments to the function, since one
    !of the masses would need to be kept constant
-   stop'problem in subroutine fill_t1dat_from_t3'
+   stop 'problem in subroutine fill_t1dat_from_t3'
   case default
-    stop'problem in fill_t1dat_from_t3 (1)'
+    stop 'problem in fill_t1dat_from_t3 (1)'
   end select 
 
  end subroutine fill_t1dat_from_t3
@@ -425,21 +425,21 @@ module S95tables_type3
   !-------------------------------------------
 
   if(lbound(zi_selection,dim=1).ne.lbound(slices_t2,dim=1))then
-    stop'problem in fill_slices_t2_from_slices_of_t3 1a'
+    stop 'problem in fill_slices_t2_from_slices_of_t3 1a'
   endif
   if(ubound(zi_selection,dim=1).ne.ubound(slices_t2,dim=1))then
-    stop'problem in fill_slices_t2_from_slices_of_t3 1b'
+    stop 'problem in fill_slices_t2_from_slices_of_t3 1b'
   endif
 
   do x=lbound(ftype_selection,dim=1),ubound(ftype_selection,dim=1)
-   if(ftype_selection(x).lt.lbound(t3%dat,dim=3))stop'problem in fill_slices_t2_from_slices_of_t3 3a'
-   if(ftype_selection(x).gt.ubound(t3%dat,dim=3))stop'problem in fill_slices_t2_from_slices_of_t3 3b'
+   if(ftype_selection(x).lt.lbound(t3%dat,dim=3))stop 'problem in fill_slices_t2_from_slices_of_t3 3a'
+   if(ftype_selection(x).gt.ubound(t3%dat,dim=3))stop 'problem in fill_slices_t2_from_slices_of_t3 3b'
   enddo
 
   do x=lbound(slices_t2,dim=1),ubound(slices_t2,dim=1)
 
-   if(zi_selection(x).lt.lbound(t3%dat,dim=2))stop'problem in fill_slices_t2_from_slices_of_t3 4a'
-   if(zi_selection(x).gt.ubound(t3%dat,dim=2))stop'problem in fill_slices_t2_from_slices_of_t3 4b'
+   if(zi_selection(x).lt.lbound(t3%dat,dim=2))stop 'problem in fill_slices_t2_from_slices_of_t3 4a'
+   if(zi_selection(x).gt.ubound(t3%dat,dim=2))stop 'problem in fill_slices_t2_from_slices_of_t3 4b'
 
 
    slices_t2(x)%id          =  t3%id    
@@ -470,7 +470,7 @@ module S95tables_type3
     case(0,1)
      itot=t3%nx1
     case default
-     stop'problem in fill_slices_t2_from_slices_of_t3 5'
+     stop 'problem in fill_slices_t2_from_slices_of_t3 5'
     end select
 
     do i=1,itot
@@ -481,7 +481,7 @@ module S95tables_type3
     enddo
    enddo 
 
-   if(ji.ne.size(t3%dat,dim=1))stop'problem in fill_slices_t2_from_slices_of_t3 6'
+   if(ji.ne.size(t3%dat,dim=1))stop 'problem in fill_slices_t2_from_slices_of_t3 6'
 
   enddo
 
@@ -559,7 +559,7 @@ module S95tables_type3
 
    if(n.ne.1)then
     write(*,*)'n=',n
-    stop'problem in readclsbfiles 1'
+    stop 'problem in readclsbfiles 1'
    endif
 
    a=0 !a labels the number of data points in entire table (spread over many files)
@@ -579,7 +579,7 @@ module S95tables_type3
    ! because of the file format: the first file is shorter than would be the case if the above expression 
    ! was correct
 
-   if(abs(deltaMhinfilename-nint(deltaMhinfilename)).gt.vsmall)stop'deltaMhinfilename must be approx an integer'
+   if(abs(deltaMhinfilename-nint(deltaMhinfilename)).gt.vsmall)stop 'deltaMhinfilename must be approx an integer'
 
    select case(clsb_t3(z)%type_of_assoc_table)
    case(1)
@@ -591,7 +591,7 @@ module S95tables_type3
     Mhinfilename_xmin=clsb_t3(z)%xmin2
     jmax=nint(deltaMhinfilename/dble(deltaMhinfilenamebits)/clsb_t3(z)%sep2)
    case default
-    stop'error in subroutine readclsbfiles'
+    stop 'error in subroutine readclsbfiles'
    end select
 
    allocate(imax(jmax))
@@ -609,7 +609,7 @@ module S95tables_type3
        imax(j)=int((Mhinfilename_initial+clsb_t3(z)%sep2*(j-1))*(clsb_t3(z)%xmax1/clsb_t3(z)%xmax2)/clsb_t3(z)%sep2)
       enddo
      case default
-      stop'error in subroutine readclsbfiles'
+      stop 'error in subroutine readclsbfiles'
      end select
   
      Mhbeg=  ( int( (Mhinfilename_initial)/deltaMhinfilename ) )*nint(deltaMhinfilename) 
@@ -637,7 +637,7 @@ module S95tables_type3
      Mhstringpart1=Mhbegstring//'_'//Mhendstring
      !write(*,*)'~'//Mhstringpart1//'~'
 
-     if(x.gt.9)stop'have not done this case yet'
+     if(x.gt.9)stop 'have not done this case yet'
      write(Mhdigit,'(I1)')x
      Mhstringpart2='_'//Mhdigit
 
@@ -677,17 +677,17 @@ module S95tables_type3
         !check Mh1_in,Mh2_in are as expected
         select case(clsb_t3(z)%type_of_assoc_table)
         case(1)
-          if(abs(Mh1_in-( Mhinfilename_initial + dble(i-1)*clsb_t3(z)%sep1)) .gt.0.0001D0 )stop'error: Mh1_in'
-          if(abs(Mh2_in-(clsb_t3(z)%xmin2 + dble(j-1)*clsb_t3(z)%sep2)) .gt.0.0001D0 )     stop'error: Mh2_in'
+          if(abs(Mh1_in-( Mhinfilename_initial + dble(i-1)*clsb_t3(z)%sep1)) .gt.0.0001D0 )stop 'error: Mh1_in'
+          if(abs(Mh2_in-(clsb_t3(z)%xmin2 + dble(j-1)*clsb_t3(z)%sep2)) .gt.0.0001D0 )     stop 'error: Mh2_in'
         case(2)
-          if(abs(Mh1_in-(clsb_t3(z)%xmin1 + dble(i-1)*clsb_t3(z)%sep1)) .gt.vsmall   )     stop'error: Mh1_in'
-          if(abs(Mh2_in-( Mhinfilename_initial + dble(j-1)*clsb_t3(z)%sep2)) .gt.0.0001D0 )stop'error: Mh2_in'
+          if(abs(Mh1_in-(clsb_t3(z)%xmin1 + dble(i-1)*clsb_t3(z)%sep1)) .gt.vsmall   )     stop 'error: Mh1_in'
+          if(abs(Mh2_in-( Mhinfilename_initial + dble(j-1)*clsb_t3(z)%sep2)) .gt.0.0001D0 )stop 'error: Mh2_in'
         case default
-          stop'error in subroutine readclsbfiles'
+          stop 'error in subroutine readclsbfiles'
         end select
 
         !check log10sf_in is as expected
-        if(  abs(log10sf_in-(clsb_t3(z)%zmin+clsb_t3(z)%zsep*dble(n-1))) .gt.0.0001D0 )stop'error: log10sf_in'
+        if(  abs(log10sf_in-(clsb_t3(z)%zmin+clsb_t3(z)%zsep*dble(n-1))) .gt.0.0001D0 )stop 'error: log10sf_in'
 #endif
 
         clsb_t3(z)%dat(b,n,clsb_t3_dat_3rdcol_clsb    )=clsb_in
@@ -709,7 +709,7 @@ module S95tables_type3
      if((n_csbfile-skip).ne.c)then
        write(*,*)'n_csbfile,skip=',n_csbfile,skip
        write(*,*)'c=',c
-       stop'error: n_csbfile,skip'
+       stop 'error: n_csbfile,skip'
      endif 
 #endif
     enddo
@@ -718,14 +718,14 @@ module S95tables_type3
    deallocate(imax)
 
 #ifdef checktables
-   if(abs(clsb_t3(z)%xmax2-Mh2_in).gt.vsmall)stop'error in clsb_t3(z)%xmax2'
+   if(abs(clsb_t3(z)%xmax2-Mh2_in).gt.vsmall)stop 'error in clsb_t3(z)%xmax2'
    if(abs(clsb_t3(z)%xmax1-Mh1_in).gt.vsmall)then
     write(*,*)'hello clsb_t3(z)%xmax1,Mh1_in',clsb_t3(z)%xmax1,Mh1_in
-    stop'error in clsb_t3(z)%xmax1'
+    stop 'error in clsb_t3(z)%xmax1'
    endif
-   if(abs(clsb_t3(z)%zmax-log10sf_in).gt.0.001)stop'error in clsb_t3(z)%zmax'
-   if((n_xy_combinations).ne.b)stop'error in n_xy_combinations'
-   if((n_xy_combinations*clsb_t3(z)%nz).ne.a)stop'error in n_xy_combinations*clsb_t3(z)%nz'
+   if(abs(clsb_t3(z)%zmax-log10sf_in).gt.0.001)stop 'error in clsb_t3(z)%zmax'
+   if((n_xy_combinations).ne.b)stop 'error in n_xy_combinations'
+   if((n_xy_combinations*clsb_t3(z)%nz).ne.a)stop 'error in n_xy_combinations*clsb_t3(z)%nz'
 #endif
 
    write(*,*)'finished reading in ',trim(filename(z))
@@ -739,7 +739,7 @@ module S95tables_type3
   integer :: z,n
   integer :: clsb_t3elementnumber_from_S95table
 
-  if(.not.(allocated(clsb_t3)))stop'error in function clsb_t3elementnumber_from_S95table'
+  if(.not.(allocated(clsb_t3)))stop 'error in function clsb_t3elementnumber_from_S95table'
 
   clsb_t3elementnumber_from_S95table=-1
 
@@ -752,7 +752,7 @@ module S95tables_type3
    endif
   enddo
 
-  if(n.gt.1)stop'error in function clsb_t3elementnumber_from_S95table'
+  if(n.gt.1)stop 'error in function clsb_t3elementnumber_from_S95table'
  
  end function clsb_t3elementnumber_from_S95table
  !*********************************************************** 
@@ -786,7 +786,7 @@ module S95tables_type3
   zbit=(log10sf-(dble(z-1)*t3%zsep+t3%zmin ))/t3%zsep
 
   if(max(ibit,jbit,zbit).gt.0.01D0)then ! Mj,Mi,log10sf are not on a data point
-    stop'bad input to function gett3dat'
+    stop 'bad input to function gett3dat'
   endif
 
   ji=0
@@ -800,7 +800,7 @@ module S95tables_type3
     case(0,1)
      itot=t3%nx1
     case default
-     stop'problem in function gett3dat'
+     stop 'problem in function gett3dat'
     end select
    endif
  
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/SLHA_manip.f90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/SLHA_manip.f90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/SLHA_manip.f90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/SLHA_manip.f90	2018-07-04 22:31:57.230497877 +0100
@@ -81,7 +81,7 @@ module SLHA_manip
   ! write(*,*)'hello block',names_of_blocks_and_decays(i)%id, &
   !  & trim(adjustl(names_of_blocks_and_decays(i)%line))
   !enddo
-  !stop'here for now (subroutine readSLHAfile)'
+  !stop 'here for now (subroutine readSLHAfile)'
 
  end subroutine readSLHAfile
  !********************************************************
@@ -227,7 +227,7 @@ module SLHA_manip
 
        call saferead_int(col(2),particlePDGcode_fromblock)
        if(particlePDGcode.ne.particlePDGcode_fromblock)then
-         stop'problem in function get_particledecaywidth(2)'
+         stop 'problem in function get_particledecaywidth(2)'
        endif
   
        call saferead_dble(col(3),get_totaldecaywidth)
@@ -278,15 +278,15 @@ module SLHA_manip
     call saferead_int(col(7),incISR_fromblock)
 
     if(trim(col(1))           .ne. 'XS'                       )then
-      stop'problem in function get_SPhenocrosssectionCMenergy(1)'
+      stop 'problem in function get_SPhenocrosssectionCMenergy(1)'
     elseif( .not.same_particles(particlePDGcode_req,particlePDGcode_fromblock) )then
-      stop'problem in function get_SPhenocrosssectionCMenergy(2)'
+      stop 'problem in function get_SPhenocrosssectionCMenergy(2)'
     elseif( pol_1             .ne. pol_1_fromblock            )then
-      stop'problem in function get_SPhenocrosssectionCMenergy(4)'
+      stop 'problem in function get_SPhenocrosssectionCMenergy(4)'
     elseif( pol_2             .ne. pol_2_fromblock            )then
-      stop'problem in function get_SPhenocrosssectionCMenergy(5)'
+      stop 'problem in function get_SPhenocrosssectionCMenergy(5)'
     elseif( incISR_fromblock  .ne. incISR_fromblock           )then
-      stop'problem in function get_SPhenocrosssectionCMenergy(6)'
+      stop 'problem in function get_SPhenocrosssectionCMenergy(6)'
     endif
 
     call saferead_dble(col(4),get_SPhenocrosssectionCMenergy)
@@ -872,7 +872,7 @@ module SLHA_manip
    case(2)
     blockname='dcinfo'
    case default
-    stop'error in function is_valid_point'
+    stop 'error in function is_valid_point'
    end select
    blocklines=line_numbers_of_block(blockname)
    if(minval(blocklines).le.0)then
@@ -918,7 +918,7 @@ module SLHA_manip
   ub=ubound(array1,dim=1)
 
   if(ub.ne.ubound(array2,dim=1))then
-   stop'problem in function same_particles'
+   stop 'problem in function same_particles'
   endif
 
   same_particles=.True.
@@ -1005,10 +1005,10 @@ module SLHA_manip
   case('block')
   case('decay')
   case default
-   stop'wrong input to function line_numbers_of_block_or_decay'
+   stop 'wrong input to function line_numbers_of_block_or_decay'
   end select
 
-  if(len(name_of_block).gt.len(name_of_block_lowercase))stop'error in function line_numbers_of_block_or_decay (a)'
+  if(len(name_of_block).gt.len(name_of_block_lowercase))stop 'error in function line_numbers_of_block_or_decay (a)'
 
   line_numbers_of_block_or_decay=0
 
@@ -1061,12 +1061,12 @@ module SLHA_manip
    if(ios.lt.0)then
     exit
    elseif(ios.gt.0) then
-    stop 'error in SLHA input file'
+    stop  'error in SLHA input file'
    endif
    n = n + 1               
   enddo            
 
-  if(n.eq.0)stop'File is empty'
+  if(n.eq.0)stop 'File is empty'
       
   getSLHAfilelength=n
   rewind(fileid)
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/string_manip.f90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/string_manip.f90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/string_manip.f90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/string_manip.f90	2018-07-04 22:31:57.230497877 +0100
@@ -12,9 +12,9 @@ contains
     !integer :: strlowa = 97
     !integer :: strlowz = 122
     integer :: casediff = 32   ! = 97-65  = 122-90
+    integer :: i,n,ich
     character(len=n) :: strtolcase
     character(len=n) :: str
-    integer :: i,n,ich
     !-----------------------
 
     strtolcase = str
@@ -30,9 +30,9 @@ contains
  function remove_from_character_onwards(string_in,n,charact)
  !********************************************************
   implicit none
+  integer,intent(in) :: n
   character(len=n),intent(in)::string_in
   character(len=n) ::remove_from_character_onwards
-  integer,intent(in) :: n
   integer :: position_of_charact
   character(len=1) :: charact
 
@@ -50,9 +50,9 @@ contains
  function remove_from_character_backwards(string_in,n,charact)
  !********************************************************
   implicit none
+  integer,intent(in) :: n
   character(len=n),intent(in)::string_in
   character(len=n) ::remove_from_character_backwards
-  integer,intent(in) :: n
   integer :: position_of_charact
   character(len=1) :: charact
 
@@ -71,9 +71,9 @@ contains
  function strip_off_comment(string_in,n)
  !********************************************************
   implicit none
+  integer,intent(in) :: n
   character(len=n),intent(in)::string_in
   character(len=n) ::strip_off_comment
-  integer,intent(in) :: n
 
   strip_off_comment=remove_from_character_onwards(string_in,n,'#')
 
@@ -86,10 +86,10 @@ contains
  !if there are m columns and m<n, columns(m+1)...columns(n) will be empty 
  !********************************************************
   implicit none
+  integer,intent(in) :: len_str,len_columns
   character(len=len_str),intent(in) :: str
   character(len=len_str) :: temp_line,bit_of_line
   character(len=len_columns) :: columns(:)
-  integer,intent(in) :: len_str,len_columns
   integer :: n,i,position_of_first_space
 
   columns=''
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theo_manip.f90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theo_manip.f90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theo_manip.f90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theo_manip.f90	2018-07-04 22:31:57.230497877 +0100
@@ -36,7 +36,7 @@ module theo_manip
     call cp_from_g2
    case('hadr','part')
    case default
-    stop'error in subroutine complete_theo (1)' 
+    stop 'error in subroutine complete_theo (1)' 
    end select               
     
   
@@ -62,11 +62,11 @@ module theo_manip
       call XS_from_partR
      case('hadr')
      case default
-      stop'error in subroutine complete_theo (2)'  
+      stop 'error in subroutine complete_theo (2)'  
      end select
    case('onlyL')
    case default       
-    stop'error in subroutine complete_theo (3)'             
+    stop 'error in subroutine complete_theo (3)'             
    end select   
   endif
 
@@ -88,7 +88,7 @@ module theo_manip
   double precision :: Mhi
   !---------------------------------------------
 
-  if(np(Hneut)<1)stop'error in csratios_from_g2  (np(Hneut))'
+  if(np(Hneut)<1)stop 'error in csratios_from_g2  (np(Hneut))'
 
 ! relative contributuion of WW- and ZZ-fusion to VBF (in LO) for
 ! p p-bar collisions at SqrtS=1.96 TeV (calcuated by T. Figy with VBFNLO):s
@@ -144,7 +144,7 @@ module theo_manip
   double precision :: max_hjff_s,max_hjff_p
   !---------------------------------------------
 
-  if(np(Hneut)<1)stop'error in cp_from_g2  (np(Hneut))'
+  if(np(Hneut)<1)stop 'error in cp_from_g2  (np(Hneut))'
 
    do jj=1,ndat
  
@@ -182,7 +182,7 @@ module theo_manip
   double precision :: Mhi,GammaRat
   !---------------------------------------------
 
-  if(np(Hneut)<1)stop'error in br_from_g2 (np(Hneut))'
+  if(np(Hneut)<1)stop 'error in br_from_g2 (np(Hneut))'
 
    do jj=1,ndat
     do i=1,np(Hneut)
@@ -356,7 +356,7 @@ module theo_manip
   double precision :: Mhi
   !----------------------------------------------
   
-  if(np(Hneut)<1)stop'error in subroutine fill_theo_SM (np(Hneut))'
+  if(np(Hneut)<1)stop 'error in subroutine fill_theo_SM (np(Hneut))'
 
    do n=1,ndat        
     if(theo(n)%gooddataset) then             
@@ -452,7 +452,7 @@ module theo_manip
   logical :: simple_partR
   !----------------------------------------------
 
-  if(np(Hneut)<1)stop'error in subroutine XS_from_partR (np(Hneut))'
+  if(np(Hneut)<1)stop 'error in subroutine XS_from_partR (np(Hneut))'
 
     call allocate_hadroncolliderextras_parts(tevS) 
     call allocate_hadroncolliderextras_parts(lhc7S) 
@@ -571,11 +571,11 @@ module theo_manip
       
 
     if(abs(sum(tevS(1)%qq_hjWp(:,j))+sum(tevS(1)%qq_hjWm(:,j)) - 1.0D0) .gt. 1.0D-2)then 
-     stop 'error in fill_tevS (a)'
+     stop  'error in fill_tevS (a)'
     elseif(abs(tevS(1)%gg_hj(j)+sum(tevS(1)%qq_hj(:,j)) - 1.0D0) .gt. 1.0D-2)then
-     stop 'error in fill_tevS (b)'
+     stop  'error in fill_tevS (b)'
     elseif(abs(tevS(1)%gg_hjZ(j)+sum(tevS(1)%qq_hjZ(:,j)) - 1.0D0) .gt. 1.0D-2)then
-     stop 'error in fill_tevS (c)'
+     stop  'error in fill_tevS (c)'
     endif 
   else
     tevS(1)%qq_hjWp(:,j)=0.0D0
@@ -608,7 +608,7 @@ module theo_manip
     lhc7S(1)%qq_hj(5,j)=LHC7_rH_bb(Mhj)
 
     if(abs(lhc7S(1)%gg_hj(j)+sum(lhc7S(1)%qq_hj(:,j)) - 1.0D0) .gt. 1.0D-2)then
-     stop 'error in fill_lhc7S (b)'
+     stop  'error in fill_lhc7S (b)'
     endif  
 
     if(XS_lhc7_HW_SM(Mhj).lt.vsmall)then
@@ -622,7 +622,7 @@ module theo_manip
       lhc7S(1)%qq_hjWm(2,j)=LHC7_rHWm_scb(Mhj)
   
       if(abs(sum(lhc7S(1)%qq_hjWp(:,j))+sum(lhc7S(1)%qq_hjWm(:,j)) - 1.0D0) .gt. 1.0D-2)then 
-       stop 'error in fill_lhc7S (a)'
+       stop  'error in fill_lhc7S (a)'
       endif 
     endif
     if(XS_lhc7_HZ_SM(Mhj).lt.vsmall)then
@@ -638,7 +638,7 @@ module theo_manip
       lhc7S(1)%qq_hjZ(5,j)=LHC7_rHZ_bbb(Mhj)
 
       if(abs(lhc7S(1)%gg_hjZ(j)+sum(lhc7S(1)%qq_hjZ(:,j)) - 1.0D0) .gt. 1.0D-2)then
-       stop 'error in fill_lhc7S (c)'
+       stop  'error in fill_lhc7S (c)'
       endif 
     endif   
   else
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theory_BRfunctions.F90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theory_BRfunctions.F90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theory_BRfunctions.F90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theory_BRfunctions.F90	2018-07-04 22:31:57.230497877 +0100
@@ -56,7 +56,7 @@ module theory_BRfunctions
   
   ! checks we've filled the whole array
   if(x.ne.xend)then
-   stop'error in setup_BRSM (a)'
+   stop 'error in setup_BRSM (a)'
   endif 
  
   col=7
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theory_XS_SM_functions.F90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theory_XS_SM_functions.F90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theory_XS_SM_functions.F90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/theory_XS_SM_functions.F90	2018-07-04 22:31:57.230497877 +0100
@@ -71,7 +71,7 @@ module theory_XS_SM_functions
        rangeok=.False.
       endif
      case default 
-        stop'problem in subroutine check_range'
+        stop  'problem in subroutine check_range'
      end select
   endif 
 
@@ -313,7 +313,7 @@ module theory_XS_SM_functions
 
   call check_range('TEV ',x,rangeok,badvalue,strict)
   if((x.lt.100.0D0).or.(x.gt.200.0D0))then
-   !stop'function XS_gg_H_SM_9713: need to check validity at this MH'
+   !stop  'function XS_gg_H_SM_9713: need to check validity at this MH'
    write(*,*)'WARNING: function XS_tev_gg_H_SM_9713: need to check validity at this MH'
   endif
 
@@ -347,7 +347,7 @@ module theory_XS_SM_functions
 
   call check_range('TEV ',x,rangeok,badvalue,strict)
   if((x.lt.100.0D0).or.(x.gt.200.0D0))then
-   !stop'function XS_gg_H_SM_9674: need to check validity at this MH'
+   !stop  'function XS_gg_H_SM_9674: need to check validity at this MH'
    write(*,*)'WARNING: function XS_gg_H_SM_9674: need to check validity at this MH'
   endif
 
diff -rupN darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/usefulbits.f90 ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/usefulbits.f90
--- darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/usefulbits.f90	2013-02-11 06:11:43.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/usefulbits.f90	2018-07-04 22:31:57.234495877 +0100
@@ -288,7 +288,7 @@ module usefulbits
       if(abs(value-array(i)).le.small) output = 1
     enddo
   else 
-    stop'error: Passing an unallocated array to subroutine iselementofarray!'
+    stop 'error: Passing an unallocated array to subroutine iselementofarray!'
   endif
 
  end subroutine iselementofarray
@@ -298,7 +298,7 @@ module usefulbits
  !**********************************************************
    integer :: x
 
-   if(ubound(np,dim=1).ne.4)stop'error: have made a mistake in subroutine fill_pdesc (1)'
+   if(ubound(np,dim=1).ne.4) stop 'error: have made a mistake in subroutine fill_pdesc (1)'
 
    x=0
    allocate(  pdesc(  ubound(np,dim=1) )  )
@@ -319,7 +319,7 @@ module usefulbits
    pdesc(x)%short='C'
    pdesc(x)%long ='chargino'
 
-   if(x.ne.ubound(np,dim=1))stop'error: have made a mistake in subroutine fill_pdesc (2)'
+   if(x.ne.ubound(np,dim=1)) stop 'error: have made a mistake in subroutine fill_pdesc (2)'
 
  end subroutine fill_pdesc
  !**********************************************************            
@@ -344,7 +344,7 @@ module usefulbits
     np_t(x)=1
    else
     write(*,*)'np=',np
-    stop'error in subroutine allocate_dataset_parts (1)'
+    stop 'error in subroutine allocate_dataset_parts (1)'
    endif
   enddo
 
@@ -353,7 +353,7 @@ module usefulbits
   elseif(n_addit.eq.0)then
     n_add=1
   else
-    stop'error in subroutine allocate_dataset_parts (2)'
+    stop 'error in subroutine allocate_dataset_parts (2)'
   endif
 
   do x=lbound(d,dim=1),ubound(d,dim=1)
@@ -515,7 +515,7 @@ module usefulbits
    enddo
   case('onlyL')
   case default
-   stop'error in allocate_dataset_parts (3)'
+   stop 'error in allocate_dataset_parts (3)'
   end select
   deallocate(np_t)
  end subroutine allocate_dataset_parts
@@ -537,7 +537,7 @@ module usefulbits
   elseif(np(Hneut).eq.0)then
     nHiggsneut=1
   else
-    stop'error in subroutine allocate_sqcouplratio_parts (1)'
+    stop 'error in subroutine allocate_sqcouplratio_parts (1)'
   endif
 
   do x=lbound(gsq,dim=1),ubound(gsq,dim=1) 
@@ -617,7 +617,7 @@ module usefulbits
   elseif(np(Hneut).eq.0)then
     nHiggsneut=1
   else
-    stop'error in subroutine allocate_hadroncolliderextras_parts (1)'
+    stop 'error in subroutine allocate_hadroncolliderextras_parts (1)'
   endif
 
   tR%nq_hjWp=2 ! (u dbar), (c sbar)  e.g
@@ -785,7 +785,7 @@ module usefulbits
    enddo 
   case('onlyL')
   case default 
-   stop'error in deallocate_usefulbits'
+   stop 'error in deallocate_usefulbits'
   end select 
   
   deallocate(theo) !allocated in subroutine do_input  
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/aldata.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/aldata.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/aldata.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/aldata.f	2018-07-04 22:31:57.234495877 +0100
@@ -155,8 +155,8 @@ C          LUXSET=.TRUE. after RLUXGO ha
      $GOWW(25,2),ALLWW(2),GOWMOD(25,MXGOJ)
       SAVE /Q1Q2/
       LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
-      COMMON/SEED/XSEED
-      SAVE /SEED/
+      COMMON/SEEDg/XSEED
+      SAVE /SEEDg/
       CHARACTER*24 XSEED
 C          SUSY parameters
 C          AMGLSS               = gluino mass
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/func.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/func.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/func.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/func.f	1970-01-01 01:00:00.000000000 +0100
@@ -1,189 +0,0 @@
-
-******************************************************************
-******************************************************************
-******************************************************************
-      FUNCTION FUNC(X)
-
-
-      IMPLICIT NONE
-      
-      CHARACTER*6 PINF,PN1,PN2
-      REAL*8 A
-      COMMON/VARS/A(1800)
- 
-      COMMON /CTRL/
-     &AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX,
-     &NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-
-      REAL*8 AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX
-      INTEGER NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-      
-      REAL*8 X(25)
-      REAL*8 P(0:3,4)
-
-      REAL*8 RR,SN,PI,GEVTOPBN,FUNC,ds_da_dc,AS_MIN,PM,E,XMASS,Z,
-     &COS1, PM1,PM2,PM3,PM4,SIN1,SFACT,CFACT,TFACT,B1,B2,FA,AS,DJACOB,
-     &ECM,XFA,FA12,E1,E2,R1,R2,E3,R3,E4,R4,F_PS,FA12_integr,FUNC_TMP,
-     &SQME
-     
-      INTEGER I
-      
-      RR(E,XMASS)  = SQRT(MAX(0d0,(E-XMASS)*(E+XMASS)))
-      SN(Z)        = SQRT(MAX(0d0,(1-z)*(1+z)))
-      
-      
-      PI=DACOS(-1d0)
-      GEVTOPBN= 0.3893796623*1.E+09      
-      
-      FUNC=0.
-      ds_da_dc=0.
-      
-
- 
-      AS_MIN=2d0
-      PM=abs(A(93))
-C------------------------------------------ 
-      COS1=1d0-2d0*X(1)
-
-
-      IF(COS1.gt.COS_MAX) goto 999
-      IF(COS1.lt.cos_min) goto 999
-      SIN1=SN(COS1)
-
-
-C------------------------------------------      
-	
-      DO I =NPROC_MIN,NPROC_MAX,NPROC_STEP
-        
-        CALL PMAS(I,1,PM1)
-        CALL PMAS(I,2,PM2)
-	IF(ABS(PM1/PM).gt.SUPPEXPMAX.or.ABS(PM2/PM).gt.SUPPEXPMAX) 
-     >  goto 900
-        CALL PMAS(I,3,PM3)
-        CALL PMAS(I,4,PM4)
-	
-	PN1=PINF(I,1)
-        PN2=PINF(I,2)
-	SFACT=1.
-	CFACT=1.
-
-	IF(PN1.ne.PN2) SFACT=2.
-
-	IF(PN1.ne.'~o1'.and.PN1.ne.'~o2'.and.PN1.ne.'~g')  CFACT=2.
-	IF(PN2.ne.'~o1'.and.PN2.ne.'~o2'.and.PN2.ne.'~g')  CFACT=2.
-	
-	IF(PN1.eq.'~1+'.and.PN2.eq.'~1-')  CFACT=1.
-	
-	IF(PN1.eq.'~e1'.and.PN2.eq.'~E1')  CFACT=1.
-	IF(PN1.eq.'~e2'.and.PN2.eq.'~E2')  CFACT=1.
-	IF(PN1.eq.'~e3'.and.PN2.eq.'~E3')  CFACT=1.
-	IF(PN1.eq.'~n1'.and.PN2.eq.'~N1')  CFACT=1.
-	IF(PN1.eq.'~n2'.and.PN2.eq.'~N2')  CFACT=1.
-	IF(PN1.eq.'~n3'.and.PN2.eq.'~N3')  CFACT=1.
-	IF(PN1.eq.'~u1'.and.PN2.eq.'~U1')  CFACT=1.
-	IF(PN1.eq.'~d1'.and.PN2.eq.'~D1')  CFACT=1.
-	IF(PN1.eq.'~c1'.and.PN2.eq.'~C1')  CFACT=1.
-	IF(PN1.eq.'~s1'.and.PN2.eq.'~S1')  CFACT=1.
-	IF(PN1.eq.'~t1'.and.PN2.eq.'~T1')  CFACT=1.
-	IF(PN1.eq.'~b1'.and.PN2.eq.'~B1')  CFACT=1.
-	
-	TFACT=SFACT*CFACT
-	
-     
-      
-	
-	pm1=abs(pm1)
-	pm2=abs(pm2)
-	pm3=abs(pm3)
-	pm4=abs(pm4)
-	
-      
-	
-	B1=pm1/pm
-	B2=pm2/pm
-        
-	
-     
-        IF(NDIMUSER.eq.1) then
-          FA=1.
-          AS=AS_MAX
-          DJACOB=2.
-        ELSEIF(NDIMUSER.ge.2) then
-	
-          AS=AS_MIN+(AS_MAX-AS_MIN)*X(2)
-          DJACOB=(AS_MAX-AS_MIN)*2.
-	  IF(AS.le.b1+b2) goto 900
-	  
-	  IF(NDIMUSER.eq.2) THEN
-	      FA=FA12(AS,I,XF)
-	      
-	    
-	  ELSEIF(NDIMUSER.eq.3.and.NDIMUSER_EFF.eq.2) THEN
-	
-   	      FA=FA12_integr(AS,b1,b2,XF)*
-     &        ((AS**2-b1**2-b2**2)**2-4.*b1**2*b2**2)
-     &        /sqrt(AS)/(2.*sqrt(2.*pi)*b1**(3./2.)*b2**(3./2.))
-
-         
-          ELSEIF(NDIMUSER.eq.3.and.NDIMUSER_EFF.eq.3) THEN
-	      XFA=X(3)
-	      FA=FA12(AS,I,XFA)
-	      
-          ENDIF
-      
-        ENDIF
-	
-         
-        ECM=AS*PM
-        IF(ECM.GT.max(PM1+PM2,PM3+PM4)) then
-	
-	
-          E1=(ECM+(PM1-PM2)*(PM1+PM2)/ECM)/2D0
-          E2=(ECM+(PM2-PM1)*(PM1+PM2)/ECM)/2D0
-          R1=RR(E1,PM1)
-          R2=R1
- 	
-          P(0,1)=E1
-          P(1,1)=0.
-          P(2,1)=0.
-          P(3,1)=-R1
-          P(0,2)=E2
-          P(1,2)=0.
-          P(2,2)=0.
-          P(3,2)=R1
-	
-          E3=(ECM+(PM3-PM4)*(PM3+PM4)/ECM)/2D0
-          R3=RR(E3,PM3)
-          E4=(ECM+(PM4-PM3)*(PM3+PM4)/ECM)/2D0
-          R4=R3
-
-          P(0,3)=E3
-          P(1,3)=R3*SIN1
-          P(2,3)=0.
-          P(3,3)=R3*COS1
-         
-	  P(0,4)=E4
-          P(1,4)=-P(1,3)
-          P(2,4)=0.
-          P(3,4)=-P(3,3)
-           
-       	 
-	  F_PS=R3/R1/(32d0*Pi*ECM**2)
-	  FUNC_TMP =TFACT*SQME(I,P)*F_PS*FA*DJACOB*GEVTOPBN
-          ds_da_dc=FUNC_TMP+ds_da_dc
-	  IF(I.eq.26.and.NDIMUSER.eq.3.and.NDIMUSER_EFF.eq.2) goto 999
-	  
-	  
-        ENDIF
-  900   CONTINUE     
-
-      ENDDO
-  999 FUNC=ds_da_dc
-       
-
-      IF(FUNC.le.1D-16) FUNC=1D-16
- 
-      return
-      end
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/func_int.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/func_int.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/func_int.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/func_int.f	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-
-
-C-------------------------------------------------------
-C#######################################################
-C-------------------------------------------------------
-
-      FUNCTION FUNC_INT(IPRINT)
-      IMPLICIT NONE
-C------- BASES COMMON BLOCKS ---------------------
-      
-      EXTERNAL FUNC
-      REAL*8  FUNC_INT,FUNC
-      
-      INTEGER NDIM,IG,MXDIM,NWILD,NCALL
-      REAL*8 XL,XU
-      PARAMETER (MXDIM = 50 )                                           
-      COMMON /BPARM1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,IG(MXDIM),NCALL    
-c      DATA NWILD/2/,NCALL/1000/      
-      INTEGER INTV, IPNT, NLOOP, MLOOP,ITMX1,ITMX2
-      REAL*8 ACC1,ACC2
-      COMMON /BPARM2/ ACC1,ACC2,ITMX1,ITMX2                             
-c      DATA  ITMX1/5/,ITMX2/5/,ACC1/0.1d0/,ACC2/0.1d0/
-      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP      
-c---------------------------------------------------
-      REAL*8 ESTIM, SIGMA, CTIME
-
-     
-      COMMON /CTRL/
-     &AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX,
-     &NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-
-      REAL*8 AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX
-      INTEGER NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-     
-      INTEGER I,IPRINT,IT1,IT2
-      
-      CALL BSINIT 
-      
-      ITMX1=5
-      ITMX2=5
-      NDIM =NDIMUSER_EFF
-      NWILD=NDIM
-      ACC1=1.
-      ACC2=1.
-      
-      DO 1 I=1,NDIMUSER_EFF
-        XL(I)=0d0
-        XU(I)=1d0
-    1 CONTINUE
-      XL(3)=0.000001
-      XU(3)=XF
-   
-c-------------------------------------------------
-
-      INTV=IPRINT
-      
-c       print *,'NCALLS=', NCALL,IPRINT,INTV,NPROC_MIN,NPROC_MAX
-      
-c      CALL BSINIT                                                  
-      CALL BASES( FUNC, ESTIM, SIGMA, CTIME, IT1, IT2 )             
-      
-      FUNC_INT=ESTIM
-      
-     
-      
-      RETURN
-      END
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/gettot.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/gettot.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/gettot.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/gettot.f	2018-07-04 22:31:57.234495877 +0100
@@ -77,8 +77,8 @@ C          Jet limits
       COMMON/IDRUN/IDVER,IDG(2),IEVT,IEVGEN
       SAVE /IDRUN/
       INTEGER   IDVER,IDG,IEVT,IEVGEN
-      COMMON/SEED/XSEED
-      SAVE /SEED/
+      COMMON/SEEDg/XSEED
+      SAVE /SEEDg/
       CHARACTER*24 XSEED
       COMMON/PRIMAR/NJET,SCM,HALFE,ECM,IDIN(2),NEVENT,NTRIES,NSIGMA,
      $WRTLHE
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/isared.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/isared.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/isared.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/isared.f	1970-01-01 01:00:00.000000000 +0100
@@ -1,391 +0,0 @@
-CDECK  ID>, ISARED.
-cccccccccccccccccccccccccccccccccccccccccccccc
-c      AUTHORS: Baer,Balazs,Belyaev
-c
-c      Last modification -> 10/27/2005 A.Belyaev
-c      Last modification -> 10/04/2007 A.Belyaev
-c      Last modification -> 12/06/2007 A.Belyaev -> sigma*v (v->0) added
-c
-cccccccccccccccccccccccccccccccccccccccccccccc
-     
-      SUBROUTINE ISARED(IPRT)
-c      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
-      IMPLICIT NONE
-      
-	
-c----------USER--------------------------------      
-      COMMON /CTRL/
-     &AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX,
-     &NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-
-      REAL*8 AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX
-      INTEGER NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-     
-
-      INTEGER IPRINT
-      
-      DATA   AS_MAX / 3D0 /, XFINI/0.05D0/, NDIMUSER/3/, NST_MAX/10/,
-     &      NPROC_MIN/1/,   NPROC_MAX/1820/, NPROC_STEP/1/, IPRINT/1/,
-     &      COS_MIN / -0.999999d0 / , COS_MAX / 0.999999d0 /,
-     &      CS_MIN  /0d0/, ISUM/1/, SUPPEXPMAX/2d0/
-     
-
-      common/printlevel/NPRINT
-      INTEGER NPRINT
-c-----------------------------------------------      
-      COMMON   /GOOD/    NNOGOOD,IALLOW 
-      INTEGER  NNOGOOD,IALLOW                                                                                                       
-c------BASES------------------------------------\
-     
-      INTEGER NDIM,IG,MXDIM,NWILD,NCALL
-      REAL*8 XL,XU
-   
-      PARAMETER (MXDIM = 50 )                                           
-      COMMON /BPARM1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,IG(MXDIM),NCALL    
-      DATA NWILD/2/,NCALL/1000/      
-      
-      INTEGER INTV, IPNT, NLOOP, MLOOP,ITMX1,ITMX2
-      REAL*8 ACC1,ACC2
-      COMMON /BPARM2/ ACC1,ACC2,ITMX1,ITMX2                             
-      DATA  ITMX1/5/,ITMX2/5/,ACC1/1d0/,ACC2/1d0/
-      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP                          
-c-----------------------------------------------
-      REAL*8 xb,g,pm
-      CHARACTER*6 names
-      INTEGER J,idof,IPTOT
-      COMMON /INPART/ xb(29),g(29),pm(29),idof(29),IPTOT
-      COMMON /NAMES/ names(29)
-
-      DATA IPTOT/29/
-      DATA  (IDOF(J),J=1,29)
-     _/  2,     2 ,     16,
-     _   2 ,	1 ,     1,      1,      3,     3, 
-     _  	1 ,     1 ,     1,      3,     3,    3,    3,
-     _   2 ,    1 ,     1,      1,      3,     3,
-     _  	1 ,     1 ,     1,      3,     3,    3,    3/
-
-     
-      DATA  (NAMES(J),J=1,29)
-     _/'~o1',  '~o2' ,'~g',
-     _  '~1-' ,'~e1' , '~e2' , '~e3' ,'~t1','~b1', 
-     _         '~n1' , '~n2' , '~n3' ,'~u1','~d1','~c1','~s1',
-     _  '~1+' ,'~E1' , '~E2' , '~E3' ,'~T1','~B1', 
-     _         '~N1' , '~N2' , '~N3' ,'~U1','~D1','~C1','~S1'/
-c-----------------------------------------------
-      REAL*4 OMGH2,SIGMA,XFREEZ,FFF_V
-      INTEGER NSTEPS
-      COMMON/SUGRED/ OMGH2,SIGMA,XFREEZ,NSTEPS,FFF_V
-c-----ISAJET-----------------------------------   
-      COMMON/SSLUN/LOUT,LHEOUT
-      INTEGER LOUT,LHEOUT
-      SAVE /SSLUN/
-C     XSUGIN contains the inputs to SUGRA:
-C     XSUGIN(1) = M_0        XSUGIN(2) = M_(1/2)  XSUGIN(3) = A_0
-C     XSUGIN(4) = tan(beta)  XSUGIN(5) = sgn(mu)  XSUGIN(6) = M_t
-C     XSUGIN(7) = SUG BC scale
-C     XGMIN(1) = LAM         XGMIN(2)  = M_MES    XGMIN(3)  = XN5
-C     XGMIN(4) = tan(beta)   XGMIN(5)  = sgn(mu)  XGMIN(6) = M_t
-C     XGMIN(7) = CGRAV       XGMIN(8)  =RSL       XGMIN(9)  = DEL_HD
-C     XGMIN(10)  = DEL_HU    XGMIN(11) = DY       XGMIN(12) = N5_1
-C     XGMIN(13)  = N5_2      XGMIN(14) = N5_3
-C     XNRIN(1) = M_N3        XNRIN(2) = M_MAJ     XNRIN(3) = ANSS 
-C     XNRIN(4) = M_N3SS
-C     XISAIN contains the MSSMi inputs in natural order.
-      COMMON /SUGXIN/ XISAIN(24),XSUGIN(7),XGMIN(14),XNRIN(4),
-     $XAMIN(11)
-      REAL XISAIN,XSUGIN,XGMIN,XNRIN,XAMIN
-      SAVE /SUGXIN/
-C          Frozen couplings from RG equations:
-C     GSS( 1) = g_1        GSS( 2) = g_2        GSS( 3) = g_3
-C     GSS( 4) = y_tau      GSS( 5) = y_b        GSS( 6) = y_t
-C     GSS( 7) = M_1        GSS( 8) = M_2        GSS( 9) = M_3
-C     GSS(10) = A_tau      GSS(11) = A_b        GSS(12) = A_t
-C     GSS(13) = M_hd^2     GSS(14) = M_hu^2     GSS(15) = M_er^2
-C     GSS(16) = M_el^2     GSS(17) = M_dnr^2    GSS(18) = M_upr^2
-C     GSS(19) = M_upl^2    GSS(20) = M_taur^2   GSS(21) = M_taul^2
-C     GSS(22) = M_btr^2    GSS(23) = M_tpr^2    GSS(24) = M_tpl^2
-C     GSS(25) = mu         GSS(26) = B          GSS(27) = Y_N
-C     GSS(28) = M_nr       GSS(29) = A_n        GSS(30) = vdq
-C     GSS(31) = vuq
-C          Masses:
-C     MSS( 1) = glss     MSS( 2) = upl      MSS( 3) = upr
-C     MSS( 4) = dnl      MSS( 5) = dnr      MSS( 6) = stl
-C     MSS( 7) = str      MSS( 8) = chl      MSS( 9) = chr
-C     MSS(10) = b1       MSS(11) = b2       MSS(12) = t1
-C     MSS(13) = t2       MSS(14) = nuel     MSS(15) = numl
-C     MSS(16) = nutl     MSS(17) = el-      MSS(18) = er-
-C     MSS(19) = mul-     MSS(20) = mur-     MSS(21) = tau1
-C     MSS(22) = tau2     MSS(23) = z1ss     MSS(24) = z2ss
-C     MSS(25) = z3ss     MSS(26) = z4ss     MSS(27) = w1ss
-C     MSS(28) = w2ss     MSS(29) = hl0      MSS(30) = hh0
-C     MSS(31) = ha0      MSS(32) = h+
-C          Unification:
-C     MGUTSS  = M_GUT    GGUTSS  = g_GUT    AGUTSS  = alpha_GUT
-      COMMON /SUGMG/ MSS(32),GSS(31),MGUTSS,GGUTSS,AGUTSS,FTGUT,
-     $FBGUT,FTAGUT,FNGUT
-      REAL MSS,GSS,MGUTSS,GGUTSS,AGUTSS,FTGUT,FBGUT,FTAGUT,FNGUT
-      SAVE /SUGMG/
-      COMMON /SUGPAS/ XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
-     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ,
-     $FNMZ,AMNRMJ,NOGOOD,IAL3UN,ITACHY,MHPNEG,MHLNEG,MHCNEG,
-     $IGUTST,ASM3,
-     $VUMT,VDMT,ASMTP,ASMSS,M3Q,MHDSQ,MHUSQ,MHDSMG,MHUSMG,MUMG,BMG,
-     $FT2Z1,FB2Z1,FL2Z1
-      REAL XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
-     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ,
-     $FNMZ,AMNRMJ,ASM3,VUMT,VDMT,ASMTP,ASMSS,M3Q,MHDSQ,MHUSQ,
-     $MHDSMG,MHUSMG,MUMG,BMG,FT2Z1,FB2Z1,FL2Z1
-      INTEGER NOGOOD,IAL3UN,ITACHY,MHPNEG,MHLNEG,MHCNEG,IGUTST
-      SAVE /SUGPAS/
-c----------COMPHEP------------------------------      
-      COMMON/VARS/A(1800)
-      REAL*8 A
-c-----------------------------------------------      
-c-----------------------------------------------      
-      CHARACTER*6 PINF
-      REAL*8 PBNTOGEV,PI,SQRT_GN,FFF,XFI,XF_OLD,SUMM,GEFF,
-     &FUNC_INT,FFF_TMP,OMEGA,FFF_OLD
-      
-      INTEGER IPRT,NPROC_MAX_S,NPROC_MIN_S,IPM,IDEL,
-     &NDIMUSER_SAVE,NST,NDIMUSER_EFF_SAVE, NCALL_SAV,I
-    
-      
-c-----------------------------------------------      
-      REAL*8 del(29)
-    
-      REAL*8 vvv,AS_MAX_SAVE,conv1,conv2,CS_V
-      
-      
-      IPRINT=IPRT
-      NPRINT=IPRINT
-      
-      XF=XFINI
-      FFF=0d0
-	
-      SQRT_GN=dsqrt(67.07d0)/1d+20
-      PBNTOGEV=1d0/0.3893796623/1d+09	
-       
-      Pi=DACOS(-1d0)
-      
-      FFF=0
-      NNOGOOD=0
-      
-      call vini
-***************************
-
-      call isachp
-
-*****************************
-! Z1,Z2,W1, e1, e2, e3, n1,n2,n3,u1,d1,c1,s1,t1,b1,gss
-****************************
-	PM(1)=abs(A(93))   	!neutr1
-        PM(2)=abs(A(95))   	!neutr2
-        PM(3)=abs(A(131))  	!gluino
-	
-        PM(4)=abs(A(89))   	!charg
-        PM(5)=abs(A(132))  	!sel
-        PM(6)=abs(A(134))  	!smu
-        PM(7)=abs(A(106))  	!sta
-        PM(8)=abs(A(122))   	!stop
-        PM(9)=abs(A(126))  	!sbot
-	
-   	
-        PM(10)=abs(A(136))  	!snu_e
-        PM(11)=abs(A(137))  	!snu_l
-        PM(12)=abs(A(112))  	!snu_tau
-        PM(13)=abs(A(138))  	!sup1
-        PM(14)=abs(A(140))  	!sd_1
-        PM(15)=abs(A(142))  	!sc1
-        PM(16)=abs(A(144))  	!ss_1
-	
-        PM(17)=	PM(4)		!charg
-        PM(18)=	PM(5)  		!sel
-        PM(19)=	PM(6)  		!smu
-        PM(20)=	PM(7)  		!sta
-        PM(21)=	PM(8)		!stop
-        PM(22)=	PM(9)  		!sbot
-	
- 
-        PM(23)=	PM(10)  	!snu_e
-        PM(24)=	PM(11)  	!snu_l
-        PM(25)=	PM(12)  	!snu_tau
-        PM(26)=	PM(13)  	!sup1
-        PM(27)=	PM(14)  	!sd_1
-        PM(28)=	PM(15)  	!sc1
-        PM(29)=	PM(17)  	!ss_1
-***********************************************      
-
- 
-      SUPPEXP=1E+20
- 
-      DO IPM=2,IPTOT
-        if(min(pm(IPM),PM(1)).ne.pm(1).and.iallow.eq.0) then
-          iallow=-11 !NEUTR IS NOT THE LIGHTEST
-          if(iprt.gt.2) print *,'Z1 IS NOT LSP',IPM,PM(IPM),PM(1)
-          NNOGOOD=5
-          goto 555
-          ENDIF 
-          SUPPEXP=min(SUPPEXP,pm(IPM)/pm(1))
-      ENDDO
-
-      geff=0d0
-      DO IDEL=1,IPTOT
-        del(idel)=(pm(idel)-pm(1))/pm(1)
-        geff=geff+ 2. * (1.+del(IDEL))**(3./2.) * Exp(-del(idel)/XF)
-        if(iprint.gt.2) 
-     &print *,  (1.+del(IDEL))**(3./2.) * Exp(-del(idel)/XF), del(idel)
-      ENDDO
-      IF(IPRINT.gt.1) print *,'GEFF=', GEFF,'   ','SUPPEXP=',SUPPEXP
-      NDIMUSER_EFF=NDIMUSER
-      IF(SUPPEXP.ge.SUPPEXPMAX.and.NDIMUSER.eq.3)  NDIMUSER_EFF=2 
-      if(iprint.gt.2) 
-     & print *, 'NDIMUSER_EFF=', NDIMUSER_EFF,SUPPEXP
-     
-
-cccccccccccccccccc    
-c      goto 111
-
-      NST=0
-      NDIMUSER_SAVE=NDIMUSER
-      NDIMUSER_EFF_SAVE=NDIMUSER_EFF
-c       print *,'ISARED:', NPROC_MIN,NPROC_MAX
-
-      IF(NDIMUSER.ge.2) NDIMUSER=2
-      NDIMUSER_EFF=NDIMUSER
-      NCALL_SAV=NCALL
-      NCALL=NCALL/2.
-888   continue
-      NST=NST+1
-      IF(NST.GT.NST_MAX) goto 666
-      
-      IPRINT=IPRT
-c--------------------	
-      FFF_OLD=FFF  
-      FFF=FUNC_INT(IPRINT)
-      IF(FFF.lt.CS_MIN) GOTO  666
-c--------------------	  
-
-      IF(NDIMUSER_SAVE.eq.2) GOTO 777
-      if(IPRT.gt.1) print *,'FFF0=', FFF
-
-        
-      IF(FFF.le.0) then
-         FFF=0.
-         goto 666
-      ENDIF
-
-
-       XFI=LOG(
-     &     PM(1)/(2d0*Pi**3)*geff/2d0*sqrt(45d0/(2d0*81d0))/SQRT_GN
-     &     *FFF*PBNTOGEV*SQRT(XF)
-     &     )
-       
-
-       XF_OLD=XF
-       XF=1D0/XFI
-       
-
-
-       IF(iprint.gt.1) then
-       print *,'======================='
-       print *,'XF = ',XF,1d0/XF
-       print *,'CS  = ',FFF
-       print *,'NST = ',NST
-       print *,'======================='
-       endif
-
-       IF(XF.le.0.) then
-         XF=XFINI
-         FFF=0
-         goto 666
-       ENDIF
-
-ccc       IF(abs(XF-XF_OLD)/XF.gt.0.01) goto 888
-       IF(abs(FFF-FFF_OLD)/FFF.gt.0.03) goto 888
-ccc    print *,'xxxxxxxx 3d Integration xxxxxxxxxx'
- 777   CONTINUE
- 666   NCALL=NCALL*2.
-       NDIMUSER=NDIMUSER_SAVE
-       NDIMUSER_EFF=NDIMUSER_EFF_SAVE
-       IF(NDIMUSER.eq.2    ) goto 999
-       IF(NDIMUSER_EFF.eq.2) NCALL=NCALL/2.
-
-       IF(FFF.lt.CS_MIN) THEN
-          FFF=1.E-20
-          GOTO 999
-       ENDIF
-
-
-       FFF=FUNC_INT(IPRINT)
- 999   continue
-  
-c      print *,'IPRINT=',IPRINT
-       IF(IPRINT.ge.3) then
-         NPROC_MAX_S=NPROC_MAX
-         NPROC_MIN_S=NPROC_MIN
-         SUMM=0.
-         
-         
-         DO I =NPROC_MIN_S,NPROC_MAX_S,NPROC_STEP
-           if(SUPPEXP.ge.SUPPEXPMAX.and.I.gt.26) GOTO 444
-           NPROC_MIN=I
-           NPROC_MAX=I
-           FFF_TMP=FUNC_INT(-1)
-           IF(FFF_TMP/FFF.gt.0.01) THEN
-             print '(I6,A4,F6.2,A2,4A8)',
-     &       I,'  ',FFF_TMP/FFF*100,' %',
-     &       (PINF(I,J),J=1,4)
-             SUMM=SUMM+FFF_TMP/FFF
-           ENDIF
-         ENDDO
- 444     continue	 
-
-         NPROC_MAX=NPROC_MAX_S
-         NPROC_MIN=NPROC_MIN_S
-       endif
-
-      
- 
- 555   continue
-       if(iprint.gt.1) then
-       print *,'===========FINAL======='
-       print *, 'freez out temp=',1d0/XF
-       print *, 'n steps       =',NST
-       print *, 'CS (fb)       =',FFF*1000d0
-       print *, 'OMEGA H^2     =',OMEGA(FFF)
-       print *,'======================='
-       endif
-
-       OMGH2 =OMEGA(FFF)
-       SIGMA =FFF
-       XFREEZ=XF
-       NSTEPS =NST
-
-       NCALL=NCALL_SAV
-      
-cccccccccccccccccccccccccccccccccccccccccccc
- 111   continue
-       NDIMUSER_SAVE=NDIMUSER
-       AS_MAX_SAVE  =AS_MAX
-       NDIMUSER=1
-       NDIMUSER_EFF=1
-
-       
-       VVV=1.E-03
-       AS_MAX=2.*sqrt(1.+(VVV/2.)**2)  
-       CONV1 =  2.998E+10  ! speed of light cm/sec
-       CONV2 =  1.000E-36  ! 1pb ==> cm^2
-
-       CS_V  =  FUNC_INT(IPRINT)
-       FFF_V =  CS_V*VVV*CONV1*CONV2
-
-       NDIMUSER=NDIMUSER_SAVE
-       AS_MAX=AS_MAX_SAVE
-       
-
-cccccccccccccccccccccccccccccccccccccccccccc       
-
-      RETURN
-      END
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/makefile.in ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/makefile.in
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/makefile.in	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/makefile.in	2018-07-04 22:31:57.234495877 +0100
@@ -6,9 +6,6 @@
 FF=@F77@
 FOPT=@FOPT@
 
-DS_ROOT=../..
-LIB=$(DS_ROOT)/lib
-
 ########################################################
 ### READ THROUGH AND CHANGE THE DEFAULT VALUES BELOW ###
 ### BEFORE COMPILING.                                ###
@@ -20,21 +17,24 @@ LIB=$(DS_ROOT)/lib
 # to libisajet.a.
 # For compatibility with gfortran, aldata.o _is_ included here (after 'BLOCK DATA' has been changed to 'SUBROUTINE').
 
-OBJ = aldata.o alqcd.o amass.o amgmw.o ayukdiag.o b0func.o bases.o besk1.o bhinit.o bhplot.o bhrset.o bhsave.o bi.o bk2mvsm.o boostx.o brems.o bschck.o bsdate.o bsdims.o bsetgu.o bsetgv.o bsggut.o bsgrid.o bsinfo.o bsinit.o bsintg.o bslist.o bsordr.o bsparm.o bsprnt.o bsread.o bstcnv.o bstime.o bsutim.o bswrit.o bufin.o bufout.o c0.o cbk2mvsm.o ccon.o cdagger.o charge.o chargino.o chdec.o chint.o ci.o cmatmul.o cmd.o cmodsq.o colr12.o colr13.o colr22.o con.o coup1x.o coup2x.o coup3x.o coup4x.o cputim.o cre.o crge215.o crge601.o crkstp.o csfmul.o csmrgedr.o cteq5l.o ctq5pdf.o ctrace.o ctxc2i.o ctxi2c.o ctxin.o ctxout.o d0.o dadmul.o dagger.o dblpcm.o dblvec.o dboost.o dcabs1.o ddilog.o decay.o decjet.o decoutcoup.o decps1.o decps2.o decrun.o decss3.o dectau.o decva.o dhfill.o dhinit.o dhplot.o di.o diagsqm.o dincgm.o disnan.o dlabad.o dladiv.o dlaisnan.o dlamc1.o dlamc2.o dlamc3.o dlamc4.o dlamc5.o dlamch.o dlapy2.o dlapy3.o dmatmul.o domssm.o downmhcond.o downmhighmh.o downmhighmz.o downmscond.o downsqm.o dre.o drge215.o drge601.o drkstp.o drllyn.o drn.o drnset.o drotsq.o drotsqback.o dscal.o dsmma.o dsmrgedr.o dtrace.o dtrint.o dzasum.o dznrm2.o eaixxx.o eaoxxx.o ebeam.o edit.o eebeg.o eemax.o ei.o eigsys.o eisrs1.o elctrn.o epf.o estruc.o evol01.o evol02.o evol03.o evol05.o evol06.o evol07.o evol11.o evolms.o evolve.o fa12.o fa12_integr.o fbrbm.o fes.o flavor.o fntg.o fortop.o frgjet.o frgmnt.o fsixxx.o fsoxxx.o func.o func_int.o funs.o fvixxx.o fvoxxx.o gamma.o gammac1.o gammac2.o gammahp.o gammasm.o gammawb1.o gammawb2.o gamtot.o gbeam.o ges.o getpas.o getpt.o gettot.o ggggxx.o gggxxx.o gluneno.o gout601.o gstruc.o hdcyad.o hdcysy.o heavyx.o hermtest.o hevolv.o higgs.o highin.o hioxxx.o hsssxx.o hssxxx.o hvsxxx.o hvvxxx.o idamax.o idanti.o idgen.o ieeeck.o iframs.o ilaenv.o ilazlc.o inisap.o iosxxx.o iovxxx.o ipartns.o ipjset.o iprtns.o irmov0.o isaamu.o isabeg.o isabmm.o isabsg.o isachp.o isaend.o isaevt.o isahep.o isaini.o isajet.o isalha.o isalhd.o isalhe.o isared.o isares.o isasrt.o isawbg.o isawev.o isawig.o isawnd.o ispjet.o istrad.o iswdky.o itrans.o ixxxxx.o j3xxxx.o jeexxx.o jetgen.o jgggxx.o jggxxx.o jioxxx.o jssxxx.o jtioxx.o jvssxx.o jvsxxx.o jvvxxx.o jw3wxx.o jwwwxx.o kkgf1.o kkgf2.o kkgf3.o kmin.o label.o lboost.o logerr.o logic.o logmgm.o logmgy.o logmij.o logp.o logphi.o logphw.o logpt.o logqm.o logqt.o logthw.o logx.o logxw.o logyth.o logyw.o lsame.o lstsq.o mass.o masssqm.o mat2vec.o mbias.o mbset.o mginit.o mmamsb.o modsq.o mom2cx.o momntx.o movlev.o mprod2.o mprod2x.o mprod3.o mprod3x.o mprod4x.o mprod5x.o muljet.o nogood.o omega.o ordecr.o order.o orth.o outcoup.o oxxxxx.o pdgid.o piblbl.o piblbr.o pibrbr.o pielel.o pierer.o pillll.o pilllr.o pilrlr.o pinene.o pitltl.o pitltr.o pitrtr.o prtevt.o prtlim.o prtlst.o ptfun.o qcdini.o qcdint.o qcdinz.o qcdjet.o qcdt.o qcdz.o qfunc.o ranf.o ranfgt.o ranfmt.o ranfst.o ranlux.o rdbeg.o rdtape.o readin.o rejfrg.o rejjet.o remsf.o rend.o rescal.o reset.o rge157.o rgeflav.o rgens.o rgeread.o rkstp.o rotate.o rotate215.o rotatesm.o rotback.o rotback215.o rotbacksm.o rotsq.o rotsqback.o rotxxx.o rpdecy.o rpinf1.o rpinf2.o rpint1.o rpint2.o rpint3.o rpmain.o rpmoda.o rpnorm.o rprate.o rprtch.o setcon.o setdky.o seth.o sethss.o setkkg.o setnxt.o settyp.o setw.o sfmul.o shcler.o shfill.o shinit.o shplot.o shrset.o shupdt.o sig0l.o sig0r.o sig0s.o sigdy.o sigdy2.o sigee.o sigfil.o siggam.o sigh.o sigh2.o sigh3.o sighss.o sigint.o sigkkg.o sigpl.o sigpr.o sigps.o sigqcd.o sigsse.o sigssl.o sigssy.o sigssz.o sigtc.o sigtc2.o sigtc3.o sigwh.o sigwhs.o sigww.o sigww2.o smszg.o sorttf.o sortth.o sortzg.o spchck.o sphist.o spinfo.o spline.o sprgen.o spring.o sqdiag.o sqrlam.o sqsix.o ssa0.o ssalfs.o ssb0.o ssb00.o ssb1.o ssb1f.o ssbt20.o ssbt22.o ssc0.o ssd0.o ssd27.o ssdhll.o ssdint.o ssdlam.o ssf.o ssf0.o ssfel.o ssg.o ssglbf.o ssgst.o ssgt.o ssgwq1.o ssgwq2.o ssgwt1.o ssgwt2.o ssgwt3.o ssgwt4.o ssgwt5.o ssgwt6.o ssgwt7.o ssgwt8.o ssgx1.o ssgx10.o ssgx11.o ssgx2.o ssgx3.o ssgx4.o ssgx5.o ssgx6.o ssgx7.o ssgx8.o ssgx9.o ssgzg1.o ssgzg2.o ssgzg3.o ssgzt.o ssh.o ssh0.o sshcc.o sshff.o sshff1.o sshgl.o sshgm.o sshgm1.o sshhx.o sshibf.o sshnn.o sshsf.o sshww.o sshww1.o sshww2.o ssl1st.o sslpbf.o sslrt1.o ssm1lp.o ssmass.o ssme3.o ssmhc.o ssmhn.o ssmqcd.o ssmssm.o ssn1st.o ssnorm.o sspole.o ssqkbf.o ssrsgb.o ssrsgl.o ssrsgt.o sssave.o sssnws.o ssssxx.o ssstbf.o sssvme.o sssxxx.o sstest.o sstpbf.o sswibf.o sswwf1.o sswz2p.o sswz3p.o sswzbf.o sswzf1.o sswzf2.o sswzf3.o sswzf4.o sswzf5.o sswzf6.o sswzf7.o ssxint.o ssxlam.o sszhx.o sszibf.o sszwf1.o sszzf1.o sszzf2.o sszzf3.o sszzf4.o sszzf5.o sszzg1.o sszzg2.o sszzg3.o sszzg4.o st1cneu.o st3int.o st3mat.o stbwz1.o stradd.o strotate.o strotback.o struc.o strucw.o sualfe.o sualfs.o sug2bsg.o sugeff.o sugefffl.o sugfrz.o sugmas.o sugra.o sugrge.o surg06.o surg26.o sxxxxx.o symmtest.o szjj1.o szjj2.o szjj3.o szjj4.o szjj5.o szjj6.o szjj7.o tactiv.o tcsfmul.o thetaxy.o timer.o tql2.o tqleig.o tr3x3.o trace.o trdiag.o tred2.o triint.o tsfmul.o twojet.o twokin.o uoutcoup.o upmhcond.o upmhcond2.o upmzmhigh.o upmzmhigh2.o upsqm.o usmma.o vec2mat.o vgen.o visaje.o vssxxx.o vvssxx.o vvsxxx.o vvvxxx.o vxxxxx.o w3w3xx.o wgens.o whiggs.o wilson.o wpair.o wwkin.o wwss.o wwst.o wwtt.o wwwwxx.o wzss.o wzst.o wzsu.o wztu.o xerbla.o xhchck.o xhfill.o xhinit.o xhordr.o xhplot.o xhrnge.o xhscle.o xkaim.o xkare.o xwwww.o xwwzz.o xzzww.o xzzzz.o ygenj.o yukdiag.o zaxpy.o zcopy.o zdotc.o zdotu.o zdscal.o zerol.o zgebak.o zgebal.o zgeev.o zgehd2.o zgehrd.o zgemm.o zgemv.o zgerc.o zhseqr.o zjj.o zjj0.o zjj1.o zjj2.o zjj3.o zjj4.o zjj5.o zjj6.o zjj7.o zlacgv.o zlacpy.o zladiv.o zlahqr.o zlahr2.o zlange.o zlaqr0.o zlaqr1.o zlaqr2.o zlaqr3.o zlaqr4.o zlaqr5.o zlarf.o zlarfb.o zlarfg.o zlarft.o zlartg.o zlascl.o zlaset.o zlassq.o zlatrs.o zrot.o zscal.o zswap.o ztrevc.o ztrexc.o ztrmm.o ztrmv.o ztrsv.o zung2r.o zunghr.o zungqr.o zunm2r.o zunmhr.o zunmqr.o zzall.o zzstar.o
+OBJ = aldata.o alqcd.o amass.o amgmw.o ayukdiag.o b0func.o bases.o besk1.o bhinit.o bhplot.o bhrset.o bhsave.o bi.o bk2mvsm.o boostx.o brems.o bschck.o bsdate.o bsdims.o bsetgu.o bsetgv.o bsggut.o bsgrid.o bsinfo.o bsinit.o bsintg.o bslist.o bsordr.o bsparm.o bsprnt.o bsread.o bstcnv.o bstime.o bsutim.o bswrit.o bufin.o bufout.o c0.o cbk2mvsm.o ccon.o cdagger.o charge.o chargino.o chdec.o chint.o ci.o cmatmul.o cmd.o cmodsq.o colr12.o colr13.o colr22.o con.o coup1x.o coup2x.o coup3x.o coup4x.o cputim.o cre.o crge215.o crge601.o crkstp.o csfmul.o csmrgedr.o cteq5l.o ctq5pdf.o ctrace.o ctxc2i.o ctxi2c.o ctxin.o ctxout.o d0.o dadmul.o dagger.o dblpcm.o dblvec.o dboost.o dcabs1.o ddilog.o decay.o decjet.o decoutcoup.o decps1.o decps2.o decrun.o decss3.o dectau.o decva.o dhfill.o dhinit.o dhplot.o di.o diagsqm.o dincgm.o disnan.o dlabad.o dladiv.o dlaisnan.o dlamc1.o dlamc2.o dlamc3.o dlamc4.o dlamc5.o dlamch.o dlapy2.o dlapy3.o dmatmul.o domssm.o downmhcond.o downmhighmh.o downmhighmz.o downmscond.o downsqm.o dre.o drge215.o drge601.o drkstp.o drllyn.o drn.o drnset.o drotsq.o drotsqback.o dscal.o dsmma.o dsmrgedr.o dtrace.o dtrint.o dzasum.o dznrm2.o eaixxx.o eaoxxx.o ebeam.o edit.o eebeg.o eemax.o ei.o eigsys.o eisrs1.o elctrn.o epf.o estruc.o evol01.o evol02.o evol03.o evol05.o evol06.o evol07.o evol11.o evolms.o evolve.o fa12_integr.o fbrbm.o fes.o flavor.o fntg.o fortop.o frgjet.o frgmnt.o fsixxx.o fsoxxx.o funs.o fvixxx.o fvoxxx.o gamma.o gammac1.o gammac2.o gammahp.o gammasm.o gammawb1.o gammawb2.o gamtot.o gbeam.o ges.o getpas.o getpt.o gettot.o ggggxx.o gggxxx.o gluneno.o gout601.o gstruc.o hdcyad.o hdcysy.o heavyx.o hermtest.o hevolv.o higgs.o highin.o hioxxx.o hsssxx.o hssxxx.o hvsxxx.o hvvxxx.o idamax.o idanti.o idgen.o ieeeck.o iframs.o ilaenv.o ilazlc.o inisap.o iosxxx.o iovxxx.o ipartns.o ipjset.o iprtns.o irmov0.o isaamu.o isabeg.o isabmm.o isabsg.o isachp.o isaend.o isaevt.o isahep.o isaini.o isajet.o isalha.o isalhd.o isalhe.o isares.o isasrt.o isawbg.o isawev.o isawig.o isawnd.o ispjet.o istrad.o iswdky.o itrans.o ixxxxx.o j3xxxx.o jeexxx.o jetgen.o jgggxx.o jggxxx.o jioxxx.o jssxxx.o jtioxx.o jvssxx.o jvsxxx.o jvvxxx.o jw3wxx.o jwwwxx.o kkgf1.o kkgf2.o kkgf3.o kmin.o label.o lboost.o logerr.o logic.o logmgm.o logmgy.o logmij.o logp.o logphi.o logphw.o logpt.o logqm.o logqt.o logthw.o logx.o logxw.o logyth.o logyw.o lsame.o lstsq.o mass.o masssqm.o mat2vec.o mbias.o mbset.o mginit.o mmamsb.o modsq.o mom2cx.o momntx.o movlev.o mprod2.o mprod2x.o mprod3.o mprod3x.o mprod4x.o mprod5x.o muljet.o nogood.o omega.o ordecr.o order.o orth.o outcoup.o oxxxxx.o pdgid.o piblbl.o piblbr.o pibrbr.o pielel.o pierer.o pillll.o pilllr.o pilrlr.o pinene.o pitltl.o pitltr.o pitrtr.o prtevt.o prtlim.o prtlst.o ptfun.o qcdini.o qcdint.o qcdinz.o qcdjet.o qcdt.o qcdz.o qfunc.o ranf.o ranfgt.o ranfmt.o ranfst.o ranlux.o rdbeg.o rdtape.o readin.o rejfrg.o rejjet.o remsf.o rend.o rescal.o reset.o rge157.o rgeflav.o rgens.o rgeread.o rkstp.o rotate.o rotate215.o rotatesm.o rotback.o rotback215.o rotbacksm.o rotsq.o rotsqback.o rotxxx.o rpdecy.o rpinf1.o rpinf2.o rpint1.o rpint2.o rpint3.o rpmain.o rpmoda.o rpnorm.o rprate.o rprtch.o setcon.o setdky.o seth.o sethss.o setkkg.o setnxt.o settyp.o setw.o sfmul.o shcler.o shfill.o shinit.o shplot.o shrset.o shupdt.o sig0l.o sig0r.o sig0s.o sigdy.o sigdy2.o sigee.o sigfil.o siggam.o sigh.o sigh2.o sigh3.o sighss.o sigint.o sigkkg.o sigpl.o sigpr.o sigps.o sigqcd.o sigsse.o sigssl.o sigssy.o sigssz.o sigtc.o sigtc2.o sigtc3.o sigwh.o sigwhs.o sigww.o sigww2.o smszg.o sorttf.o sortth.o sortzg.o spchck.o sphist.o spinfo.o spline.o sprgen.o spring.o sqdiag.o sqrlam.o sqsix.o ssa0.o ssalfs.o ssb0.o ssb00.o ssb1.o ssb1f.o ssbt20.o ssbt22.o ssc0.o ssd0.o ssd27.o ssdhll.o ssdint.o ssdlam.o ssf.o ssf0.o ssfel.o ssg.o ssglbf.o ssgst.o ssgt.o ssgwq1.o ssgwq2.o ssgwt1.o ssgwt2.o ssgwt3.o ssgwt4.o ssgwt5.o ssgwt6.o ssgwt7.o ssgwt8.o ssgx1.o ssgx10.o ssgx11.o ssgx2.o ssgx3.o ssgx4.o ssgx5.o ssgx6.o ssgx7.o ssgx8.o ssgx9.o ssgzg1.o ssgzg2.o ssgzg3.o ssgzt.o ssh.o ssh0.o sshcc.o sshff.o sshff1.o sshgl.o sshgm.o sshgm1.o sshhx.o sshibf.o sshnn.o sshsf.o sshww.o sshww1.o sshww2.o ssid.o ssl1st.o sslpbf.o sslrt1.o ssm1lp.o ssmass.o ssme3.o ssmhc.o ssmhn.o ssmqcd.o ssmssm.o ssn1st.o ssnorm.o sspole.o ssqkbf.o ssrsgb.o ssrsgl.o ssrsgt.o sssave.o sssnws.o ssssxx.o ssstbf.o sssvme.o sssxxx.o sstest.o sstpbf.o sswibf.o sswwf1.o sswz2p.o sswz3p.o sswzbf.o sswzf1.o sswzf2.o sswzf3.o sswzf4.o sswzf5.o sswzf6.o sswzf7.o ssxint.o ssxlam.o sszhx.o sszibf.o sszwf1.o sszzf1.o sszzf2.o sszzf3.o sszzf4.o sszzf5.o sszzg1.o sszzg2.o sszzg3.o sszzg4.o st1cneu.o st3int.o st3mat.o stbwz1.o stradd.o strotate.o strotback.o struc.o strucw.o sualfe.o sualfs.o sug2bsg.o sugeff.o sugefffl.o sugfrz.o sugmas.o sugra.o sugrge.o surg06.o surg26.o sxxxxx.o symmtest.o szjj1.o szjj2.o szjj3.o szjj4.o szjj5.o szjj6.o szjj7.o tactiv.o tcsfmul.o thetaxy.o timer.o tql2.o tqleig.o tr3x3.o trace.o trdiag.o tred2.o triint.o tsfmul.o twojet.o twokin.o uoutcoup.o upmhcond.o upmhcond2.o upmzmhigh.o upmzmhigh2.o upsqm.o usmma.o vec2mat.o vgen.o visaje.o vssxxx.o vvssxx.o vvsxxx.o vvvxxx.o vxxxxx.o w3w3xx.o wgens.o whiggs.o wilson.o wpair.o wwkin.o wwss.o wwst.o wwtt.o wwwwxx.o wzss.o wzst.o wzsu.o wztu.o xerbla.o xhchck.o xhfill.o xhinit.o xhordr.o xhplot.o xhrnge.o xhscle.o xkaim.o xkare.o xwwww.o xwwzz.o xzzww.o xzzzz.o ygenj.o yukdiag.o zaxpy.o zcopy.o zdotc.o zdotu.o zdscal.o zerol.o zgebak.o zgebal.o zgeev.o zgehd2.o zgehrd.o zgemm.o zgemv.o zgerc.o zhseqr.o zjj.o zjj0.o zjj1.o zjj2.o zjj3.o zjj4.o zjj5.o zjj6.o zjj7.o zlacgv.o zlacpy.o zladiv.o zlahqr.o zlahr2.o zlange.o zlaqr0.o zlaqr1.o zlaqr2.o zlaqr3.o zlaqr4.o zlaqr5.o zlarf.o zlarfb.o zlarfg.o zlarft.o zlartg.o zlascl.o zlaset.o zlassq.o zlatrs.o zrot.o zscal.o zswap.o ztrevc.o ztrexc.o ztrmm.o ztrmv.o ztrsv.o zung2r.o zunghr.o zungqr.o zunm2r.o zunmhr.o zunmqr.o zzall.o zzstar.o
 
 #OBJ2 = aldata.o
 
-vpath %.a $(LIB)
+vpath %.a $(DS_LIB)
 
 #all : libisajet.a aldata.o
-all : libisajet.a
+all : libisajet.a libisajet.so
 
 #aldata.o: aldata.f
-#	$(FF) $(FOPT) -c -o $(LIB)/aldata.o aldata.f
+#	$(FF) $(FOPT) -c -o $(DS_LIB)/aldata.o aldata.f
 
 libisajet.a: $(OBJ)
-	ar r $(LIB)/libisajet.a $(OBJ)
-	ranlib $(LIB)/libisajet.a
+	ar r $(DS_LIB)/libisajet.a $(OBJ)
+	ranlib $(DS_LIB)/libisajet.a
+
+libisajet.so: $(OBJ)
+	$(FF) $(FOPT) -shared -o $(DS_LIB)/libisajet.so $(OBJ)
 
 clean:
 	rm -f *.o
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/prtevt.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/prtevt.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/prtevt.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/prtevt.f	2018-07-04 22:31:57.234495877 +0100
@@ -84,8 +84,8 @@ C
       COMMON/WSIG/SIGLLQ
       SAVE /WSIG/
       REAL      SIGLLQ
-      COMMON/SEED/XSEED
-      SAVE /SEED/
+      COMMON/SEEDg/XSEED
+      SAVE /SEEDg/
       CHARACTER*24 XSEED
 C
 C          LABELS ARE CHARACTER*8
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/prtlim.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/prtlim.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/prtlim.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/prtlim.f	2018-07-04 22:31:57.234495877 +0100
@@ -79,8 +79,8 @@ C          KKGravity common
       COMMON/PRTOUT/NEVPRT,NJUMP
       SAVE /PRTOUT/
       INTEGER   NEVPRT,NJUMP
-      COMMON/SEED/XSEED
-      SAVE /SEED/
+      COMMON/SEEDg/XSEED
+      SAVE /SEEDg/
       CHARACTER*24 XSEED
       INTEGER MXTYPE
       PARAMETER (MXTYPE=8)
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/ranfgt.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/ranfgt.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/ranfgt.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/ranfgt.f	2018-07-04 22:31:57.238493877 +0100
@@ -1,4 +1,4 @@
 C
-      SUBROUTINE RANFGT(SEED)
+      SUBROUTINE RANFGT(SEEDg)
       RETURN
       END
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/ranfst.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/ranfst.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/ranfst.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/ranfst.f	2018-07-04 22:31:57.238493877 +0100
@@ -1,4 +1,4 @@
-      SUBROUTINE RANFST(SEED)
-      DOUBLE PRECISION SEED
+      SUBROUTINE RANFST(SEEDg)
+      DOUBLE PRECISION SEEDg
       RETURN
       END
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/readin.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/readin.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/readin.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/readin.f	2018-07-04 22:31:57.238493877 +0100
@@ -73,8 +73,8 @@ C          KKGravity common
       COMMON/PRTOUT/NEVPRT,NJUMP
       SAVE /PRTOUT/
       INTEGER   NEVPRT,NJUMP
-      COMMON/SEED/XSEED
-      SAVE /SEED/
+      COMMON/SEEDg/XSEED
+      SAVE /SEEDg/
       CHARACTER*24 XSEED
       INTEGER MXTYPE
       PARAMETER (MXTYPE=8)
@@ -230,7 +230,7 @@ C
       CHARACTER*8 HTYPE
       INTEGER JLIM1,JLIM2
       REAL AMLIM1,AMLIM2
-      DOUBLE PRECISION SEED
+      DOUBLE PRECISION SEEDg
 C
 C          Overlapping variable flags.
       DATA NLAP/1,2,3, 1,2,7 ,1,2,8, 1,3,5, 1,3,6, 1,3,7, 1,3,8, 1,5,7,
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/reset.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/reset.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/reset.f	2011-11-03 14:34:52.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/reset.f	2018-07-04 22:31:57.238493877 +0100
@@ -84,8 +84,8 @@ C          Jet limits
      $GOWW(25,2),ALLWW(2),GOWMOD(25,MXGOJ)
       SAVE /Q1Q2/
       LOGICAL GOQ,GOALL,GODY,STDDY,GOWW,ALLWW,GOWMOD
-      COMMON/SEED/XSEED
-      SAVE /SEED/
+      COMMON/SEEDg/XSEED
+      SAVE /SEEDg/
       CHARACTER*24 XSEED
 C          SUSY parameters
 C          AMGLSS               = gluino mass
diff -rupN darksusy-5.1.3/contrib/isajet781-for-darksusy/ssid.f ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/ssid.f
--- darksusy-5.1.3/contrib/isajet781-for-darksusy/ssid.f	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/contrib/isajet781-for-darksusy/ssid.f	2018-07-04 22:31:57.238493877 +0100
@@ -0,0 +1,80 @@
+      CHARACTER*5 FUNCTION SSID(ID)
+C-----------------------------------------------------------------------
+C
+C     Return character name for ID, assuming the default IDENT codes
+C     are used in /SSTYPE/.
+C
+C     Extracted by hand from ISAJET 1.8.5's isajet.car
+C     Pat Scott Feb 2 2016
+C
+C-----------------------------------------------------------------------
+      IMPLICIT NONE
+
+      COMMON/SSLUN/LOUT,LHEOUT
+      INTEGER LOUT,LHEOUT
+      SAVE /SSLUN/
+
+      CHARACTER*5 LABEL(-120:120)
+      SAVE LABEL
+      INTEGER ID,J
+C
+      DATA LABEL(0)/'     '/
+C
+      DATA (LABEL(J),J=1,10)
+     $/'UP   ','DN   ','ST   ','CH   ','BT   ','TP   '
+     $,'ERROR','ERROR','GL   ','GM   '/
+      DATA (LABEL(J),J=-1,-10,-1)
+     $/'UB   ','DB   ','SB   ','CB   ','BB   ','TB   '
+     $,'ERROR','ERROR','ERROR','ERROR'/
+C
+      DATA (LABEL(J),J=11,20)
+     $/'NUE  ','E-   ','NUM  ','MU-  ','NUT  ','TAU- '
+     $,'ERROR','ERROR','ERROR','ERROR'/
+      DATA (LABEL(J),J=-11,-20,-1)
+     $/'ANUE ','E+   ','ANUM ','MU+  ','ANUT ','TAU+ '
+     $,'ERROR','ERROR','ERROR','ERROR'/
+C
+      DATA (LABEL(J),J=21,30)
+     $/'UPL  ','DNL  ','STL  ','CHL  ','BT1  ','TP1  '
+     $,'ERROR','ERROR','GLSS ','Z1SS '/
+      DATA (LABEL(J),J=-21,-30,-1)
+     $/'UBL  ','DBL  ','SBL  ','CBL  ','BB1  ','TB1  '
+     $,'ERROR','ERROR','ERROR','ERROR'/
+C
+      DATA (LABEL(J),J=31,40)
+     $/'NUEL ','EL-  ','NUML ','MUL- ','NUTL ','TAU1-'
+     $,'ERROR','ERROR','W1SS+','Z2SS '/
+      DATA (LABEL(J),J=-31,-40,-1)
+     $/'ANUEL','EL+  ','ANUML','MUL+ ','ANUTL','TAU1+'
+     $,'ERROR','ERROR','W1SS-','ERROR'/
+C
+      DATA (LABEL(J),J=41,50)
+     $/'UPR  ','DNR  ','STR  ','CHR  ','BT2  ','TP2  '
+     $,'ERROR','ERROR','W2SS+','Z3SS '/
+      DATA (LABEL(J),J=-41,-50,-1)
+     $/'UBR  ','DBR  ','SBR  ','CBR  ','BB2  ','TB2  '
+     $,'ERROR','ERROR','W2SS-','ERROR'/
+C
+      DATA (LABEL(J),J=51,60)
+     $/'NUER ','ER-  ','NUMR ','MUR- ','NUTR ','TAU2-'
+     $,'ERROR','ERROR','ERROR','Z4SS '/
+      DATA (LABEL(J),J=-51,-60,-1)
+     $/'ANUEL','ER+  ','ANUMR','MUR+ ','ANUTR','TAU2+'
+     $,'ERROR','ERROR','ERROR','ERROR'/
+C
+      DATA (LABEL(J),J=82,86)
+     $/'HL0  ','HH0  ','HA0  ','ERROR','H+   '/
+      DATA LABEL(-86)/'H-   '/
+C
+      DATA LABEL(80)/'W+   '/,LABEL(-80)/'W-   '/,LABEL(90)/'Z0   '/
+      DATA LABEL(91)/'GVSS '/
+      DATA LABEL(110)/'PI0  '/
+      DATA LABEL(120)/'PI+  '/,LABEL(-120)/'PI-  '/
+C
+      IF(IABS(ID).GT.120) THEN
+        WRITE(LOUT,*) 'SSID: ID = ',ID
+        STOP99
+      ENDIF
+      SSID=LABEL(ID)
+      RETURN
+      END
diff -rupN darksusy-5.1.3/contrib/TSPACK/makefile.in ../installed/darksusy/5.1.3/contrib/TSPACK/makefile.in
--- darksusy-5.1.3/contrib/TSPACK/makefile.in	2013-02-10 06:43:34.000000000 +0000
+++ ../installed/darksusy/5.1.3/contrib/TSPACK/makefile.in	2018-07-04 22:31:57.238493877 +0100
@@ -9,8 +9,7 @@ FOPT=@FOPT@
 # Dependencies and libraries
 DINC=../../include
 LIB=../../lib
-
-INC_DEP = 
+BUILD=../../build/
 
 vpath %.h $(DINC)
 
@@ -19,12 +18,11 @@ tspack = ENDSLP.f SIGS.f SNHCSH.f STORE.
 
 all: tspack
 
-tspack : $(tspack) makefile
+tspack : 
 	cat $(tspack) > tspack.f
 	$(FF) $(FOPT) -c -I$(DINC) -o tspack.o tspack.f
+	mv tspack.o $(BUILD)/
 	rm tspack.f
-	ar rv $(LIB)/libdarksusy.a tspack.o
-	ranlib $(LIB)/libdarksusy.a
 
 clean:
 	rm -f tspack.f *.o
diff -rupN darksusy-5.1.3/HISTORY ../installed/darksusy/5.1.3/HISTORY
--- darksusy-5.1.3/HISTORY	2015-12-22 20:08:40.000000000 +0000
+++ ../installed/darksusy/5.1.3/HISTORY	2018-07-04 22:31:57.238493877 +0100
@@ -3,6 +3,12 @@ Version history for DarkSUSY
 
 ====================================================== VERSION HISTORY
 
+* Version 5.1.3.2 is created from version 5.1.3.1 and is for GAMBIT use.
+  The difference compared to 5.1.3.1 is that there is an option to
+  cut the relic density calculation if it takes too long time. There are
+  also more options for faster (and less accurate) relic density calculations.
+  These changes are the same as those in library_6plus/trunk rev. 1804.
+
 * Version 5.1.3 is created from version 5.1.2 with the changes from
   iclike2 merged in, i.e. the new IC likelihoods from December, 2015.
 
diff -rupN darksusy-5.1.3/include/dsandwcom.h ../installed/darksusy/5.1.3/include/dsandwcom.h
--- darksusy-5.1.3/include/dsandwcom.h	2010-08-06 09:27:44.000000000 +0100
+++ ../installed/darksusy/5.1.3/include/dsandwcom.h	2018-07-04 22:31:57.238493877 +0100
@@ -23,7 +23,7 @@ c....dwcom - common block needed for the
       save /dwcom1/,/dwcom2/
 
 * partial annihilation rates
-      real*8 prtial(54)
+      real*8 prtial(114)
       common /partials/ prtial
 
 ***                                                                 ***
diff -rupN darksusy-5.1.3/include/dsascom.h ../installed/darksusy/5.1.3/include/dsascom.h
--- darksusy-5.1.3/include/dsascom.h	2008-06-23 22:39:47.000000000 +0100
+++ ../installed/darksusy/5.1.3/include/dsascom.h	2018-07-04 22:31:57.238493877 +0100
@@ -44,10 +44,10 @@ c some roundoff terms
 
 c dsasdwdcossfsf final/intermediate state arrays/variables
       real*8  cfactini,cfactfin,gg1,gg2
-      integer kp1s,kp2s,kp3in(30),kp4in(30),chcol,nsfertc,ksfertc(6),
+      integer kp1s,kp2s,kp3in(114),kp4in(114),chcol,nsfertc,ksfertc(6),
      &  nsferuc,ksferuc(6),nsfertn,ksfertn(6),nsferun,ksferun(6),
      &  kf2,kf2o,ick1,ick2
-      logical chon(30),gluonin,gammain,neutcurr,nosneutrinov
+      logical chon(114),gluonin,gammain,neutcurr,nosneutrinov
       common/aswsfsfcom/cfactini,cfactfin,gg1,gg2,kp1s,kp2s,kp3in,kp4in,
      &  chcol,nsfertc,ksfertc,nsferuc,ksferuc,nsfertn,ksfertn,nsferun,
      &  ksferun,kf2,kf2o,ick1,ick2,chon,gluonin,gammain,neutcurr,
@@ -55,10 +55,10 @@ c dsasdwdcossfsf final/intermediate stat
 
 c dsasdwdcossfchi final/intermediate state arrays/variables
       real*8  gg1c,gg2c
-      integer kp1c,kp2c,ciaux,kcfers,ncfers,kcfersv(3),ncferd,kcferd(3),
-     & ncsfert,kcsfertn(2),ncsfertc,kcsfertc(6)
+      integer kp1c,kp2c,ciaux,ncfers,kcfersv(3),ncferd,kcferd(3),
+     & ncsfert,kcsfertn(6),ncsfertc,kcsfertc(6)
       logical cgammain,cgluonin
-      common/aswsfchicom/gg1c,gg2c,kp1c,kp2c,ciaux,kcfers,ncfers,
+      common/aswsfchicom/gg1c,gg2c,kp1c,kp2c,ciaux,ncfers,
      & kcfersv,ncferd,kcferd,ncsfert,kcsfertn,ncsfertc,kcsfertc,
      & cgammain,cgluonin
 
diff -rupN darksusy-5.1.3/include/dsdirver.h ../installed/darksusy/5.1.3/include/dsdirver.h
--- darksusy-5.1.3/include/dsdirver.h	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/include/dsdirver.h	2018-07-04 22:31:58.617803896 +0100
@@ -0,0 +1,22 @@
+*         -*- mode: fortran -*-
+*######################################################################*
+*                       i n c l u d e     f i l e                      *
+*######################################################################*
+
+************************************************************************
+***                           dsdirver.h                             ***
+***         this piece of code is needed as a separate file          ***
+***            the rest of the code 'includes' dsdirver.h            ***
+c----------------------------------------------------------------------c
+*** This file is created by config2.pl on Wed Jul  4 22:31:58 BST 2018
+
+      character*5 dsver
+      parameter(dsver='5.1.3')
+      character*51 dsinstall
+      parameter(dsinstall='/home/pat/gambit/Backends/installed/darksus'
+     & //'y/5.1.3/')
+      character*50 dsversion
+      common /dsv/dsversion
+      save /dsv/
+***                                                                  ***
+************************** end of dsdirver.h ***************************
diff -rupN darksusy-5.1.3/include/dsmssm.h ../installed/darksusy/5.1.3/include/dsmssm.h
--- darksusy-5.1.3/include/dsmssm.h	2013-01-31 21:46:16.000000000 +0000
+++ ../installed/darksusy/5.1.3/include/dsmssm.h	2018-07-04 22:31:57.238493877 +0100
@@ -140,9 +140,12 @@ c
       complex*16 neunmx(4,4),chaumx(2,2),chavmx(2,2),
      & slulmx(3,3),sldlmx(6,3),sldrmx(6,3),
      & squlmx(6,3),squrmx(6,3),sqdlmx(6,3),sqdrmx(6,3)
+      integer flavsortsqu(6),flavsortsqd(6),flavsortsl(6),
+     & flavsortsnu(3)
       common /mssmmixing/ neunmx,chaumx,chavmx,
      & slulmx,sldlmx,sldrmx,
-     & squlmx,squrmx,sqdlmx,sqdrmx,alpha,mix_stop,mix_sbot,mix_stau
+     & squlmx,squrmx,sqdlmx,sqdrmx,alpha,mix_stop,mix_sbot,mix_stau,
+     & flavsortsqu,flavsortsqd,flavsortsl,flavsortsnu ! see dsorder_flavour
 * msugra variables
       real*8 m0var,mhfvar,a0var,tgbetavar,sgnmuvar
       common/sugrainput/m0var,mhfvar,a0var,tgbetavar,sgnmuvar
diff -rupN darksusy-5.1.3/include/dsrdcom.h ../installed/darksusy/5.1.3/include/dsrdcom.h
--- darksusy-5.1.3/include/dsrdcom.h	2010-08-06 09:27:44.000000000 +0100
+++ ../installed/darksusy/5.1.3/include/dsrdcom.h	2018-07-04 22:31:57.238493877 +0100
@@ -58,9 +58,12 @@ c...rdlims
 c...rdswitch - switches
       integer thavint,rdprt
       common /rdswitch/thavint,rdprt
+c...rdtime - time of calculation
+      real*8 rdt_max,rdt_start,rdt_end
+      common /rdtime/rdt_max,rdt_start,rdt_end
 c....save common blocks
       save /rdmgev/,/rddof/,/rderrors/,/rdlun/,/rdrate/,/rdpth/,
-     &  /rdinfo/,/rdpars/,/rdpadd/,/rdlims/,/rdswitch/
+     &  /rdinfo/,/rdpars/,/rdpadd/,/rdlims/,/rdswitch/,/rdtime/
 ***                                                                 ***
 ************************** end of dsrdcom.h *****************************
 
diff -rupN darksusy-5.1.3/include/dswacom.h ../installed/darksusy/5.1.3/include/dswacom.h
--- darksusy-5.1.3/include/dswacom.h	2015-12-20 21:43:06.000000000 +0000
+++ ../installed/darksusy/5.1.3/include/dswacom.h	2018-07-04 22:31:57.242491877 +0100
@@ -18,30 +18,26 @@ c...to 52.
       integer wamax,walast(2),wanm
       parameter(wamax=6) ! number of tables to load simultaneously
       parameter(wanm=28) ! number of masses for tabulation
-      real*8 lb,ub,mi,thindex,zindex,dth,dz
-      real phiint,phidiff,phimixed
-      integer milow,thn,zn,yload
+      real*8 lb(14),ub(14),mi(wanm),thindex(-1:90,2),
+     &  zindex(-1:50,2),dth(-1:90),dz(-1:50)
+      real phiint(-1:90,0:50,wanm,13,2,wamax),
+     &  phidiff(-1:90,-1:50,wanm,13,2,wamax),
+     &  phimixed(-1:90,-1:50,wanm,13,2,wamax)
+      integer milow(14),thn,zn,yload(2,26)
       integer kind2ki(3)
       character*128 wadir
       character waftype
       character*40 wabase
-      common/wasim/lb(14),ub(14),mi(wanm),thindex(-1:90,2),
-     &  zindex(-1:50,2),dth(-1:90),dz(-1:50),
-     &  yload(2,26),walast,
-     &  milow(14),thn,zn,kind2ki,
+      common/wasim/lb,ub,mi,thindex,zindex,dth,dz,
+     &  yload,walast,
+     &  milow,thn,zn,kind2ki,
      &  wadir,waftype,wabase
-      common/wasim2/ phiint(-1:90,0:50,wanm,13,2,wamax),
-     &  phidiff(-1:90,-1:50,wanm,13,2,wamax),
-     &  phimixed(-1:90,-1:50,wanm,13,2,wamax)
+      common/wasim2/ phiint, phidiff, phimixed
 
 c...wagen - general stuff
       integer ch2chi(29),chi2chii(14),chii2chi(13),chi2ch(14)
       common /wagen/ch2chi,chi2chii,chii2chi,chi2ch
 
-c...wainfo - tag etc.
-      integer waerr,waistat
-      common/wainfo/waerr,waistat
-
 c...waopt - options
       real*8 wasbrmin
       common/waopt/wasbrmin
@@ -58,8 +54,7 @@ c...wabranch - annihilation branching ra
      &  wasv,wasigsip,wasigsdp,dswasetupcalled
 
 c save common block
-      save /wasim/,/wainfo/,/wasim2/,/wasim3/,/wagen/,
-     &  /wabranch/,/waopt/
+      save /wasim/,/wasim2/,/wasim3/,/wagen/,/wabranch/,/waopt/
 ***                                                                 ***
 ************************** end of muoncom.h ***************************
 
diff -rupN darksusy-5.1.3/include/FHCouplings.h ../installed/darksusy/5.1.3/include/FHCouplings.h
--- darksusy-5.1.3/include/FHCouplings.h	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/include/FHCouplings.h	2018-07-04 22:31:04.748751159 +0100
@@ -0,0 +1,149 @@
+#if 0
+	FHCouplings.h
+		human-readable indexing for the
+		couplings, gammas, and gammasms arrays
+		this file is part of FeynHiggs
+		last modified 11 May 12 th
+
+Note1: comments are real funny here because we want to include
+       this file in both Fortran and C
+
+Note2: for the same reason, the funny notation couplingS etc.
+       is used because we have to remap array indices in C and
+       Fortran does not care about caps.
+#endif
+
+
+#ifndef FHCOUPLINGS_H
+#define FHCOUPLINGS_H
+
+#define ncouplings 681
+#define Roffset 472
+#define Coupling(c)		couplingS(c)
+#define LCoupling(c)		couplingS(c)
+#define RCoupling(c)		couplingS(c+Roffset)
+
+#define ncouplingsms 231
+#define RSMoffset 108
+#define CouplingSM(c)		couplingsmS(c)
+#define LCouplingSM(c)		couplingsmS(c)
+#define RCouplingSM(c)		couplingsmS(c+RSMoffset)
+
+#define ngammas 978
+#define BRoffset 491
+#define GammaTot(h)		gammaS(h)
+#define Gamma(c)		gammaS(c+4)
+#define BR(c)			gammaS(c+BRoffset)
+
+#define ngammasms 250
+#define BRSMoffset 127
+#define GammaSMTot(h)		gammasmS(h)
+#define GammaSM(c)		gammasmS(c+4)
+#define BRSM(c)			gammasmS(c+BRSMoffset)
+
+
+#define H0VV(h,vv) h+3*vv-3
+#if 0
+  h  = 1..3	Higgs: h0, HH, A0
+  vv = 1..5	vector-boson pair: gamma gamma, gamma Z, ZZ, WW, gg
+#endif
+
+#define H0FF(h,t,g1,g2) h+3*t+12*g1+36*g2-36
+#if 0
+  h  = 1..3	Higgs: h0, HH, A0
+  t  = 1..4	fermion type: nu, e, u, d
+  g1 = 1..3	fermion 1 generation
+  g2 = 1..3	fermion 2 generation
+#endif
+
+#define HpFF(p,g1,g2) p+2*g1+6*g2+115
+#if 0
+  p  = 1..2	decay products: leptons, quarks
+  g1 = 1..3	up-type fermion 1 generation
+  g2 = 1..3	down-type fermion 2 generation
+#endif
+
+#define H0ChaCha(h,c1,c2) h+3*c1+6*c2+132
+#if 0
+  h  = 1..3	Higgs: h0, HH, A0
+  c1 = 1..2	chargino 1
+  c2 = 1..2	chargino 2
+#endif
+
+#define H0NeuNeu(h,n1,n2) h+3*n1+12*n2+138
+#if 0
+  h  = 1..3	Higgs: h0, HH, A0
+  n1 = 1..4	neutralino 1
+  n2 = 1..4	neutralino 2
+#endif
+
+#define HpNeuCha(n1,c2) n1+4*c2+197
+#if 0
+  n1 = 1..4	neutralino
+  c2 = 1..2	chargino
+#endif
+
+#define H0HV(h,hv) h+3*hv+206
+#if 0
+  h  = 1..3	decaying Higgs: h0, HH, A0
+  hv = 1..3	produced pair: h0-Z, HH-Z, A0-Z
+#endif
+
+#define HpHV(hv) hv+218
+#if 0
+  hv = 1..3	produced pair: h0-W, HH-W, A0-W
+#endif
+
+#define H0HH(h,h1,h2) h+3*h1+12*h2+206
+#if 0
+  h  = 1..3	decaying Higgs: h0, HH, A0
+  h1 = 1..4	produced Higgs 1: h0, HH, A0, Hp
+  h2 = 1..4	produced Higgs 2: h0, HH, A0, Hp
+#endif
+
+#define H0SfSf(h,s1,s2,t,g) h+3*s1+6*s2+12*t+48*g+200
+#if 0
+  h  = 1..3	Higgs: h0, HH, A0
+  s1 = 1..2	sfermion 1
+  s2 = 1..2	sfermion 2
+  t  = 1..4	sfermion type: nu, e, u, d
+  g = 1..3	common sfermion generation
+#endif
+
+#define HpSfSf(s1,s2,p,g1,g2) s1+2*s2+4*p+8*g1+24*g2+375
+#if 0
+  s1 = 1..2	sfermion 1
+  s2 = 1..2	sfermion 2
+  p  = 1..2	decay products: sleptons, squarks
+  g1 = 1..3	up-type sfermion 1 generation
+  g2 = 1..3	down-type sfermion 2 generation
+#endif
+
+#define tBF(bf) bf+485
+#if 0
+  bf = 1..2	W-b, H-b
+#endif
+
+
+#define nprodxs 49
+
+#define bbh(h)		prodXS(h)
+#define bbhSM(h)	prodXS(h+3)
+#define btagbh(h)	prodXS(h+6)
+#define btagbhSM(h)	prodXS(h+9)
+#define ggh(h)		prodXS(h+12)
+#define ggh2(h)		prodXS(h+15)
+#define gghSM(h)	prodXS(h+18)
+#define qqh(h)		prodXS(h+21)
+#define qqhSM(h)	prodXS(h+24)
+#define tth(h)		prodXS(h+27)
+#define tthSM(h)	prodXS(h+30)
+#define Wh(h)		prodXS(h+33)
+#define WhSM(h)		prodXS(h+36)
+#define Zh(h)		prodXS(h+39)
+#define ZhSM(h)		prodXS(h+42)
+#define StSth(h)	prodXS(h+45)
+#define tHm		prodXS(49)
+
+#endif
+
diff -rupN darksusy-5.1.3/include/PDG.h ../installed/darksusy/5.1.3/include/PDG.h
--- darksusy-5.1.3/include/PDG.h	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/include/PDG.h	2018-07-04 22:31:04.748751159 +0100
@@ -0,0 +1,79 @@
+#if 0
+	PDG.h
+		declaration of Particle Data Group codes
+		last modified 22 Jun 06 th
+#endif
+
+
+#ifndef PDG_H
+#define PDG_H
+
+#define PDGLen 16
+#define PDGDigits 10
+
+#define PDG_down	1
+#define PDG_up		2
+#define PDG_strange	3
+#define PDG_charm	4
+#define PDG_bottom	5
+#define PDG_top		6
+
+#define PDG_electron	11
+#define PDG_nu_e	12
+#define PDG_muon	13
+#define PDG_nu_mu	14
+#define PDG_tau		15
+#define PDG_nu_tau	16
+
+#define PDG_gluon	21
+#define PDG_photon	22
+#define PDG_Z		23
+#define PDG_W		24
+#define PDG_h0		25
+#define PDG_HH		35
+#define PDG_A0		36
+#define PDG_Hp		37
+#define PDG_graviton	39
+#define PDG_H3		45
+#define PDG_A2		46
+
+#define PDG_sdown1	1000001
+#define PDG_sup1	1000002
+#define PDG_sstrange1	1000003
+#define PDG_scharm1	1000004
+#define PDG_sbottom1	1000005
+#define PDG_stop1	1000006
+
+#define PDG_selectron1	1000011
+#define PDG_snu_e1	1000012
+#define PDG_smuon1	1000013
+#define PDG_snu_mu1	1000014
+#define PDG_stau1	1000015
+#define PDG_snu_tau1	1000016
+
+#define PDG_sdown2	2000001
+#define PDG_sup2	2000002
+#define PDG_sstrange2	2000003
+#define PDG_scharm2	2000004
+#define PDG_sbottom2	2000005
+#define PDG_stop2	2000006
+
+#define PDG_selectron2	2000011
+#define PDG_snu_e2	2000012
+#define PDG_smuon2	2000013
+#define PDG_snu_mu2	2000014
+#define PDG_stau2	2000015
+#define PDG_snu_tau2	2000016
+
+#define PDG_gluino	1000021
+#define PDG_neutralino1	1000022
+#define PDG_neutralino2	1000023
+#define PDG_neutralino3	1000025
+#define PDG_neutralino4	1000035
+#define PDG_neutralino5 1000045
+#define PDG_chargino1	1000024
+#define PDG_chargino2	1000037
+#define PDG_gravitino	1000039
+
+#endif
+
diff -rupN darksusy-5.1.3/include/SLHADefs.h ../installed/darksusy/5.1.3/include/SLHADefs.h
--- darksusy-5.1.3/include/SLHADefs.h	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/include/SLHADefs.h	2018-07-04 22:31:04.752749158 +0100
@@ -0,0 +1,742 @@
+#if 0
+	SLHADefs.h
+		declarations for SLHALib data
+		generated 1 Jun 2012 9:36
+#endif
+
+#ifndef SLHADEFS_H
+#define SLHADEFS_H
+
+#define invalid (-999)
+
+#define OffsetModSel 0
+#define LengthModSel 6
+#define BlockModSel(i) SlhaData(i)
+#define ModSel_Model Slhadata(1)
+#define ModSel_GridPts Slhadata(2)
+#define ModSel_Content Slhadata(3)
+#define ModSel_RPV Slhadata(4)
+#define ModSel_CPV Slhadata(5)
+#define ModSel_FV Slhadata(6)
+
+#define OffsetSMInputs 6
+#define LengthSMInputs 16
+#define BlockSMInputs(i) SlhaData(6+i)
+#define SMInputs_invAlfaMZ Slhadata(7)
+#define SMInputs_GF Slhadata(8)
+#define SMInputs_AlfasMZ Slhadata(9)
+#define SMInputs_MZ Slhadata(10)
+#define SMInputs_Mf(t,g) Slhadata(6+t+4*(g))
+#define SMInputs_MfFlat(i) Slhadata(10+i)
+#define   SMInputs_Mnu1 SMInputs_Mf(1,1)
+#define   SMInputs_Me SMInputs_Mf(2,1)
+#define   SMInputs_Mu SMInputs_Mf(3,1)
+#define   SMInputs_Md SMInputs_Mf(4,1)
+#define   SMInputs_Mnu2 SMInputs_Mf(1,2)
+#define   SMInputs_Mmu SMInputs_Mf(2,2)
+#define   SMInputs_Mc SMInputs_Mf(3,2)
+#define   SMInputs_Ms SMInputs_Mf(4,2)
+#define   SMInputs_Mnu3 SMInputs_Mf(1,3)
+#define   SMInputs_Mtau SMInputs_Mf(2,3)
+#define   SMInputs_Mt SMInputs_Mf(3,3)
+#define   SMInputs_Mb SMInputs_Mf(4,3)
+
+#define OffsetMinPar 22
+#define LengthMinPar 6
+#define BlockMinPar(i) SlhaData(22+i)
+#define MinPar_M0 Slhadata(23)
+#define   MinPar_Lambda MinPar_M0
+#define MinPar_M12 Slhadata(24)
+#define   MinPar_Mmess MinPar_M12
+#define   MinPar_M32 MinPar_M12
+#define MinPar_TB Slhadata(25)
+#define MinPar_signMUE Slhadata(26)
+#define MinPar_A Slhadata(27)
+#define   MinPar_N5 MinPar_A
+#define MinPar_cgrav Slhadata(28)
+
+#define OffsetExtPar 28
+#define LengthExtPar 42
+#define BlockExtPar(i) SlhaData(28+i)
+#define ExtPar_Q SlhaData(29)
+#define ExtPar_M1 Slhadata(30)
+#define ExtPar_M2 Slhadata(31)
+#define ExtPar_M3 Slhadata(32)
+#define ExtPar_Af(t) Slhadata(31+t)
+#define   ExtPar_Atau ExtPar_Af(2)
+#define   ExtPar_At ExtPar_Af(3)
+#define   ExtPar_Ab ExtPar_Af(4)
+#define ExtPar_MHu2 Slhadata(36)
+#define ExtPar_MHd2 Slhadata(37)
+#define ExtPar_MUE Slhadata(38)
+#define ExtPar_MA02 Slhadata(39)
+#define ExtPar_TB Slhadata(40)
+#define ExtPar_MA0 Slhadata(41)
+#define ExtPar_MHp Slhadata(42)
+#define ExtPar_MSS(g,q) Slhadata(39+g+3*(q))
+#define   ExtPar_MSL(g) ExtPar_MSS(g,1)
+#define   ExtPar_MSE(g) ExtPar_MSS(g,2)
+#define   ExtPar_MSQ(g) ExtPar_MSS(g,3)
+#define   ExtPar_MSU(g) ExtPar_MSS(g,4)
+#define   ExtPar_MSD(g) ExtPar_MSS(g,5)
+#define ExtPar_N5(g) Slhadata(57+g)
+#define ExtPar_lambda Slhadata(61)
+#define ExtPar_kappa Slhadata(62)
+#define ExtPar_Alambda Slhadata(63)
+#define ExtPar_Akappa Slhadata(64)
+#define ExtPar_lambdaS Slhadata(65)
+#define ExtPar_xiF Slhadata(66)
+#define ExtPar_xiS Slhadata(67)
+#define ExtPar_MUEprime Slhadata(68)
+#define ExtPar_mS2prime Slhadata(69)
+#define ExtPar_mS2 Slhadata(70)
+
+#define OffsetQExtPar 70
+#define LengthQExtPar 16
+#define BlockQExtPar(i) SlhaData(70+i)
+#define QExtPar_QM1 SlhaData(71)
+#define QExtPar_QM2 SlhaData(72)
+#define QExtPar_QM3 SlhaData(73)
+#define QExtPar_QAf(t) SlhaData(72+t)
+#define   QExtPar_QAtau QExtPar_QAf(2)
+#define   QExtPar_QAt QExtPar_QAf(3)
+#define   QExtPar_QAb QExtPar_QAf(4)
+#define QExtPar_QMHu2 SlhaData(77)
+#define QExtPar_QMHd2 SlhaData(78)
+#define QExtPar_QMUE SlhaData(79)
+#define QExtPar_QMA02 SlhaData(80)
+#define QExtPar_QTB SlhaData(81)
+#define QExtPar_QMSS(q) SlhaData(81+q)
+#define   QExtPar_QMSL QExtPar_QMSS(1)
+#define   QExtPar_QMSE QExtPar_QMSS(2)
+#define   QExtPar_QMSQ QExtPar_QMSS(3)
+#define   QExtPar_QMSU QExtPar_QMSS(4)
+#define   QExtPar_QMSD QExtPar_QMSS(5)
+
+#define OffsetNMSSMRun 86
+#define LengthNMSSMRun 11
+#define BlockNMSSMRun(i) SlhaData(86+i)
+#define NMSSMRun_Q SlhaData(87)
+#define NMSSMRun_lambda Slhadata(88)
+#define NMSSMRun_kappa Slhadata(89)
+#define NMSSMRun_Alambda Slhadata(90)
+#define NMSSMRun_Akappa Slhadata(91)
+#define NMSSMRun_lambdaS Slhadata(92)
+#define NMSSMRun_xiF Slhadata(93)
+#define NMSSMRun_xiS Slhadata(94)
+#define NMSSMRun_MUEprime Slhadata(95)
+#define NMSSMRun_mS2prime Slhadata(96)
+#define NMSSMRun_mS2 Slhadata(97)
+
+#define OffsetMass 97
+#define LengthMass 53
+#define BlockMass(i) SlhaData(97+i)
+#define Mass_Mf(t,g) Slhadata(93+t+4*(g))
+#define Mass_MfFlat(i) Slhadata(97+i)
+#define Mass_MSf(s,t,g) Slhadata(99+s+8*(g)+2*(t))
+#define Mass_MSfFlat(i) Slhadata(109+i)
+#define Mass_MZ Slhadata(134)
+#define Mass_MW Slhadata(135)
+#define Mass_Mh0 Slhadata(136)
+#define Mass_MHH Slhadata(137)
+#define Mass_MA0 Slhadata(138)
+#define Mass_MHp Slhadata(139)
+#define   Mass_MH1 Mass_Mh0
+#define   Mass_MH2 Mass_MHH
+#define Mass_MH3 Slhadata(140)
+#define   Mass_MA1 Mass_MA0
+#define Mass_MA2 Slhadata(141)
+#define Mass_MNeu(n) Slhadata(141+n)
+#define Mass_MCha(c) Slhadata(146+c)
+#define Mass_MGl Slhadata(149)
+#define Mass_MGrav Slhadata(150)
+
+#define OffsetDMass 150
+#define LengthDMass 5
+#define BlockDMass(i) SlhaData(150+i)
+#define DMass_Q SlhaData(151)
+#define DMass_DeltaMh0 Slhadata(152)
+#define DMass_DeltaMHH Slhadata(153)
+#define DMass_DeltaMA0 Slhadata(154)
+#define DMass_DeltaMHp Slhadata(155)
+
+#define OffsetNMix 155
+#define LengthNMix 16
+#define BlockNMix(i) SlhaData(155+i)
+#define NMix_ZNeu(n1,n2) Slhadata(151+n1+4*(n2))
+#define NMix_ZNeuFlat(i) Slhadata(155+i)
+
+#define OffsetUMix 171
+#define LengthUMix 4
+#define BlockUMix(i) SlhaData(171+i)
+#define UMix_UCha(c1,c2) Slhadata(169+c1+2*(c2))
+#define UMix_UChaFlat(i) Slhadata(171+i)
+
+#define OffsetVMix 175
+#define LengthVMix 4
+#define BlockVMix(i) SlhaData(175+i)
+#define VMix_VCha(c1,c2) Slhadata(173+c1+2*(c2))
+#define VMix_VChaFlat(i) Slhadata(175+i)
+
+#define OffsetSfMix 179
+#define LengthSfMix 12
+#define BlockSfMix(i) SlhaData(179+i)
+#define SfMix_USf(s1,s2,t) Slhadata(169+s1+2*(s2)+4*(t))
+#define SfMix_USfFlat(i,t) Slhadata(171+i+4*(t))
+
+#define OffsetStauMix 179
+#define LengthStauMix 4
+#define BlockStauMix(i) SlhaData(179+i)
+#define   StauMix_USf(s1,s2) SfMix_USf(s1,s2,2)
+#define   StauMix_USfFlat(i) SfMix_USfFlat(i,2)
+
+#define OffsetStopMix 183
+#define LengthStopMix 4
+#define BlockStopMix(i) SlhaData(183+i)
+#define   StopMix_USf(s1,s2) SfMix_USf(s1,s2,3)
+#define   StopMix_USfFlat(i) SfMix_USfFlat(i,3)
+
+#define OffsetSbotMix 187
+#define LengthSbotMix 4
+#define BlockSbotMix(i) SlhaData(187+i)
+#define   SbotMix_USf(s1,s2) SfMix_USf(s1,s2,4)
+#define   SbotMix_USfFlat(i) SfMix_USfFlat(i,4)
+
+#define OffsetAlpha 191
+#define LengthAlpha 1
+#define BlockAlpha(i) SlhaData(191+i)
+#define Alpha_Alpha Slhadata(192)
+
+#define OffsetDAlpha 192
+#define LengthDAlpha 1
+#define BlockDAlpha(i) SlhaData(192+i)
+#define DAlpha_DeltaAlpha Slhadata(193)
+
+#define OffsetHMix 193
+#define LengthHMix 5
+#define BlockHMix(i) SlhaData(193+i)
+#define HMix_Q SlhaData(194)
+#define HMix_MUE Slhadata(195)
+#define HMix_TB Slhadata(196)
+#define HMix_VEV Slhadata(197)
+#define HMix_MA02 Slhadata(198)
+
+#define OffsetGauge 198
+#define LengthGauge 4
+#define BlockGauge(i) SlhaData(198+i)
+#define Gauge_Q SlhaData(199)
+#define Gauge_g1 Slhadata(200)
+#define Gauge_g2 Slhadata(201)
+#define Gauge_g3 Slhadata(202)
+
+#define OffsetMSoft 202
+#define LengthMSoft 21
+#define BlockMSoft(i) SlhaData(202+i)
+#define MSoft_Q SlhaData(203)
+#define MSoft_M1 Slhadata(204)
+#define MSoft_M2 Slhadata(205)
+#define MSoft_M3 Slhadata(206)
+#define MSoft_MHu2 Slhadata(207)
+#define MSoft_MHd2 Slhadata(208)
+#define MSoft_MSS(g,q) Slhadata(205+g+3*(q))
+#define   MSoft_MSL(g) MSoft_MSS(g,1)
+#define   MSoft_MSE(g) MSoft_MSS(g,2)
+#define   MSoft_MSQ(g) MSoft_MSS(g,3)
+#define   MSoft_MSU(g) MSoft_MSS(g,4)
+#define   MSoft_MSD(g) MSoft_MSS(g,5)
+
+#define OffsetAf 223
+#define LengthAf 30
+#define BlockAf(i) SlhaData(223+i)
+#define Af_Q(t) SlhaData(204+10*(t))
+#define Af_Af(g1,g2,t) Slhadata(201+g1+3*(g2)+10*(t))
+#define Af_AfFlat(i,t) Slhadata(204+i+10*(t))
+
+#define OffsetAe 223
+#define LengthAe 11
+#define BlockAe(i) SlhaData(223+i)
+#define   Ae_Q Af_Q(2)
+#define   Ae_Af(g1,g2) Af_Af(g1,g2,2)
+#define   Ae_AfFlat(i) Af_AfFlat(i,2)
+#define   Ae_Atau Ae_Af(3,3)
+
+#define OffsetAu 234
+#define LengthAu 11
+#define BlockAu(i) SlhaData(234+i)
+#define   Au_Q Af_Q(3)
+#define   Au_Af(g1,g2) Af_Af(g1,g2,3)
+#define   Au_AfFlat(i) Af_AfFlat(i,3)
+#define   Au_At Au_Af(3,3)
+
+#define OffsetAd 245
+#define LengthAd 11
+#define BlockAd(i) SlhaData(245+i)
+#define   Ad_Q Af_Q(4)
+#define   Ad_Af(g1,g2) Af_Af(g1,g2,4)
+#define   Ad_AfFlat(i) Af_AfFlat(i,4)
+#define   Ad_Ab Ad_Af(3,3)
+
+#define OffsetYf 256
+#define LengthYf 30
+#define BlockYf(i) SlhaData(256+i)
+#define Yf_Q(t) SlhaData(237+10*(t))
+#define Yf_Yf(g1,g2,t) Slhadata(234+g1+3*(g2)+10*(t))
+#define Yf_YfFlat(i,t) Slhadata(237+i+10*(t))
+
+#define OffsetYe 256
+#define LengthYe 11
+#define BlockYe(i) SlhaData(256+i)
+#define   Ye_Q Yf_Q(2)
+#define   Ye_Yf(g1,g2) Yf_Yf(g1,g2,2)
+#define   Ye_YfFlat(i) Yf_YfFlat(i,2)
+#define   Ye_Ytau Ye_Yf(3,3)
+
+#define OffsetYu 267
+#define LengthYu 11
+#define BlockYu(i) SlhaData(267+i)
+#define   Yu_Q Yf_Q(3)
+#define   Yu_Yf(g1,g2) Yf_Yf(g1,g2,3)
+#define   Yu_YfFlat(i) Yf_YfFlat(i,3)
+#define   Yu_Yt Yu_Yf(3,3)
+
+#define OffsetYd 278
+#define LengthYd 11
+#define BlockYd(i) SlhaData(278+i)
+#define   Yd_Q Yf_Q(4)
+#define   Yd_Yf(g1,g2) Yf_Yf(g1,g2,4)
+#define   Yd_YfFlat(i) Yf_YfFlat(i,4)
+#define   Yd_Yb Yd_Yf(3,3)
+
+#define OffsetRVLamLLEIn 289
+#define LengthRVLamLLEIn 27
+#define BlockRVLamLLEIn(i) SlhaData(289+i)
+#define RVLamLLEIn_lamLLE(i,j,k) Slhadata(277+i+3*(j)+9*(k))
+#define RVLamLLEIn_lamLLEFlat(i) Slhadata(289+i)
+
+#define OffsetRVLamLQDIn 316
+#define LengthRVLamLQDIn 27
+#define BlockRVLamLQDIn(i) SlhaData(316+i)
+#define RVLamLQDIn_lamLQD(i,j,k) Slhadata(304+i+3*(j)+9*(k))
+#define RVLamLQDIn_lamLQDFlat(i) Slhadata(316+i)
+
+#define OffsetRVLamUDDIn 343
+#define LengthRVLamUDDIn 27
+#define BlockRVLamUDDIn(i) SlhaData(343+i)
+#define RVLamUDDIn_lamUDD(i,j,k) Slhadata(331+i+3*(j)+9*(k))
+#define RVLamUDDIn_lamUDDFlat(i) Slhadata(343+i)
+
+#define OffsetRVLamLLE 370
+#define LengthRVLamLLE 28
+#define BlockRVLamLLE(i) SlhaData(370+i)
+#define RVLamLLE_Q SlhaData(371)
+#define RVLamLLE_lamLLE(i,j,k) Slhadata(359+i+3*(j)+9*(k))
+#define RVLamLLE_lamLLEFlat(i) Slhadata(371+i)
+
+#define OffsetRVLamLQD 398
+#define LengthRVLamLQD 28
+#define BlockRVLamLQD(i) SlhaData(398+i)
+#define RVLamLQD_Q SlhaData(399)
+#define RVLamLQD_lamLQD(i,j,k) Slhadata(387+i+3*(j)+9*(k))
+#define RVLamLQD_lamLQDFlat(i) Slhadata(399+i)
+
+#define OffsetRVLamUDD 426
+#define LengthRVLamUDD 28
+#define BlockRVLamUDD(i) SlhaData(426+i)
+#define RVLamUDD_Q SlhaData(427)
+#define RVLamUDD_lamUDD(i,j,k) Slhadata(415+i+3*(j)+9*(k))
+#define RVLamUDD_lamUDDFlat(i) Slhadata(427+i)
+
+#define OffsetRVTLLEIn 454
+#define LengthRVTLLEIn 27
+#define BlockRVTLLEIn(i) SlhaData(454+i)
+#define RVTLLEIn_TLLE(i,j,k) Slhadata(442+i+3*(j)+9*(k))
+#define RVTLLEIn_TLLEFlat(i) Slhadata(454+i)
+
+#define OffsetRVTLQDIn 481
+#define LengthRVTLQDIn 27
+#define BlockRVTLQDIn(i) SlhaData(481+i)
+#define RVTLQDIn_TLQD(i,j,k) Slhadata(469+i+3*(j)+9*(k))
+#define RVTLQDIn_TLQDFlat(i) Slhadata(481+i)
+
+#define OffsetRVTUDDIn 508
+#define LengthRVTUDDIn 27
+#define BlockRVTUDDIn(i) SlhaData(508+i)
+#define RVTUDDIn_TUDD(i,j,k) Slhadata(496+i+3*(j)+9*(k))
+#define RVTUDDIn_TUDDFlat(i) Slhadata(508+i)
+
+#define OffsetRVTLLE 535
+#define LengthRVTLLE 28
+#define BlockRVTLLE(i) SlhaData(535+i)
+#define RVTLLE_Q SlhaData(536)
+#define RVTLLE_TLLE(i,j,k) Slhadata(524+i+3*(j)+9*(k))
+#define RVTLLE_TLLEFlat(i) Slhadata(536+i)
+
+#define OffsetRVTLQD 563
+#define LengthRVTLQD 28
+#define BlockRVTLQD(i) SlhaData(563+i)
+#define RVTLQD_Q SlhaData(564)
+#define RVTLQD_TLQD(i,j,k) Slhadata(552+i+3*(j)+9*(k))
+#define RVTLQD_TLQDFlat(i) Slhadata(564+i)
+
+#define OffsetRVTUDD 591
+#define LengthRVTUDD 28
+#define BlockRVTUDD(i) SlhaData(591+i)
+#define RVTUDD_Q SlhaData(592)
+#define RVTUDD_TUDD(i,j,k) Slhadata(580+i+3*(j)+9*(k))
+#define RVTUDD_TUDDFlat(i) Slhadata(592+i)
+
+#define OffsetRVKappaIn 619
+#define LengthRVKappaIn 3
+#define BlockRVKappaIn(i) SlhaData(619+i)
+#define RVKappaIn_kappa(i) Slhadata(619+i)
+
+#define OffsetRVKappa 622
+#define LengthRVKappa 4
+#define BlockRVKappa(i) SlhaData(622+i)
+#define RVKappa_Q SlhaData(623)
+#define RVKappa_kappa(i) Slhadata(623+i)
+
+#define OffsetRVDIn 626
+#define LengthRVDIn 3
+#define BlockRVDIn(i) SlhaData(626+i)
+#define RVDIn_D(i) Slhadata(626+i)
+
+#define OffsetRVD 629
+#define LengthRVD 4
+#define BlockRVD(i) SlhaData(629+i)
+#define RVD_Q SlhaData(630)
+#define RVD_D(i) Slhadata(630+i)
+
+#define OffsetRVSnVEVIn 633
+#define LengthRVSnVEVIn 3
+#define BlockRVSnVEVIn(i) SlhaData(633+i)
+#define RVSnVEVIn_VEV(i) Slhadata(633+i)
+
+#define OffsetRVSnVEV 636
+#define LengthRVSnVEV 4
+#define BlockRVSnVEV(i) SlhaData(636+i)
+#define RVSnVEV_Q SlhaData(637)
+#define RVSnVEV_VEV(i) Slhadata(637+i)
+
+#define OffsetRVM2LH1In 640
+#define LengthRVM2LH1In 3
+#define BlockRVM2LH1In(i) SlhaData(640+i)
+#define RVM2LH1In_M2LH1(i) Slhadata(640+i)
+
+#define OffsetRVM2LH1 643
+#define LengthRVM2LH1 4
+#define BlockRVM2LH1(i) SlhaData(643+i)
+#define RVM2LH1_Q SlhaData(644)
+#define RVM2LH1_M2LH1(i) Slhadata(644+i)
+
+#define OffsetRVNMix 647
+#define LengthRVNMix 49
+#define BlockRVNMix(i) SlhaData(647+i)
+#define RVNMix_ZNeu(n1,n2) Slhadata(640+n1+7*(n2))
+#define RVNMix_ZNeuFlat(i) Slhadata(647+i)
+
+#define OffsetRVUMix 696
+#define LengthRVUMix 25
+#define BlockRVUMix(i) SlhaData(696+i)
+#define RVUMix_UCha(c1,c2) Slhadata(691+c1+5*(c2))
+#define RVUMix_UChaFlat(i) Slhadata(696+i)
+
+#define OffsetRVVMix 721
+#define LengthRVVMix 25
+#define BlockRVVMix(i) SlhaData(721+i)
+#define RVVMix_VCha(c1,c2) Slhadata(716+c1+5*(c2))
+#define RVVMix_VChaFlat(i) Slhadata(721+i)
+
+#define OffsetRVHMix 746
+#define LengthRVHMix 25
+#define BlockRVHMix(i) SlhaData(746+i)
+#define RVHMix_UH(h1,h2) Slhadata(741+h1+5*(h2))
+#define RVHMix_UHFlat(i) Slhadata(746+i)
+
+#define OffsetRVAMix 771
+#define LengthRVAMix 25
+#define BlockRVAMix(i) SlhaData(771+i)
+#define RVAMix_UA(h1,h2) Slhadata(766+h1+5*(h2))
+#define RVAMix_UAFlat(i) Slhadata(771+i)
+
+#define OffsetRVLMix 796
+#define LengthRVLMix 64
+#define BlockRVLMix(i) SlhaData(796+i)
+#define RVLMix_CLep(l1,l2) Slhadata(788+l1+8*(l2))
+#define RVLMix_CLepFlat(i) Slhadata(796+i)
+
+#define OffsetVCKMIn 860
+#define LengthVCKMIn 4
+#define BlockVCKMIn(i) SlhaData(860+i)
+#define VCKMIn_lambda Slhadata(861)
+#define VCKMIn_A Slhadata(862)
+#define VCKMIn_rhobar Slhadata(863)
+#define VCKMIn_etabar Slhadata(864)
+
+#define OffsetVCKM 864
+#define LengthVCKM 10
+#define BlockVCKM(i) SlhaData(864+i)
+#define VCKM_Q SlhaData(865)
+#define VCKM_VCKM(g1,g2) Slhadata(862+g1+3*(g2))
+#define VCKM_VCKMFlat(i) Slhadata(865+i)
+
+#define OffsetUPMNSIn 874
+#define LengthUPMNSIn 6
+#define BlockUPMNSIn(i) SlhaData(874+i)
+#define UPMNSIn_theta12 Slhadata(875)
+#define UPMNSIn_theta23 Slhadata(876)
+#define UPMNSIn_theta13 Slhadata(877)
+#define UPMNSIn_delta13 Slhadata(878)
+#define UPMNSIn_alpha1 Slhadata(879)
+#define UPMNSIn_alpha2 Slhadata(880)
+
+#define OffsetUPMNS 880
+#define LengthUPMNS 10
+#define BlockUPMNS(i) SlhaData(880+i)
+#define UPMNS_Q SlhaData(881)
+#define UPMNS_UPMNS(g1,g2) Slhadata(878+g1+3*(g2))
+#define UPMNS_UPMNSFlat(i) Slhadata(881+i)
+
+#define OffsetMSS2In 890
+#define LengthMSS2In 45
+#define BlockMSS2In(i) SlhaData(890+i)
+#define MSS2In_MSS2(g1,g2,q) Slhadata(878+g1+3*(g2)+9*(q))
+#define MSS2In_MSS2Flat(i,q) Slhadata(881+i+9*(q))
+
+#define OffsetMSL2In 890
+#define LengthMSL2In 9
+#define BlockMSL2In(i) SlhaData(890+i)
+#define   MSL2In_MSL2(g1,g2) MSS2In_MSS2(g1,g2,1)
+#define   MSL2In_MSL2Flat(i) MSS2In_MSS2Flat(i,1)
+
+#define OffsetMSE2In 899
+#define LengthMSE2In 9
+#define BlockMSE2In(i) SlhaData(899+i)
+#define   MSE2In_MSE2(g1,g2) MSS2In_MSS2(g1,g2,2)
+#define   MSE2In_MSE2Flat(i) MSS2In_MSS2Flat(i,2)
+
+#define OffsetMSQ2In 908
+#define LengthMSQ2In 9
+#define BlockMSQ2In(i) SlhaData(908+i)
+#define   MSQ2In_MSQ2(g1,g2) MSS2In_MSS2(g1,g2,3)
+#define   MSQ2In_MSQ2Flat(i) MSS2In_MSS2Flat(i,3)
+
+#define OffsetMSU2In 917
+#define LengthMSU2In 9
+#define BlockMSU2In(i) SlhaData(917+i)
+#define   MSU2In_MSU2(g1,g2) MSS2In_MSS2(g1,g2,4)
+#define   MSU2In_MSU2Flat(i) MSS2In_MSS2Flat(i,4)
+
+#define OffsetMSD2In 926
+#define LengthMSD2In 9
+#define BlockMSD2In(i) SlhaData(926+i)
+#define   MSD2In_MSD2(g1,g2) MSS2In_MSS2(g1,g2,5)
+#define   MSD2In_MSD2Flat(i) MSS2In_MSS2Flat(i,5)
+
+#define OffsetMSS2 935
+#define LengthMSS2 50
+#define BlockMSS2(i) SlhaData(935+i)
+#define MSS2_Q(q) SlhaData(926+10*(q))
+#define MSS2_MSS2(g1,g2,q) Slhadata(923+g1+3*(g2)+10*(q))
+#define MSS2_MSS2Flat(i,q) Slhadata(926+i+10*(q))
+
+#define OffsetMSL2 935
+#define LengthMSL2 10
+#define BlockMSL2(i) SlhaData(935+i)
+#define   MSL2_Q MSS2_Q(1)
+#define   MSL2_MSL2(g1,g2) MSS2_MSS2(g1,g2,1)
+#define   MSL2_MSL2Flat(i) MSS2_MSS2Flat(i,1)
+
+#define OffsetMSE2 945
+#define LengthMSE2 10
+#define BlockMSE2(i) SlhaData(945+i)
+#define   MSE2_Q MSS2_Q(2)
+#define   MSE2_MSE2(g1,g2) MSS2_MSS2(g1,g2,2)
+#define   MSE2_MSE2Flat(i) MSS2_MSS2Flat(i,2)
+
+#define OffsetMSQ2 955
+#define LengthMSQ2 10
+#define BlockMSQ2(i) SlhaData(955+i)
+#define   MSQ2_Q MSS2_Q(3)
+#define   MSQ2_MSQ2(g1,g2) MSS2_MSS2(g1,g2,3)
+#define   MSQ2_MSQ2Flat(i) MSS2_MSS2Flat(i,3)
+
+#define OffsetMSU2 965
+#define LengthMSU2 10
+#define BlockMSU2(i) SlhaData(965+i)
+#define   MSU2_Q MSS2_Q(4)
+#define   MSU2_MSU2(g1,g2) MSS2_MSS2(g1,g2,4)
+#define   MSU2_MSU2Flat(i) MSS2_MSS2Flat(i,4)
+
+#define OffsetMSD2 975
+#define LengthMSD2 10
+#define BlockMSD2(i) SlhaData(975+i)
+#define   MSD2_Q MSS2_Q(5)
+#define   MSD2_MSD2(g1,g2) MSS2_MSS2(g1,g2,5)
+#define   MSD2_MSD2Flat(i) MSS2_MSS2Flat(i,5)
+
+#define OffsetTfIn 985
+#define LengthTfIn 27
+#define BlockTfIn(i) SlhaData(985+i)
+#define TfIn_Tf(g1,g2,t) Slhadata(964+g1+3*(g2)+9*(t))
+#define TfIn_TfFlat(i,t) Slhadata(967+i+9*(t))
+
+#define OffsetTeIn 985
+#define LengthTeIn 9
+#define BlockTeIn(i) SlhaData(985+i)
+#define   TeIn_Tf(g1,g2) TfIn_Tf(g1,g2,2)
+#define   TeIn_TfFlat(i) TfIn_TfFlat(i,2)
+
+#define OffsetTuIn 994
+#define LengthTuIn 9
+#define BlockTuIn(i) SlhaData(994+i)
+#define   TuIn_Tf(g1,g2) TfIn_Tf(g1,g2,3)
+#define   TuIn_TfFlat(i) TfIn_TfFlat(i,3)
+
+#define OffsetTdIn 1003
+#define LengthTdIn 9
+#define BlockTdIn(i) SlhaData(1003+i)
+#define   TdIn_Tf(g1,g2) TfIn_Tf(g1,g2,4)
+#define   TdIn_TfFlat(i) TfIn_TfFlat(i,4)
+
+#define OffsetTf 1012
+#define LengthTf 30
+#define BlockTf(i) SlhaData(1012+i)
+#define Tf_Q(t) SlhaData(993+10*(t))
+#define Tf_Tf(g1,g2,t) Slhadata(990+g1+3*(g2)+10*(t))
+#define Tf_TfFlat(i,t) Slhadata(993+i+10*(t))
+
+#define OffsetTe 1012
+#define LengthTe 10
+#define BlockTe(i) SlhaData(1012+i)
+#define   Te_Q Tf_Q(2)
+#define   Te_Tf(g1,g2) Tf_Tf(g1,g2,2)
+#define   Te_TfFlat(i) Tf_TfFlat(i,2)
+
+#define OffsetTu 1022
+#define LengthTu 10
+#define BlockTu(i) SlhaData(1022+i)
+#define   Tu_Q Tf_Q(3)
+#define   Tu_Tf(g1,g2) Tf_Tf(g1,g2,3)
+#define   Tu_TfFlat(i) Tf_TfFlat(i,3)
+
+#define OffsetTd 1032
+#define LengthTd 10
+#define BlockTd(i) SlhaData(1032+i)
+#define   Td_Q Tf_Q(4)
+#define   Td_Tf(g1,g2) Tf_Tf(g1,g2,4)
+#define   Td_TfFlat(i) Tf_TfFlat(i,4)
+
+#define OffsetASfMix 1042
+#define LengthASfMix 144
+#define BlockASfMix(i) SlhaData(1042+i)
+#define ASfMix_UASf(s1,s2,t) Slhadata(1000+s1+6*(s2)+36*(t))
+#define ASfMix_UASfFlat(i,t) Slhadata(1006+i+36*(t))
+
+#define OffsetSnuMix 1042
+#define LengthSnuMix 36
+#define BlockSnuMix(i) SlhaData(1042+i)
+#define   SnuMix_UASf(s1,s2) ASfMix_UASf(s1,s2,1)
+#define   SnuMix_UASfFlat(i) ASfMix_UASfFlat(i,1)
+
+#define OffsetSelMix 1078
+#define LengthSelMix 36
+#define BlockSelMix(i) SlhaData(1078+i)
+#define   SelMix_UASf(s1,s2) ASfMix_UASf(s1,s2,2)
+#define   SelMix_UASfFlat(i) ASfMix_UASfFlat(i,2)
+
+#define OffsetUSqMix 1114
+#define LengthUSqMix 36
+#define BlockUSqMix(i) SlhaData(1114+i)
+#define   USqMix_UASf(s1,s2) ASfMix_UASf(s1,s2,3)
+#define   USqMix_UASfFlat(i) ASfMix_UASfFlat(i,3)
+
+#define OffsetDSqMix 1150
+#define LengthDSqMix 36
+#define BlockDSqMix(i) SlhaData(1150+i)
+#define   DSqMix_UASf(s1,s2) ASfMix_UASf(s1,s2,4)
+#define   DSqMix_UASfFlat(i) ASfMix_UASfFlat(i,4)
+
+#define OffsetSnSMix 1186
+#define LengthSnSMix 9
+#define BlockSnSMix(i) SlhaData(1186+i)
+#define SnSMix_US(g1,g2) Slhadata(1183+g1+3*(g2))
+#define SnSMix_USFlat(i) Slhadata(1186+i)
+
+#define OffsetSnAMix 1195
+#define LengthSnAMix 9
+#define BlockSnAMix(i) SlhaData(1195+i)
+#define SnAMix_UA(g1,g2) Slhadata(1192+g1+3*(g2))
+#define SnAMix_UAFlat(i) Slhadata(1195+i)
+
+#define OffsetCVHMix 1204
+#define LengthCVHMix 16
+#define BlockCVHMix(i) SlhaData(1204+i)
+#define CVHMix_UH(h1,h2) Slhadata(1200+h1+4*(h2))
+#define CVHMix_UHFlat(i) Slhadata(1204+i)
+
+#define OffsetNMNMix 1220
+#define LengthNMNMix 25
+#define BlockNMNMix(i) SlhaData(1220+i)
+#define NMNMix_ZNeu(n1,n2) Slhadata(1215+n1+5*(n2))
+#define NMNMix_ZNeuFlat(i) Slhadata(1220+i)
+
+#define OffsetNMHMix 1245
+#define LengthNMHMix 9
+#define BlockNMHMix(i) SlhaData(1245+i)
+#define NMHMix_UH(h1,h2) Slhadata(1242+h1+3*(h2))
+#define NMHMix_UHFlat(i) Slhadata(1245+i)
+
+#define OffsetNMAMix 1254
+#define LengthNMAMix 9
+#define BlockNMAMix(i) SlhaData(1254+i)
+#define NMAMix_UA(h1,h2) Slhadata(1251+h1+3*(h2))
+#define NMAMix_UAFlat(i) Slhadata(1254+i)
+
+#define OffsetPrecObs 1263
+#define LengthPrecObs 15
+#define BlockPrecObs(i) SlhaData(1263+i)
+#define PrecObs_DeltaRho Slhadata(1264)
+#define PrecObs_MWMSSM Slhadata(1265)
+#define PrecObs_MWSM Slhadata(1266)
+#define PrecObs_SW2effMSSM Slhadata(1267)
+#define PrecObs_SW2effSM Slhadata(1268)
+#define PrecObs_gminus2mu Slhadata(1269)
+#define PrecObs_EDMeTh Slhadata(1270)
+#define PrecObs_EDMn Slhadata(1271)
+#define PrecObs_EDMHg Slhadata(1272)
+#define PrecObs_bsgammaMSSM Slhadata(1273)
+#define PrecObs_bsgammaSM Slhadata(1274)
+#define PrecObs_DeltaMsMSSM Slhadata(1275)
+#define PrecObs_DeltaMsSM Slhadata(1276)
+#define PrecObs_BsmumuMSSM Slhadata(1277)
+#define PrecObs_BsmumuSM Slhadata(1278)
+
+#define OffsetSPInfo 1278
+#define LengthSPInfo 92
+#define BlockSPInfo(i) SlhaData(1278+i)
+#define SPInfo_NLines SlhaData(1279)
+#define SPInfo_Severity SlhaData(1280)
+#define SPInfo_Code(n) SlhaData(1280+n)
+#define SPInfo_Text(i,n) SlhaData(1290+i+5*(n))
+#define SPInfo_TextFlat(i) SlhaData(1295+i)
+#define   SPInfo_Len 80
+
+#define OffsetDCInfo 1370
+#define LengthDCInfo 92
+#define BlockDCInfo(i) SlhaData(1370+i)
+#define DCInfo_NLines SlhaData(1371)
+#define DCInfo_Severity SlhaData(1372)
+#define DCInfo_Code(n) SlhaData(1372+n)
+#define DCInfo_Text(i,n) SlhaData(1382+i+5*(n))
+#define DCInfo_TextFlat(i) SlhaData(1387+i)
+#define   DCInfo_Len 80
+
+#define OffsetDecays 1462
+#define LengthDecays 4096
+#define BlockDecays(i) SlhaData(1462+i)
+#define Decays_Data(n) Slhadata(1462+n)
+
+#define nslhadata 5558
+
+#endif
diff -rupN darksusy-5.1.3/include/SLHA.h ../installed/darksusy/5.1.3/include/SLHA.h
--- darksusy-5.1.3/include/SLHA.h	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/include/SLHA.h	2018-07-04 22:31:04.752749158 +0100
@@ -0,0 +1,17 @@
+#if 0
+	SLHA.h
+		declarations of the external SLHA functions
+		last modified 30 Nov 11 th
+#endif
+
+#include "SLHADefs.h"
+
+	RealType SLHAGetDecay
+	external SLHAGetDecay
+
+	integer SLHANewDecay, SLHADecayTable
+	external SLHANewDecay, SLHADecayTable
+
+	integer SLHAExist, SLHAValid
+	external SLHAExist, SLHAValid
+
diff -rupN darksusy-5.1.3/makefile.in ../installed/darksusy/5.1.3/makefile.in
--- darksusy-5.1.3/makefile.in	2015-04-07 10:23:05.000000000 +0100
+++ ../installed/darksusy/5.1.3/makefile.in	2018-07-04 22:31:57.242491877 +0100
@@ -60,7 +60,9 @@ HBDIR=@HIGGSBOUNDSDIR@
 SLHADIR=@SLHADIR@
 TSPACKDIR=@TSPACKDIR@
 
-LIB=${DS_INSTALL}/lib
+DS_LIB=${DS_ROOT}/lib
+
+export DS_LIB
 
 ###############################################
 #### DO NOT CHANGE ANYTHING BELOW THIS LINE ###
@@ -82,7 +84,11 @@ config_paths config :
 
 darksusy_lib dslib : tspack
 	mkdir -p lib
-	cd $(DS_ROOT)/src; make all
+	cd $(DS_ROOT)/src; make libdarksusy.a
+
+darksusy_lib_shared dslib_shared : tspack libisajet_shared feynhiggs_shared higgsbounds_shared
+	mkdir -p lib
+	cd $(DS_ROOT)/src; make libdarksusy.so
 
 install : install_builds install_tables
 
@@ -139,15 +145,27 @@ install_tables :
 	cd $(DS_ROOT)/share/DarkSUSY; make all
 
 libisajet :
-	cd $(ISAJETDIR); make
+	cd $(ISAJETDIR); make libisajet.a
+
+libisajet_shared :
+	cd $(ISAJETDIR); make libisajet.so
 
 tspack:
 	cd $(TSPACKDIR); make
 
 feynhiggs :
 	cd $(FEYNHIGGSDIR); \
-	make lib ; \
-	cp -p build/libFH.a $(DS_ROOT)/lib/ ; \
+	make FC="$(FF)" FFLAGS="$(FOPT)" CFLAGS="-fPIC" lib ; \
+	cp -p build/libFH.a $(DS_LIB)/ ;
+	make copy_feynhiggs_headers
+
+feynhiggs_shared :
+	cd $(FEYNHIGGSDIR); \
+	make FC="$(FF)" FFLAGS="$(FOPT)" CFLAGS="-fPIC" lib_shared
+	make copy_feynhiggs_headers
+
+copy_feynhiggs_headers :
+	cd $(FEYNHIGGSDIR); \
 	cp -p build/include/FHCouplings.h $(DS_ROOT)/include/ ;  \
 	cp -p build/include/SLHA.h $(DS_ROOT)/include/  ; \
 	cp -p build/include/SLHADefs.h $(DS_ROOT)/include/  ; \
@@ -156,7 +174,11 @@ feynhiggs :
 higgsbounds :
 	cd $(HBDIR); \
 	make -f makefile_darksusy libHB ; \
-	cp -p libHB.a $(DS_ROOT)/lib/
+	cp -p libHB.a $(DS_LIB)/
+
+higgsbounds_shared :
+	cd $(HBDIR); \
+	make -f makefile_darksusy libHB_shared ; \
 
 # SLHA is currently not built, as feynhiggs includes slhalib
 slha :
@@ -184,7 +206,7 @@ clean :
 	cd $(DS_ROOT)/contrib/galprop/v50p; $(MAKE) clean
 	cd $(FEYNHIGGSDIR); $(MAKE) clean ; rm -fr ds
 	cd $(SLHADIR); $(MAKE) clean ; rm -fr ds
-	cd $(HBDIR); $(MAKE) -f makefile_darksusy -i veryclean; $(MAKE) -f makefile_darksusy -i hyperclean
+	cd $(HBDIR); $(MAKE) -f makefile_darksusy -i clean
 	cd $(TSPACKDIR); $(MAKE) clean
 
 
@@ -198,6 +220,11 @@ rmmore:
 	rm -f $(DS_ROOT)/lib/libFH.a
 	rm -f $(DS_ROOT)/lib/libSLHA.a
 	rm -f $(DS_ROOT)/lib/libHB.a
+	rm -f $(DS_INSTALL)/lib/libdarksusy.so
+	rm -f $(DS_INSTALL)/lib/libisajet.so
+	rm -f $(DS_INSTALL)/lib/libFH.so
+	rm -f $(DS_INSTALL)/lib/libSLHA.so
+	rm -f $(DS_INSTALL)/lib/libHB.so
 	rm -f $(DS_ROOT)/lib/aldata.o
 	rm -f $(DS_ROOT)/lib/libcfitsio.a
 	rm -f $(DS_ROOT)/share/DarkSUSY/ascii2bin
@@ -229,6 +256,7 @@ rmmore:
 # If it is, we know that DS_INSTALL must point to DS_ROOT.
 uninstall:
 	rm -f $(DS_INSTALL)/lib/libdarksusy.a
+	rm -f $(DS_INSTALL)/lib/libdarksusy.so
 	rm -f $(DS_INSTALL)/lib/aldata.o
 	if [ ! -f $(DS_INSTALL)/makefile.in ] ; then \
 		echo 'The install directory is different from DS_ROOT' ; \
diff -rupN darksusy-5.1.3/misc/makefile.in ../installed/darksusy/5.1.3/misc/makefile.in
--- darksusy-5.1.3/misc/makefile.in	2013-02-15 17:58:12.000000000 +0000
+++ ../installed/darksusy/5.1.3/misc/makefile.in	2018-07-04 22:31:57.242491877 +0100
@@ -26,6 +26,10 @@ caprates : caprates.f $(LIB)/libdarksusy
 	$(FF) $(FOPT) $(INC) -L$(LIB) -o caprates caprates.f \
         -ldarksusy -lHB -lFH
 
+oh2test : oh2test.f $(LIB)/libdarksusy.a
+	$(FF) $(FOPT) $(INC) -L$(LIB) -o oh2test oh2test.f \
+        -L$(LIB)/aldata.o -ldarksusy -lisajet -lHB -lFH
+
 caprates_ea : caprates_ea.f $(LIB)/libdarksusy.a
 	$(FF) $(FOPT) $(INC) -L$(LIB) -o caprates_ea caprates_ea.f \
         -ldarksusy -lHB -lFH
diff -rupN darksusy-5.1.3/misc/oh2test.f ../installed/darksusy/5.1.3/misc/oh2test.f
--- darksusy-5.1.3/misc/oh2test.f	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/misc/oh2test.f	2018-07-04 22:31:57.242491877 +0100
@@ -0,0 +1,294 @@
+      program oh2test
+c
+c     This program is a sample DarkSUSY main program. It asks for model
+c     parameters interactively and calculates the relic density and
+c     various rates for each given model. This program can be used
+c     as is for quick calculations, or be modified to your liking for
+c     more advanced uses.
+c
+c     
+c-----This line is 72 columns long--------------------------------------
+c
+      implicit none
+
+      character*80 slhafile
+      real*8 xf,oh2,dsrdomega,dsabsq
+      real*8 dsandwdcosij
+      real*8 wx,dsanwx,wtot
+      real*8 iby,dsibyield
+      integer ierr,iwar,nfc,i,j,istat
+      integer knew(50)
+      logical first
+      data first/.true./
+
+      include 'dsmssm.h'
+      include 'dsio.h'
+      include 'dsidtag.h'
+c      integer flavsortsl(6),flavsortsqu(6),flavsortsqd(6),flavsortsnu(3)
+      data flavsortsl/1,2,3,4,5,6/
+      data flavsortsqu/1,2,3,4,5,6/
+      data flavsortsqd/1,2,3,4,5,6/
+      data flavsortsnu/1,2,3/
+
+c...Initial setup
+      do i=1,50
+         knew(i)=i
+      enddo
+      
+      
+      call dsinit
+
+c      slhafile='slha/GAMBIT_spectrum_all.slha2'
+c      slhafile='slha/GAMBIT_spectrum_sleptons.slha2'
+c      slhafile='slha/GAMBIT_spectrum_squarks.slha2'
+c      slhafile='slha/GAMBIT_spectrum_trilinears.slha2'
+c      slhafile='slha/slepton_wino.slha1'
+      slhafile='../slha2.dat'
+      call dsSLHAread(slhafile,0) ! 0=no warnings, 1=print warnings
+
+
+      write(*,*) ' '
+      write(*,*) '***** MODEL: ',idtag,' *****'
+
+      call dsprep
+      open (unit=30,file='dsmain1.tmp')
+      write(30,*) ' '
+      write(30,*) '***** MODEL: ',idtag,' *****'
+      call dswspectrum(30)
+      call dswvertx(30)
+      call dswwidth(30)
+      close (30)
+
+      write(*,*) pname(ksl(3))
+      write(*,*) 'mass(22) = ',mass(22),pname(22)
+      write(*,*) 'mass(23) = ',mass(23),pname(23)
+      write(*,*) 'mass(25) = ',mass(25),pname(25)
+      write(*,*) 'mass(26) = ',mass(26),pname(26)
+      write(*,*) 'mass(28) = ',mass(28),pname(28)
+      write(*,*) 'mass(29) = ',mass(29),pname(29)
+
+c      write(*,*) gl(kn(1),ksnu(1),knutau)
+c      write(*,*) gl(kn(1),ksnu(2),knutau)
+c      write(*,*) gl(kn(1),ksnu(3),knutau)
+      write(*,*) gl(kcha(1),ksl(1),knutau),pname(ksl(1))
+      write(*,*) gl(kcha(1),ksl(2),knutau),pname(ksl(2))
+      write(*,*) gl(kcha(1),ksl(3),knutau),pname(ksl(3))
+      write(*,*) gl(kcha(1),ksl(4),knutau),pname(ksl(4))
+      write(*,*) gl(kcha(1),ksl(5),knutau),pname(ksl(5))
+      write(*,*) gl(kcha(1),ksl(6),knutau),pname(ksl(6))
+
+      write(*,*) gl(ksqu(1),ksqu(1),kz),pname(ksqu(1))
+      write(*,*) gl(ksqu(3),ksqu(3),kz),pname(ksqu(3))
+      write(*,*) gr(ksqu(1),ksqu(1),kgluon),pname(ksqu(1))
+      write(*,*) gr(ksqu(3),ksqu(3),kgluon),pname(ksqu(3))
+      write(*,*) gl(ksqu(1),ksqu(1),kz),pname(ksqu(1))
+      write(*,*) gl(ksqu(3),ksqu(3),kz),pname(ksqu(3))
+      write(*,*) gr(ksqu(1),ksqu(1),kgluon),pname(ksqu(1))
+      write(*,*) gr(ksqu(3),ksqu(3),kgluon),pname(ksqu(3))
+      write(*,*) gl(kc,kc,kgluon),pname(kc)
+      write(*,*) gr(kc,kc,kgluon),pname(kc)
+
+      write(*,*) ' '
+      write(*,*) gl(kcha(1),ke,knue)
+      write(*,*) gr(kcha(1),ke,knue)
+      write(*,*) gl(kcha(1),ke,knumu)
+      write(*,*) gr(kcha(1),ke,knumu)
+
+      write(*,*) '  Neutralino mass = ',mass(kn(1))
+      write(*,*) '  Gaugino fraction = ',
+     &  dsabsq(neunmx(1,1))+dsabsq(neunmx(1,2))
+      write(*,*) '  Chargino 1 mass = ',mass(kcha(1))
+      write(*,*) '  Chargino 2 mass = ',mass(kcha(2))
+      write(*,*) '  H1 mass =  ',mass(kh1),width(kh1)
+      write(*,*) '  H2 mass =  ',mass(kh2),width(kh2)
+      write(*,*) '  H3 mass =  ',mass(kh3),width(kh3)
+      write(*,*) '  H+- mass = ',mass(khc),width(khc)
+
+      write(*,*) 'Calculating omega h^2 without coannihilations,',
+     &     ' please be patient...'
+      oh2=dsrdomega(0,1,xf,ierr,iwar,nfc)
+      write(*,*) '  without coannihilations Oh2 = ',oh2,ierr,iwar
+      write(*,*) 'Calculating omega h^2 with coannihilations,',
+     &     ' please be patient...'
+      oh2=dsrdomega(1,1,xf,ierr,iwar,nfc)
+      write(*,*) '  with coannihilations Oh2 = ',oh2,ierr,iwar
+      write(*,*) '  Chemical decoupling (freeze-out) occured at'
+      write(*,*) '  T_f = ',mass(kn(1))/xf,' GeV.'
+
+      iby=dsibyield(120.d0,152,istat)
+      write(*,*) 'IB gamma yield at 120 GeV = ',iby
+      iby=dsibyield(400.d0,152,istat)
+      write(*,*) 'IB gamma yield at 400 GeV = ',iby
+
+      wx=dsanwx(100.d0)
+      write(*,*) 'Invariant rate at 100 GeV: ',wx
+      wx=dsandwdcosij(100.d0,0.5d0,42,22)
+      write(*,*) 'chi_1^0 s_l_1, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,42,23)
+      write(*,*) 'chi_1^0 s_l_2, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,42,25)
+      write(*,*) 'chi_1^0 s_l_3, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,42,26)
+      write(*,*) 'chi_1^0 s_l_4, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,42,28)
+      write(*,*) 'chi_1^0 s_l_5, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,42,29)
+      write(*,*) 'chi_1^0 s_l_6, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,42,30)
+      write(*,*) 'chi_1^0 u~1, dsandwdcosij=',wx
+      write(*,*) ' '
+      wx=dsandwdcosij(100.d0,0.5d0,46,22)
+      write(*,*) 'chi_1^+ s_l_1, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,46,23)
+      write(*,*) 'chi_1^+ s_l_2, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,46,25)
+      write(*,*) 'chi_1^+ s_l_3, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,46,26)
+      write(*,*) 'chi_1^+ s_l_4, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,46,28)
+      write(*,*) 'chi_1^+ s_l_5, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,46,29)
+      write(*,*) 'chi_1^+ s_l_6, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,46,30)
+      write(*,*) 'chi_1^+ u~1, dsandwdcosij=',wx
+      write(*,*) ' '
+      wx=dsandwdcosij(100.d0,0.5d0,22,22)
+      write(*,*) 's_l_1 s_l_1, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,23,23)
+      write(*,*) 's_l_2 s_l_2, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,25,25)
+      write(*,*) 's_l_3 s_l_3, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,26,26)
+      write(*,*) 's_l_4 s_l_4, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,28,28)
+      write(*,*) 's_l_5 s_l_5, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,29,29)
+      write(*,*) 's_l_6 s_l_6, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,28,22)
+      write(*,*) 's_l_5 s_l_1, dsandwdcosij=',wx
+
+
+      write(*,*) ' '
+      wx=dsandwdcosij(100.d0,0.5d0,22,30)
+      write(*,*) 's_l_1 s_u_1, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,22,32)
+      write(*,*) 's_l_1 s_d_1, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,28,38)
+      write(*,*) 's_l_5 s_u_5, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,28,40)
+      write(*,*) 's_l_5 s_d_5, dsandwdcosij=',wx
+
+      write(*,*) ' '
+      wx=dsandwdcosij(100.d0,0.5d0,30,30)
+      write(*,*) 's_u_1 s_u_1, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,31,31)
+      write(*,*) 's_u_2 s_u_2, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,34,34)
+      write(*,*) 's_u_3 s_u_3, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,35,35)
+      write(*,*) 's_u_4 s_u_4, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,38,38)
+      write(*,*) 's_u_5 s_u_5, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,39,39)
+      write(*,*) 's_u_6 s_u_6, dsandwdcosij=',wx
+      write(*,*) ' '
+      wx=dsandwdcosij(100.d0,0.5d0,32,32)
+      write(*,*) 's_d_1 s_d_1, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,33,33)
+      write(*,*) 's_d_2 s_d_2, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,36,36)
+      write(*,*) 's_d_3 s_d_3, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,37,37)
+      write(*,*) 's_d_4 s_d_4, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,40,40)
+      write(*,*) 's_d_5 s_d_5, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,41,41)
+      write(*,*) 's_d_6 s_d_6, dsandwdcosij=',wx
+
+      write(*,*) ' '
+      wx=dsandwdcosij(100.d0,0.5d0,30,32)
+      write(*,*) 's_u_1 s_d_1, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,38,40)
+      write(*,*) 's_u_5 s_d_5, dsandwdcosij=',wx
+
+      write(*,*) ' '
+      wx=dsandwdcosij(100.d0,0.5d0,42,42)
+      write(*,*) 'chi_1^0 chi_1^0, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,42,43)
+      write(*,*) 'chi_1^0 chi_2^0, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,46,46)
+      write(*,*) 'chi_1^+ chi_1^+, dsandwdcosij=',wx
+      wx=dsandwdcosij(100.d0,0.5d0,42,46)
+      write(*,*) 'chi_1^0 chi_1^+, dsandwdcosij=',wx
+      
+      write(*,*) 'Now performing full test...'
+
+c...Manual reordering in other direction      
+c      flavsortsl(1)=3
+c      flavsortsl(2)=2
+c      flavsortsl(3)=1
+c      flavsortsl(4)=6
+c      flavsortsl(5)=5
+c      flavsortsl(6)=4
+
+c      flavsortsqu(1)=3
+c      flavsortsqu(2)=6
+c      flavsortsqu(3)=2
+c      flavsortsqu(4)=1
+c      flavsortsqu(5)=5
+c      flavsortsqu(6)=4
+
+c      flavsortsqd(1)=3
+c      flavsortsqd(2)=6
+c      flavsortsqd(3)=2
+c      flavsortsqd(4)=1
+c      flavsortsqd(5)=5
+c      flavsortsqd(6)=4
+
+c      flavsortsnu(1)=3
+c      flavsortsnu(2)=2
+c      flavsortsnu(3)=1
+c...Reorder knew
+c      do i=1,6         
+c         knew(ksl(i))=ksl(flavsortsl(i))
+c         knew(ksqu(i))=ksqu(flavsortsqu(i))
+c         knew(ksqd(i))=ksqd(flavsortsqd(i))
+c      enddo
+c      do i=1,3
+c         knew(ksnu(i))=ksnu(flavsortsnu(i))
+c      enddo
+      
+      
+      wtot=0.d0
+      do i=21,47 ! 30,41 ! 21,29  ! 21,47
+         do j=21,47 ! 30,41 ! 21,29 ! 21,47
+            wx=dsandwdcosij(100.d0,0.5d0,knew(i),knew(j))
+     &           +dsandwdcosij(100.d0,-0.5d0,knew(i),knew(j))
+            write(*,*) i,j,wx
+            write(47,*) i,j,wx
+            wtot=wtot+wx
+         enddo
+      enddo
+      write(*,*) 'wtot = ',wtot
+      
+
+      wx=dsandwdcosij(100.d0,0.5d0,46,21)
+      write(*,*) 'chi_1^+ snu_e wx = ',wx
+      wx=dsandwdcosij(100.d0,0.5d0,21,24)
+      write(*,*) 'snu_e snu_mu wx = ',wx
+      wx=dsandwdcosij(100.d0,0.5d0,21,25)
+      write(*,*) 'snu_e smu_1 wx = ',wx
+      wx=dsandwdcosij(100.d0,-0.5d0,21,25)
+      write(*,*) 'snu_e smu_1 wx = ',wx
+      wx=dsandwdcosij(100.d0,0.5d0,21,22)
+      write(*,*) 'snu_e se_1 wx = ',wx
+
+      write(*,*) ' '
+      wx=dsandwdcosij(100.d0,0.5d0,34,41)
+      write(*,*) 'c_1 b_1 wx = ',wx
+
+      write(*,*) ' '
+      wx=dsandwdcosij(100.d0,0.5d0,ksl(1),ksl(2))
+      write(*,*) 'sl_1 sl_2 wx = ',wx
+      
+      end
diff -rupN darksusy-5.1.3/share/DarkSUSY/tab_install.pl ../installed/darksusy/5.1.3/share/DarkSUSY/tab_install.pl
--- darksusy-5.1.3/share/DarkSUSY/tab_install.pl	2008-04-11 10:31:28.000000000 +0100
+++ ../installed/darksusy/5.1.3/share/DarkSUSY/tab_install.pl	2018-07-04 22:31:57.242491877 +0100
@@ -12,7 +12,7 @@ if ($file =~ /.gz$/) {    # Convert asci
 #    } else {
 #	$type="d";
 #    }
-    $tmpfile="tmp.dat";
+    $tmpfile="$file-tmp";
     system("gunzip -v -c $file > $tmpfile");
 # Now we are ready to run ascii2bin
     open(PROG,"|./ascii2bin") ||
diff -rupN darksusy-5.1.3/src/as/dsaschicasea.f ../installed/darksusy/5.1.3/src/as/dsaschicasea.f
--- darksusy-5.1.3/src/as/dsaschicasea.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/as/dsaschicasea.f	2018-07-04 22:31:57.242491877 +0100
@@ -177,9 +177,13 @@ c....mass symbols used in form-code
           kchiu(k+2)=0
         enddo
         nchiu=2
-***** in the s-channel (1 fermion):
-        kfers(1)=kcfers
-        nfers=1
+***** in the s-channel (3 fermion): ! JE CORR 1->3
+c        kfers(1)=kcfers
+c        nfers=1
+        nfers=ncfers
+        do i=1,nfers
+           kfers(i)=kcfersv(i)
+        enddo
         goto 100
       endif
 *****
@@ -217,14 +221,14 @@ c....mass symbols used in form-code
         enddo
 ***** in the u-channel (4 neutralinos):
 ***** only when initial/final state (s)fermions are of same family
-        if(iifam(1).eq.ivfam(kfer)) then
-          do k=1,4
+c        if(iifam(1).eq.ivfam(kfer)) then
+          do k=1,4 ! JE CORR due to sfermion mixing
             kchiu(k)=kn(k)
           enddo
           nchiu=4
-	else
-          nchiu=0
-        endif
+c	else
+c          nchiu=0
+c        endif
 ***** no s-channel:
         nfers=0
         goto 100
@@ -239,15 +243,16 @@ c....mass symbols used in form-code
         nsfert=0 
 ***** in the u-channel (4 neutralinos):
 ***** only when initial/final state (s)fermions are of same family
-        if(iifam(1).eq.ivfam(kfer)) then
-          do k=1,4
+c        if(iifam(1).eq.ivfam(kfer)) then
+          do k=1,4 ! JE CORR, always include, due to sfermion mixings
             kchiu(k)=kn(k)
           enddo
           nchiu=4
-        else
-          nchiu=0
-        endif
-***** in the s-channel (1 lepton or 3 quarks):
+c        else
+c          nchiu=0
+c        endif
+        
+***** in the s-channel (3 leptons or 3 quarks):
         nfers=ncferd
         do i=1,nfers
           kfers(i)=kcferd(i)
diff -rupN darksusy-5.1.3/src/as/dsaschicaseb.f ../installed/darksusy/5.1.3/src/as/dsaschicaseb.f
--- darksusy-5.1.3/src/as/dsaschicaseb.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/as/dsaschicaseb.f	2018-07-04 22:31:57.246489878 +0100
@@ -171,9 +171,13 @@ c....mass symbols used in form-code
           kchiu(k+2)=0
         enddo
         nchiu=2
-***** in the s-channel (1 fermion): 
-        kfers(1)=kcfers
-        nfers=1
+***** in the s-channel (3 fermion): ! JE CORR 1->3
+c        kfers(1)=kcfers
+c        nfers=1
+        nfers=ncfers ! JE CORR 4 lines
+        do i=1,nfers
+           kfers(i)=kcfersv(i)
+        enddo
         goto 200
       endif
 *****
@@ -185,15 +189,15 @@ c....mass symbols used in form-code
 ***** no t-channel:  
         nsfert=0
 ***** in the u-channel (0 or 4 neutralinos):
-        if(iifam(1).eq.ivfam(kfer)) then
-          do k=1,4
+c        if(iifam(1).eq.ivfam(kfer)) then
+          do k=1,4 ! JE CORR due to sfermion mixing
             kchiu(k)=kn(k)
           enddo
           nchiu=4
-        else
-          nchiu=0
-        endif
-***** in the s-channel (1 lepton or 3 quarks):
+c        else
+c          nchiu=0
+c        endif
+***** in the s-channel (3 leptons or 3 quarks):
         nfers=ncferd
         do i=1,nfers
           kfers(i)=kcferd(i)
@@ -212,14 +216,14 @@ c....mass symbols used in form-code
           ksfert(i)=kcsfertc(i)
         enddo
 ***** in the u-channel (0 or 4 neutralinos):
-        if(iifam(1).eq.ivfam(kfer)) then
-          do k=1,4
+c        if(iifam(1).eq.ivfam(kfer)) then
+          do k=1,4 ! JE CORR due to sfermion mixing
             kchiu(k)=kn(k)
           enddo
           nchiu=4
-        else
-          nchiu=0
-        endif
+c        else
+c          nchiu=0
+c        endif
 ***** no s-channel:
         nfers=0
         goto 200
diff -rupN darksusy-5.1.3/src/as/dsaschicasec.f ../installed/darksusy/5.1.3/src/as/dsaschicasec.f
--- darksusy-5.1.3/src/as/dsaschicasec.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/as/dsaschicasec.f	2018-07-04 22:31:57.246489878 +0100
@@ -227,9 +227,13 @@ c....mass symbols used in form-code
           kchiu(k+2)=0
         enddo
         nchiu=2
-***** in the s-channel (1 fermion):
-        kfers(1)=kcfers
-        nfers=1
+***** in the s-channel (3 fermion): ! JE CORR 1->3
+c        kfers(1)=kcfers
+c        nfers=1
+        nfers=ncfers ! JE CORR 4 lines
+        do i=1,nfers
+           kfers(i)=kcfersv(i)
+        enddo
         goto 300
       endif
 *****
@@ -244,14 +248,14 @@ c....mass symbols used in form-code
           ksfert(i)=kcsfertc(i)
         enddo
 ***** in the u-channel (0 or 4 neutralinos):
-        if(iifam(1).eq.ivfam(kfer)) then
-          do k=1,4
+c        if(iifam(1).eq.ivfam(kfer)) then
+          do k=1,4 ! JE CORR due to sfermion mixing
             kchiu(k)=kn(k)
           enddo
           nchiu=4
-        else
-          nchiu=0
-        endif
+c        else
+c          nchiu=0
+c        endif
 ***** no s-channel:
         nfers=0       
         goto 300
@@ -265,15 +269,15 @@ c....mass symbols used in form-code
 ***** no t-channel:  
         nsfert=0 
 ***** in the u-channel (0 or 4 neutralinos):
-        if(iifam(1).eq.ivfam(kfer)) then
-          do k=1,4
+c        if(iifam(1).eq.ivfam(kfer)) then
+          do k=1,4 ! JE CORR, always include due to sfermion mixing
             kchiu(k)=kn(k)
           enddo
           nchiu=4
-        else
-          nchiu=0
-        endif
-***** in the s-channel (1 lepton or 3 quarks):
+c        else
+c          nchiu=0
+c        endif
+***** in the s-channel (3 leptons or 3 quarks):
         nfers=ncferd
         do i=1,nfers
           kfers(i)=kcferd(i)
diff -rupN darksusy-5.1.3/src/as/dsaschicased.f ../installed/darksusy/5.1.3/src/as/dsaschicased.f
--- darksusy-5.1.3/src/as/dsaschicased.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/as/dsaschicased.f	2018-07-04 22:31:57.246489878 +0100
@@ -194,9 +194,13 @@ c....mass symbols used in form-code
           kchiu(k+2)=0
         enddo
         nchiu=2
-***** in the s-channel (1 fermion):
-        kfers(1)=kcfers
-        nfers=1
+***** in the s-channel (3 fermion): ! JE CORR 1->3
+c        kfers(1)=kcfers
+c        nfers=1
+        nfers=ncfers ! JE CORR 4 lines
+        do i=1,nfers
+           kfers(i)=kcfersv(i)
+        enddo
         goto 400
       endif  
 *****
@@ -208,15 +212,15 @@ c....mass symbols used in form-code
 ***** no t-channel:
         nsfert=0
 ***** in the u-channel (0 or 4 neutralinos):
-        if(iifam(1).eq.ivfam(kfer)) then
-          do k=1,4
+c        if(iifam(1).eq.ivfam(kfer)) then
+          do k=1,4 ! JE CORR due to sfermion mixing
             kchiu(k)=kn(k)
           enddo
           nchiu=4
-        else
-          nchiu=0
-        endif
-***** in the s-channel (1 or 3 fermions):
+c        else
+c          nchiu=0
+c        endif
+***** in the s-channel (3 fermions):
         nfers=ncferd
         do i=1,nfers
           kfers(i)=kcferd(i)
@@ -235,14 +239,14 @@ c....mass symbols used in form-code
           ksfert(i)=kcsfertc(i)
         enddo
 ***** in the u-channel (0 or 4 neutralinos):
-        if(iifam(1).eq.ivfam(kfer)) then
-          do k=1,4
+c        if(iifam(1).eq.ivfam(kfer)) then
+          do k=1,4 ! JE CORR due to sfermion mixing
             kchiu(k)=kn(k)
           enddo
           nchiu=4
-        else
-          nchiu=0
-        endif 
+c        else
+c          nchiu=0
+c        endif 
 ***** no s-channel:
         nfers=0
         goto 400
diff -rupN darksusy-5.1.3/src/as/dsasdwdcossfchi.f ../installed/darksusy/5.1.3/src/as/dsasdwdcossfchi.f
--- darksusy-5.1.3/src/as/dsasdwdcossfchi.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/as/dsasdwdcossfchi.f	2018-07-04 22:31:57.246489878 +0100
@@ -15,6 +15,8 @@
 ***   final state quarks in selected cases, June 2006, Jan 2007      ***
 *** modified: Piero Ullio to include a new labelling of states,      ***
 ***   08-05-30                                                       ***
+*** modified: Joakim Edsjo to properly include inter-family mixing   ***
+***   2016-10-29                                                     ***
 ************************************************************************
 
       real*8 function dsasdwdcossfchi(p,costhe,kp1,kp2)
@@ -24,7 +26,7 @@
       include 'dsandwcom.h'
       include 'dsidtag.h'
       real*8 p,costhe
-      integer kp1,kp2,kp3,kp4,kp2int,i,f,fsave,icase
+      integer kp1,kp2,kp3,kp4,kp2int,i,f,icase
       real*8 w,par
       logical wok
 ************************************************************************
@@ -69,40 +71,91 @@
         do i=1,54
           prtial(i)=0.0d0
         enddo
-        if(kp1.ne.kp1c.or.kp2int.ne.kp2c) then
+        if(kp1.ne.kp1c.or.kp2int.ne.kp2c) then ! to save CPU, don't recalc
         kp1c=kp1
         kp2c=kp2int
         cgammain=.false.
         cgluonin=.false.
         ciaux=iifam(1)/10
         ciaux=iifam(1)-ciaux*10
-        do f=knue,kb
-          if(iifam(1).eq.ivfam(f)) then 
-            fsave=f
-          endif
-        enddo
-        kcfers=fsave
-        if(kcfers.le.ktau.and.kcfers.ge.knue) then
-          if(ciaux.eq.1) then
-            ncsfert=1
-            kcsfertn(1)=ksnu((fsave+1)/2)
-            ncferd=1
-            kcferd(1)=fsave+1
-          endif
-          if(ciaux.eq.2) then
-            ncsfert=2
-            kcsfertn(1)=ksl(fsave/2)
-            kcsfertn(2)=ksl(fsave/2+3)
-            ncferd=1
-            kcferd(1)=fsave-1
+c        do f=knue,kb ! not needed anymore (JE)
+c          if(iifam(1).eq.ivfam(f)) then 
+c            fsave=f
+c          endif
+c        enddo
+c        kcfers=fsave
+c...Add virtual s-channel fermions (made array by 3)
+        ncfers=3
+        if (iifam(1).eq.12.or.iifam(1).eq.22.or.iifam(1).eq.32) then
+           kcfersv(1)=ke
+           kcfersv(2)=kmu
+           kcfersv(3)=ktau
+        elseif (iifam(1).eq.11.or.iifam(1).eq.21.or.iifam(1).eq.31) then
+           kcfersv(1)=knue
+           kcfersv(2)=knumu
+           kcfersv(3)=knutau
+        elseif (iifam(1).eq.42.or.iifam(1).eq.52.or.iifam(1).eq.62) then
+           kcfersv(1)=kd
+           kcfersv(2)=ks
+           kcfersv(3)=kb
+        elseif (iifam(1).eq.41.or.iifam(1).eq.51.or.iifam(1).eq.61) then
+           kcfersv(1)=ku
+           kcfersv(2)=kc
+           kcfersv(3)=kt
+        else
+           write(*,*) 'ERROR in DS: dsasdwdcossfchi:'
+           write(*,*) 'Illegal iifam= ',iifam(1)
+           write(*,*) 'Something is wrong.'
+           stop
+        endif
+        
+        if(kcfersv(1).le.ktau.and.kcfersv(1).ge.knue) then ! slepton case
+          if(ciaux.eq.1) then ! sneutrino
+c            ncsfert=1 ! add all three?
+c            kcsfertn(1)=ksnu((fsave+1)/2)
+             ncsfert=3 ! JE CORRECTION these 4 lines
+             kcsfertn(1)=ksnu(1)
+             kcsfertn(2)=ksnu(2)
+             kcsfertn(3)=ksnu(3)
+c            ncferd=1 ! add all three
+c            kcferd(1)=fsave+1
+             ncferd=3 ! JE CORRECTION these 4 lines
+             kcferd(1)=ke
+             kcferd(2)=kmu
+             kcferd(3)=ktau
+          endif
+          if(ciaux.eq.2) then ! charged slepton
+c            ncsfert=2 ! add all six?
+c            kcsfertn(1)=ksl(fsave/2)
+c            kcsfertn(2)=ksl(fsave/2+3)
+            ncsfert=6 ! JE CORRECTION these 7 lines
+            kcsfertn(1)=ksl(1)
+            kcsfertn(2)=ksl(2)
+            kcsfertn(3)=ksl(3)
+            kcsfertn(4)=ksl(4)
+            kcsfertn(5)=ksl(5)
+            kcsfertn(6)=ksl(6)
+c            ncferd=1 ! add all three?
+c            kcferd(1)=fsave-1
+            ncferd=3 ! JE CORRECTION these 4 lines
+            kcferd(1)=knue
+            kcferd(2)=knumu
+            kcferd(3)=knutau
             cgammain=.true.
           endif
         endif
-        if(kcfers.le.kb.and.kcfers.ge.ku) then
-          if(ciaux.eq.1) then
-            ncsfert=2
-            kcsfertn(1)=ksqu((fsave-6+1)/2)
-            kcsfertn(2)=ksqu((fsave-6+1)/2+3)
+        if(kcfersv(1).le.kb.and.kcfersv(1).ge.ku) then ! squarks
+          if(ciaux.eq.1) then ! up type 
+c            ncsfert=2 ! add all 6?
+c            kcsfertn(1)=ksqu((fsave-6+1)/2)
+c            kcsfertn(2)=ksqu((fsave-6+1)/2+3)
+            ncsfert=6 ! JE CORRECTION these 7 lines
+            kcsfertn(1)=ksqu(1)
+            kcsfertn(2)=ksqu(2)
+            kcsfertn(3)=ksqu(3)
+            kcsfertn(4)=ksqu(4)
+            kcsfertn(5)=ksqu(5)
+            kcsfertn(6)=ksqu(6)
             ncferd=3
             kcferd(1)=kd
             kcferd(2)=ks
@@ -110,10 +163,17 @@
             cgammain=.true.
             cgluonin=.true.
           endif
-          if(ciaux.eq.2) then
-            ncsfert=2
-            kcsfertn(1)=ksqd((fsave-6)/2)
-            kcsfertn(2)=ksqd((fsave-6)/2+3)
+          if(ciaux.eq.2) then ! down type
+c            ncsfert=2 ! add all 6?
+c            kcsfertn(1)=ksqd((fsave-6)/2)
+c            kcsfertn(2)=ksqd((fsave-6)/2+3)
+            ncsfert=6 ! JE CORRECTION these 7 lines
+            kcsfertn(1)=ksqd(1)
+            kcsfertn(2)=ksqd(2)
+            kcsfertn(3)=ksqd(3)
+            kcsfertn(4)=ksqd(4)
+            kcsfertn(5)=ksqd(5)
+            kcsfertn(6)=ksqd(6)
             ncferd=3
             kcferd(1)=ku
             kcferd(2)=kc
@@ -126,92 +186,141 @@
         endif
 ******************************************************** sf chi^0 -> Z f
         kp3=kz
-        kp4=kcfers
         icase=1
-        call dsaschicasea(kp1,kp2,kp3,kp4,icase,par)
-        prtial(1)=par
+        do f=1,3
+c           kcfers=kcfersv(f)
+           kp4=kcfersv(f)
+           call dsaschicasea(kp1,kp2,kp3,kp4,icase,par)
+           prtial(1)=prtial(1)+par
+        enddo
+
 **************************************************** sf chi^0 -> gamma f
         if(cgammain) then
           kp3=kgamma
-          kp4=kcfers
           icase=7
-          call dsaschizero(kp1,kp2,kp3,kp4,icase,par)
-          prtial(2)=par
+          do f=1,3
+c             kcfers=kcfersv(f)
+             kp4=kcfersv(f)
+             call dsaschizero(kp1,kp2,kp3,kp4,icase,par)
+             prtial(2)=prtial(2)+par
+          enddo
         endif
 ******************************************************** sf chi^0 -> h f
         kp3=kh2
-        kp4=kcfers
         icase=1
-        call dsaschicasec(kp1,kp2,kp3,kp4,icase,par)
-        prtial(3)=par
+        do f=1,3
+c           kcfers=kcfersv(f)
+           kp4=kcfersv(f)
+           call dsaschicasec(kp1,kp2,kp3,kp4,icase,par)
+           prtial(3)=prtial(3)+par
+        enddo
 ******************************************************** sf chi^0 -> H f
         kp3=kh1
-        kp4=kcfers
         icase=1
-        call dsaschicasec(kp1,kp2,kp3,kp4,icase,par)
-        prtial(4)=par
+        do f=1,3
+c           kcfers=kcfersv(f)
+           kp4=kcfersv(f)
+           call dsaschicasec(kp1,kp2,kp3,kp4,icase,par)
+           prtial(4)=prtial(4)+par
+        enddo
 ******************************************************** sf chi^0 -> a f
         kp3=kh3
-        kp4=kcfers
         icase=2
-        call dsaschicasec(kp1,kp2,kp3,kp4,icase,par)
-        prtial(5)=par
+        do f=1,3
+c           kcfers=kcfersv(f)
+           kp4=kcfersv(f)
+           call dsaschicasec(kp1,kp2,kp3,kp4,icase,par)
+           prtial(5)=prtial(5)+par
+        enddo
 **************************************************** sf chi^0 -> gluon f
         if(cgluonin) then
           kp3=kgluon
-          kp4=kcfers
           icase=9
-          call dsaschizero(kp1,kp2,kp3,kp4,icase,par)
-          prtial(8)=par
+          do f=1,3
+c             kcfers=kcfersv(f)
+             kp4=kcfersv(f)
+             call dsaschizero(kp1,kp2,kp3,kp4,icase,par)
+             prtial(8)=prtial(8)+par
+          enddo
         endif
 ********
-        if(ciaux.eq.1) then
+c        kcfers=fsave ! FIX ME is this needed?
+        if(ciaux.eq.1) then ! up type
           prtial(6)=0.d0
           prtial(7)=0.d0
           do i=1,ncferd
             kp4=kcferd(i)
             if(kp4.le.ktau.and.kp4.ge.knue) then
-              ncsfertc=2
-              kcsfertc(1)=ksl(kp4/2)
-              kcsfertc(2)=ksl(kp4/2+3)
+c              ncsfertc=2
+c              kcsfertc(1)=ksl(kp4/2)
+c              kcsfertc(2)=ksl(kp4/2+3)
+               ncsfertc=6 ! JE CORRECTION these 7 lines
+               kcsfertc(1)=ksl(1)
+               kcsfertc(2)=ksl(2)
+               kcsfertc(3)=ksl(3)
+               kcsfertc(4)=ksl(4)
+               kcsfertc(5)=ksl(5)
+               kcsfertc(6)=ksl(6)
             else
-              ncsfertc=2
-              kcsfertc(1)=ksqd((kp4-6)/2)
-              kcsfertc(2)=ksqd((kp4-6)/2+3)
+c              ncsfertc=2
+c              kcsfertc(1)=ksqd((kp4-6)/2)
+c              kcsfertc(2)=ksqd((kp4-6)/2+3)
+               ncsfertc=6 ! JE CORRECTION these 7 lines
+               kcsfertc(1)=ksqd(1)
+               kcsfertc(2)=ksqd(2)
+               kcsfertc(3)=ksqd(3)
+               kcsfertc(4)=ksqd(4)
+               kcsfertc(5)=ksqd(5)
+               kcsfertc(6)=ksqd(6)
             endif
 *********************************************** sfu^* chi^0 -> W^- fdbar
             kp3=kw
             icase=2
+c            kcfers=kp4 ! JE CORRECTION
             call dsaschicaseb(kp1,kp2,kp3,kp4,icase,par)
             prtial(6)=prtial(6)+par   
 *********************************************** sfu^* chi^0 -> h^- fdbar
             kp3=khc
             icase=3
+c            kcfers=kp4 ! JE CORRECTION
             call dsaschicased(kp1,kp2,kp3,kp4,icase,par)
             prtial(7)=prtial(7)+par
           enddo
-        elseif(ciaux.eq.2) then  
+        elseif(ciaux.eq.2) then  ! down type
 ********
           prtial(6)=0.d0
           prtial(7)=0.d0
           do i=1,ncferd
             kp4=kcferd(i)
             if(kp4.le.ktau.and.kp4.ge.knue) then
-              ncsfertc=1
-              kcsfertc(1)=ksnu((kp4+1)/2)
+c              ncsfertc=1
+c              kcsfertc(1)=ksnu((kp4+1)/2)
+               ncsfertc=3 ! JE CORRECTION these 4 lines
+               kcsfertc(1)=ksnu(1)
+               kcsfertc(2)=ksnu(2)
+               kcsfertc(3)=ksnu(3)
             else
-              ncsfertc=2
-              kcsfertc(1)=ksqu((kp4-6+1)/2)
-              kcsfertc(2)=ksqu((kp4-6+1)/2+3)
+c              ncsfertc=2
+c              kcsfertc(1)=ksqu((kp4-6+1)/2)
+c              kcsfertc(2)=ksqu((kp4-6+1)/2+3)
+              ncsfertc=6 ! JE CORRECTION these 7 lines
+              kcsfertc(1)=ksqu(1)
+              kcsfertc(2)=ksqu(2)
+              kcsfertc(3)=ksqu(3)
+              kcsfertc(4)=ksqu(4)
+              kcsfertc(5)=ksqu(5)
+              kcsfertc(6)=ksqu(6)
             endif
 **************************************************** sfd chi^0 -> W^- fu
             kp3=kw
             icase=2
+c            kcfers=kp4+1 ! JE CORRECTION
             call dsaschicasea(kp1,kp2,kp3,kp4,icase,par)
             prtial(6)=prtial(6)+par
 **************************************************** sfd chi^0 -> h^- fu
             kp3=khc
             icase=4
+c            kcfers=kp4+1 ! JE CORRECTION
             call dsaschicasec(kp1,kp2,kp3,kp4,icase,par)
             prtial(7)=prtial(7)+par
           enddo
@@ -233,6 +342,15 @@
                                  ! or  sfd chi^0 -> h^- fu
         w=w+prtial(8)            ! sf chi^0 -> gluon f
         dsasdwdcossfchi = w      ! The weighting factor is 1
+c        write(*,*) 'sfchi, prtial(1)=',prtial(1)
+c        write(*,*) 'sfchi, prtial(2)=',prtial(2)
+c        write(*,*) 'sfchi, prtial(3)=',prtial(3)
+c        write(*,*) 'sfchi, prtial(4)=',prtial(4)
+c        write(*,*) 'sfchi, prtial(5)=',prtial(5)
+c        write(*,*) 'sfchi, prtial(6)=',prtial(6)
+c        write(*,*) 'sfchi, prtial(7)=',prtial(7)
+c        write(*,*) 'sfchi, prtial(8)=',prtial(8)
+c        write(*,*) 'sfchi, w=',w
 
 ************************************************************************
 *****
@@ -241,51 +359,124 @@
         do i=1,54
           prtial(i)=0.0d0
         enddo
-        if(kp1.ne.kp1c.or.kp2int.ne.kp2c) then
+        if(kp1.ne.kp1c.or.kp2int.ne.kp2c) then ! only recalcualte when needed
         kp1c=kp1
         kp2c=kp2int
         cgluonin=.false.
         ciaux=iifam(1)/10
         ciaux=iifam(1)-ciaux*10
-        do f=knue,kb
-          if(iifam(1).eq.ivfam(f)) then 
-            fsave=f
-          endif
-        enddo
-        kcfers=fsave
-        if(kcfers.le.ktau.and.kcfers.ge.knue) then
-          if(ciaux.eq.1) then
-            ncsfert=1
-            kcsfertn(1)=ksnu((fsave+1)/2)
-            ncfers=1
-            kcfersv(1)=kcfers
-            ncferd=1
-            kcferd(1)=fsave+1
-            ncsfertc=2
-            kcsfertc(1)=ksl((fsave+1)/2)
-            kcsfertc(2)=ksl((fsave+1)/2+3)
-          endif
-          if(ciaux.eq.2) then
-            ncsfert=2
-            kcsfertn(1)=ksl(fsave/2)
-            kcsfertn(2)=ksl(fsave/2+3)
-            ncfers=1
-            kcfersv(1)=kcfers
-            ncferd=1
-            kcferd(1)=fsave-1
-            ncsfertc=1
-            kcsfertc(1)=ksnu(fsave/2)
+c        do f=knue,kb! not needed anymore
+c          if(iifam(1).eq.ivfam(f)) then 
+c            fsave=f
+c          endif
+c        enddo
+c        kcfers=fsave
+c JE FIX. Is this enough with fsave and kcfers? Do we need to make kcfers an
+c array of dimension 3
+c...JE CORRECTION
+c...Add final state fermions to be used in this routine
+        ncfers=3
+        if (iifam(1).eq.12.or.iifam(1).eq.22.or.iifam(1).eq.32) then
+           kcfersv(1)=ke
+           kcfersv(2)=kmu
+           kcfersv(3)=ktau
+        elseif (iifam(1).eq.11.or.iifam(1).eq.21.or.iifam(1).eq.31) then
+           kcfersv(1)=knue
+           kcfersv(2)=knumu
+           kcfersv(3)=knutau
+        elseif (iifam(1).eq.42.or.iifam(1).eq.52.or.iifam(1).eq.62) then
+           kcfersv(1)=kd
+           kcfersv(2)=ks
+           kcfersv(3)=kb
+        elseif (iifam(1).eq.41.or.iifam(1).eq.51.or.iifam(1).eq.61) then
+           kcfersv(1)=ku
+           kcfersv(2)=kc
+           kcfersv(3)=kt
+        else
+           write(*,*) 'ERROR in DS: dsasdwdcossfchi:'
+           write(*,*) 'Illegal iifam= ',iifam(1)
+           write(*,*) 'Something is wrong.'
+           stop
+        endif
+
+        if(kcfersv(1).le.ktau.and.kcfersv(1).ge.knue) then
+          if(ciaux.eq.1) then ! sneutrino
+c            ncsfert=1
+c            kcsfertn(1)=ksnu((fsave+1)/2)
+            ncsfert=3 ! JE CORRECTION these 4 lines
+            kcsfertn(1)=ksnu(1)
+            kcsfertn(2)=ksnu(2)
+            kcsfertn(3)=ksnu(3)
+c            ncfers=1
+c            kcfersv(1)=kcfers
+c            ncfers=3 ! JE CORRECTION these 4 lines ! done already
+c            kcfersv(1)=kcfinal(1)
+c            kcfersv(2)=kcfinal(2)
+c            kcfersv(3)=kcfinal(3)
+c            ncferd=1
+c            kcferd(1)=fsave+1
+            ncferd=3 ! JE CORRECTION these 4 lines
+            kcferd(1)=ke
+            kcferd(2)=kmu
+            kcferd(3)=ktau
+c            ncsfertc=2
+c            kcsfertc(1)=ksl((fsave+1)/2)
+c            kcsfertc(2)=ksl((fsave+1)/2+3)
+           ncsfertc=6 ! JE CORRECTION these 7 lines
+           kcsfertc(1)=ksl(1)
+           kcsfertc(2)=ksl(2)
+           kcsfertc(3)=ksl(3)
+           kcsfertc(4)=ksl(4)
+           kcsfertc(5)=ksl(5)
+           kcsfertc(6)=ksl(6)
+          endif
+          if(ciaux.eq.2) then ! charged slepton
+c            ncsfert=2
+c            kcsfertn(1)=ksl(fsave/2)
+c            kcsfertn(2)=ksl(fsave/2+3)
+            ncsfert=6 ! JE CORRECTION these 7 lines
+            kcsfertn(1)=ksl(1)
+            kcsfertn(2)=ksl(2)
+            kcsfertn(3)=ksl(3)
+            kcsfertn(4)=ksl(4)
+            kcsfertn(5)=ksl(5)
+            kcsfertn(6)=ksl(6)
+c            ncfers=1
+c            kcfersv(1)=kcfers
+c            ncfers=3 ! JE CORRECTION these 4 lines ! done already
+c            kcfersv(1)=kcfinal(1)
+c            kcfersv(2)=kcfinal(2)
+c            kcfersv(3)=kcfinal(3)
+c            ncferd=1
+c            kcferd(1)=fsave-1
+            ncferd=3 ! JE CORRECTION these 4 lines
+            kcferd(1)=knue
+            kcferd(2)=knumu
+            kcferd(3)=knutau
+c            ncsfertc=1
+c            kcsfertc(1)=ksnu(fsave/2)
+            ncsfertc=3 ! JE CORRECTION these 4 lines
+            kcsfertc(1)=ksnu(1)
+            kcsfertc(2)=ksnu(2)
+            kcsfertc(3)=ksnu(3)
           endif
         endif
-        if(kcfers.le.kb.and.kcfers.ge.ku) then
-          if(ciaux.eq.1) then
-            ncsfert=2
-            kcsfertn(1)=ksqu((fsave-6+1)/2)
-            kcsfertn(2)=ksqu((fsave-6+1)/2+3)
-            ncfers=3
-            kcfersv(1)=ku
-            kcfersv(2)=kc
-            kcfersv(3)=kt
+        if(kcfersv(1).le.kb.and.kcfersv(1).ge.ku) then ! squarks
+          if(ciaux.eq.1) then ! up type
+c            ncsfert=2
+c            kcsfertn(1)=ksqu((fsave-6+1)/2)
+c            kcsfertn(2)=ksqu((fsave-6+1)/2+3)
+            ncsfert=6 ! JE CORRECTION these 7 lines
+            kcsfertn(1)=ksqu(1)
+            kcsfertn(2)=ksqu(2)
+            kcsfertn(3)=ksqu(3)
+            kcsfertn(4)=ksqu(4)
+            kcsfertn(5)=ksqu(5)
+            kcsfertn(6)=ksqu(6)
+c            ncfers=3 ! done already
+c            kcfersv(1)=ku
+c            kcfersv(2)=kc
+c            kcfersv(3)=kt
             ncferd=3
             kcferd(1)=kd
             kcferd(2)=ks
@@ -296,14 +487,21 @@
             enddo
             cgluonin=.true.
           endif
-          if(ciaux.eq.2) then
-            ncsfert=2
-            kcsfertn(1)=ksqd((fsave-6)/2)
-            kcsfertn(2)=ksqd((fsave-6)/2+3)
-            ncfers=3
-            kcfersv(1)=kd
-            kcfersv(2)=ks
-            kcfersv(3)=kb
+          if(ciaux.eq.2) then ! down type
+c            ncsfert=2
+c            kcsfertn(1)=ksqd((fsave-6)/2)
+c            kcsfertn(2)=ksqd((fsave-6)/2+3)
+            ncsfert=6 ! JE CORRECTION these 7 lines
+            kcsfertn(1)=ksqd(1)
+            kcsfertn(2)=ksqd(2)
+            kcsfertn(3)=ksqd(3)
+            kcsfertn(4)=ksqd(4)
+            kcsfertn(5)=ksqd(5)
+            kcsfertn(6)=ksqd(6)
+c            ncfers=3 ! done already
+c            kcfersv(1)=kd
+c            kcfersv(2)=ks
+c            kcfersv(3)=kb
             ncferd=3
             kcferd(1)=ku
             kcferd(2)=kc
@@ -318,7 +516,7 @@
 ********
         endif
 ********
-        if(ciaux.eq.1) then
+        if(ciaux.eq.1) then ! up type
 ************************************************* sfu^* chi^+ -> Z fdbar
           kp3=kz
           prtial(1)=0.d0
@@ -427,8 +625,9 @@
           w=w+prtial(10)           ! sfu^* chi^+ -> g fdbar
           dsasdwdcossfchi = w*0.5d0 ! 0.5d0 <- we should return weff for sf chi+ ann
                                     ! with sf and chi+ combined part. and anti-particle states
+          
 ********
-        elseif(ciaux.eq.2) then
+        elseif(ciaux.eq.2) then ! down type
 ****************************************************** sfd chi^+ -> Z fu
           kp3=kz
           prtial(1)=0.d0
@@ -481,6 +680,7 @@
             kp4=kcfersv(i)
 	    icase=5  
             call dsaschicasea(kp1,kp2,kp3,kp4,icase,par)
+c            write(*,*) 'sfd chi+ -> W+ fd: ',kp1,kp2,kp3,kp4,par
             prtial(6)=prtial(6)+par
           enddo
 **************************************************** sfd chi^+ -> h^+ fd
@@ -538,6 +738,16 @@
           dsasdwdcossfchi = w*0.5d0 
                ! 0.5d0 <- we should return weff for sf chi+ ann
                ! with sf and chi+ combined part. and anti-particle states
+c          write(*,*) 'sf-cha: prtial(1) = ',prtial(1)
+c          write(*,*) 'sf-cha: prtial(2) = ',prtial(2)
+c          write(*,*) 'sf-cha: prtial(3) = ',prtial(3)
+c          write(*,*) 'sf-cha: prtial(4) = ',prtial(4)
+c          write(*,*) 'sf-cha: prtial(5) = ',prtial(5)
+c          write(*,*) 'sf-cha: prtial(6) = ',prtial(6)
+c          write(*,*) 'sf-cha: prtial(7) = ',prtial(7)
+c          write(*,*) 'sf-cha: prtial(8) = ',prtial(8)
+c          write(*,*) 'sf-cha: prtial(9) = ',prtial(9)
+c          write(*,*) 'sf-cha: prtial(10)= ',prtial(10)
 ********
         else
           write(*,*) 'DS: wrong ciaux value =',ciaux
diff -rupN darksusy-5.1.3/src/as/dsasdwdcossfsf.f ../installed/darksusy/5.1.3/src/as/dsasdwdcossfsf.f
--- darksusy-5.1.3/src/as/dsasdwdcossfsf.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/as/dsasdwdcossfsf.f	2018-07-04 22:31:57.250487877 +0100
@@ -19,6 +19,11 @@
 *** modified: Piero Ullio to include mixing in fermion final states  ***
 ***   and a new labelling of states                                  ***
 ***   08-05-30                                                       ***
+***   Joakim Edsjo, bug fix in slepton-squark part (case 3)          ***
+***   2015-04-08                                                     ***
+***   Joakim Edsjo, made more general (full 6x6 mixing),             ***
+***   Cleaned up a bit (not as many if's needed with full 6x6        ***
+***   mixing). 2016-11-16                                            ***
 ************************************************************************
 
       real*8 function dsasdwdcossfsf(p,costhe,kp1,kp2)
@@ -64,7 +69,7 @@ c...them changed on return, let's use so
 ***** decide on type for kp1i and kp2i, i.e.:
 *****   itype(iii)=ivfam(ku) for up-type (s)quark
 *****   itype(iii)=ivfam(kd) for down-type (s)quark
-*****   itype(iii)=ivfam(iii) for (s)leptons
+*****   itype(iii)=ivfam(iii) for (s)leptons, JE CORR ivfam(ke) for (s)leptons
       itype(1)=ivtype(kp1i)
       itype(2)=ivtype(kp2i)
 
@@ -93,24 +98,28 @@ c...them changed on return, let's use so
       call dsaskinset1
 ***** 
 *****    3 cases:
+c======================================================================
+c======================================================================
 ***** 1) sfermions with same type index, i.e.:
-*****    slepton + slepton* (same family, both charged or both neutral) 
+*****    slepton + slepton* (both charged or both neutral) 
 *****    up-type-squark1 + up-type-squark2  or 
 *****    down-type-squark1 + down-type-squark2 
+c======================================================================
+c======================================================================
       if(itype(1).eq.itype(2)) then
-        do i=1,54
+        do i=1,66
           prtial(i)=0.0d0
         enddo
 ccc
 ccc check whether to reload final/intermediate state arrays/variables
 ccc
-        if(kp1i.ne.kp1s.or.kp2i.ne.kp2s) then
+        if(kp1i.ne.kp1s.or.kp2i.ne.kp2s) then ! recalculate when needed
         kp1s=kp1i
         kp2s=kp2i
 ccc
 ccc do the resetting in the various cases:
 ccc
-        do i=1,30
+        do i=1,66
           chon(i)=.false.
         enddo
         gluonin=.false.
@@ -119,30 +128,123 @@ ccc
         nosneutrinov=.true.
 ccc
         if(itype(1).ge.ivtype(knue).and.itype(1).le.ivtype(ktau)) then
+c============================================================
 ccc input:   \tilde{l}_1,2(i) \tilde{l}^*_1,2(i)
+c============================================================
 ccc
 ccc fermion channels:
 ccc
         i=0
-***** f fbar
+***** f fbar 
         do f=knue,kb
           i=i+1
           kp3in(i)=f
           kp4in(i)=f
           chon(i)=.true.
+       enddo                    ! i=1-12 now filled
+
+c..JE CORR following states added
+***** up-type quark(i), up-type antiquark(j) i,j matching initial state
+        i=12
+        do f1=1,3 ! i=13-18 filled here
+        do f2=1,3
+          kp3=ku+2*(f1-1)
+          kp4=ku+2*(f2-1)
+          if(kp3.ne.kp4) then
+          i=i+1
+c          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4)) then ! JE CORR
+          chon(i)=.true.
+          kp3in(i)=kp3
+          kp4in(i)=kp4
+c          endif ! JE CORR
+          endif         
+        enddo
+        enddo
+c...JE CORR following states added        
+***** down-type quark(i), down-type antiquark(j) i.ne.j 
+        do f1=1,3 ! i=19-24 filled here
+        do f2=1,3 
+          kp3=kd+2*(f1-1)
+          kp4=kd+2*(f2-1)
+          if(kp3.ne.kp4) then
+          i=i+1
+          chon(i)=.true.
+          kp3in(i)=kp3
+          kp4in(i)=kp4
+          endif         
+        enddo
         enddo
-***** no up-type quark(i), up-type antiquark(j) i.ne.j 
-***** no down-type quark(i), down-type antiquark(j) i.ne.j 
+       
 ***** lepton1,  lepton2
-        i=25
-        chon(i)=.true.
-        do f=knue,ktau
-          if(itype(1).eq.ivtype(f)) then
-            kp3in(i)=f
-            kp4in(i)=f
-            fsave=f
-          endif
-        enddo      
+c...JE CORR Added all families as final states, ch 25-30
+        i=24
+        if (itype(1).eq.ivtype(knue)) then ! sneutrino
+           do f1=1,3
+              do f2=f1,3
+                 i=i+1
+                 chon(i)=.true.
+                 kp3in(i)=knu(f1)
+                 kp4in(i)=knu(f2)
+              enddo
+           enddo
+           fsave=knue           ! just for type testing later
+        else                    ! charged slepton
+           do f1=1,3
+              do f2=f1,3
+                 i=i+1
+                 chon(i)=.true.
+                 kp3in(i)=kl(f1)
+                 kp4in(i)=kl(f2)
+              enddo
+           enddo
+           fsave=ke ! just for type testing
+        endif
+        
+c..Old one family code. Replaced by code above        
+c        i=25 ! lepton_1 lepton_1 (same type)
+c        chon(i)=.true.
+c        do f=knue,ktau
+c          if(itype(1).eq.ivtype(f)) then 
+c            kp3in(i)=f
+c            kp4in(i)=f
+c            fsave=f
+c          endif
+c        enddo      
+
+c...Mixed final state lepton states (OK even w/o flavour violation
+c...for initial states with different flavours)        
+        i=54
+        do f1=1,3 ! i=55-60 filled here, nu_i nu_j 
+           do f2=1,3
+              kp3=knu(f1)
+              kp4=knu(f2)
+              if (kp3.ne.kp4) then
+                 i=i+1
+                 if (itype(1).eq.itype(2)) then ! same type (up/down)
+                    kp3in(i)=kp3 ! sl sl* ->
+                    kp4in(i)=kp4
+                    chon(i)=.true.
+                 endif
+              endif
+           enddo
+        enddo
+
+        do f1=1,3 ! i=61-66 filled here, l_i l_j
+           do f2=1,3
+              kp3=kl(f1)
+              kp4=kl(f2)
+              if (kp3.ne.kp4) then
+                 i=i+1
+                 if (itype(1).eq.itype(2)) then ! same type (up/down)
+                    kp3in(i)=kp3 ! sl sl* ->
+                    kp4in(i)=kp4
+                    chon(i)=.true.
+                 endif
+              endif
+           enddo
+        enddo
+        
+        
 ccc
 ccc gauge boson channels:
 ccc
@@ -152,24 +254,57 @@ ccc
 ccc t- and u-channels:
 ccc
         if(dabs(echarg(fsave)).gt.1.d-15) then ! for charged sleptons:
-          ksfertc(1)=ksnu(fsave/2)
-          nsfertc=1
+c          ksfertc(1)=ksnu(fsave/2)
+c          nsfertc=1
+          nsfertc=3 ! JE CORRECTION 4 lines
+          ksfertc(1)=ksnu(1)
+          ksfertc(2)=ksnu(2)
+          ksfertc(3)=ksnu(3)
           nsferuc=0
-          ksfertn(1)=ksl(fsave/2)
-          ksfertn(2)=ksl(fsave/2+3)
-          nsfertn=2
-          ksferun(1)=ksl(fsave/2)
-          ksferun(2)=ksl(fsave/2+3)
-          nsferun=2
+c          ksfertn(1)=ksl(fsave/2)
+c          ksfertn(2)=ksl(fsave/2+3)
+c          nsfertn=2
+          nsfertn=6 ! JE CORRECTION 7 lines
+          ksfertn(1)=ksl(1)
+          ksfertn(2)=ksl(2)
+          ksfertn(3)=ksl(3)
+          ksfertn(4)=ksl(4)
+          ksfertn(5)=ksl(5)
+          ksfertn(6)=ksl(6)
+c          ksferun(1)=ksl(fsave/2)
+c          ksferun(2)=ksl(fsave/2+3)
+c          nsferun=2
+          nsferun=6 ! JE CORRECTION 7 lines
+          ksferun(1)=ksl(1)
+          ksferun(2)=ksl(2)
+          ksferun(3)=ksl(3)
+          ksferun(4)=ksl(4)
+          ksferun(5)=ksl(5)
+          ksferun(6)=ksl(6)
         else ! for sneutrinos:
           nsfertc=0
-          ksferuc(1)=ksl((fsave+1)/2)
-          ksferuc(2)=ksl((fsave+1)/2+3)
-          nsferuc=2
-          ksfertn(1)=ksnu((fsave+1)/2)
-          nsfertn=1
-          ksferun(1)=ksnu((fsave+1)/2)
-          nsferun=1
+c          ksferuc(1)=ksl((fsave+1)/2)
+c          ksferuc(2)=ksl((fsave+1)/2+3)
+c          nsferuc=2
+          nsferuc=6 ! JE CORRECTION 7 lines
+          ksferuc(1)=ksl(1)
+          ksferuc(2)=ksl(2)
+          ksferuc(3)=ksl(3)
+          ksferuc(4)=ksl(4)
+          ksferuc(5)=ksl(5)
+          ksferuc(6)=ksl(6)
+c          ksfertn(1)=ksnu((fsave+1)/2)
+c          nsfertn=1
+          nsfertn=3 ! JE CORRECTION 4 lines
+          ksfertn(1)=ksnu(1)
+          ksfertn(2)=ksnu(2)
+          ksfertn(3)=ksnu(3)
+c          ksferun(1)=ksnu((fsave+1)/2)
+c          nsferun=1
+          nsferun=3 ! JE CORRECTION 4 lines
+          ksferun(1)=ksnu(1)
+          ksferun(2)=ksnu(2)
+          ksferun(3)=ksnu(3)
           nosneutrinov=.false.
         endif
 ccc
@@ -180,8 +315,11 @@ ccc
         cfactfin=3.d0
         endif
 ccc
-        if(iifam(1).eq.iifam(2).and.itype(1).eq.ivtype(ku)) then
-ccc input:   \tilde{u}_1,2(i) \tilde{u}^*_1,2(i)
+c        if(iifam(1).eq.iifam(2).and.itype(1).eq.ivtype(ku)) then
+        if(itype(1).eq.ivtype(ku)) then ! JE CORR
+c============================================================
+ccc input:   \tilde{u}_1,2(i) \tilde{u}^*_1,2(j) (all i,j)
+c============================================================
 ccc
 ccc fermion channels:
 ccc
@@ -193,172 +331,28 @@ ccc
           kp4in(i)=f
           chon(i)=.true.
         enddo
-***** no up-type quark(i), up-type antiquark(j) i.ne.j 
-        i=i+6
-***** down-type quark(i), down-type antiquark(j) i.ne.j 
-        do f1=1,3
-        do f2=1,3
-          kp3=kd+2*(f1-1)
-          kp4=kd+2*(f2-1)
-          if(kp3.ne.kp4) then
-          i=i+1
-          chon(i)=.true.
-          kp3in(i)=kp3
-          kp4in(i)=kp4
-          endif         
-        enddo
-        enddo
-***** up-type quark1, up-type quark2 
-        do f1=1,3
-        do f2=f1,3
-          kp3=ku+2*(f1-1)
-          kp4=ku+2*(f2-1)
-          i=i+1  
-          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4).or.
-     &       iifam(1).eq.ivfam(kp4).and.iifam(2).eq.ivfam(kp3)) then
-            chon(i)=.true.
-            kp3in(i)=kp3
-            kp4in(i)=kp4
-            fsave=f1
-          endif
-        enddo
-        enddo
-ccc
-ccc boson channels:
-ccc
-        gluonin=.true.
-        gammain=.true.
-        neutcurr=.true.
-ccc
-ccc t- and u-channels:
-ccc
-        nsfertc=0 
-        do i=1,6
-          ksferuc(i)=ksqd(i)
-        enddo
-        nsferuc=6
-        ksfertn(1)=ksqu(fsave)
-        ksfertn(2)=ksqu(fsave+3)
-        nsfertn=2
-        ksferun(1)=ksqu(fsave)
-        ksferun(2)=ksqu(fsave+3)
-        nsferun=2
-ccc
-ccc degrees of freedom and color factors
-ccc
-        gg1=3.d0
-        gg2=3.d0
-        chcol=2
-        call dsascolset(chcol)
-        cfactini=1.d0  ! set inside the routine dsasfercol
-        cfactfin=1.d0
-ccc
-        endif
-ccc
-        if(iifam(1).eq.iifam(2).and.itype(1).eq.ivtype(kd)) then
-ccc input:   \tilde{d}_1,2(i) \tilde{d}^*_1,2(i)
-        i=0
-***** f fbar
-        do f=knue,kb
-          i=i+1
-          kp3in(i)=f
-          kp4in(i)=f
-          chon(i)=.true.
-        enddo
-***** up-type quark(i), up-type antiquark(j) i.ne.j 
-        do f1=1,3
-        do f2=1,3
-          kp3=ku+2*(f1-1)
-          kp4=ku+2*(f2-1)
-          if(kp3.ne.kp4) then
-          i=i+1
-          chon(i)=.true.
-          kp3in(i)=kp3
-          kp4in(i)=kp4
-          endif         
-        enddo
-        enddo
-***** no down-type quark(i), down-type antiquark(j) i.ne.j 
-        i=i+6
-***** down-type quark1, down-type quark2 
-        do f1=1,3
-        do f2=f1,3
-          kp3=kd+2*(f1-1)
-          kp4=kd+2*(f2-1)
-          i=i+1  
-          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4).or.
-     &       iifam(1).eq.ivfam(kp4).and.iifam(2).eq.ivfam(kp3)) then
-            chon(i)=.true.
-            kp3in(i)=kp3
-            kp4in(i)=kp4
-            fsave=f1
-          endif
-        enddo
-        enddo  
-ccc
-ccc boson channels:
-ccc
-        gluonin=.true.
-        gammain=.true.
-        neutcurr=.true.
-ccc
-ccc t- and u-channels:
-ccc
-        do i=1,6
-          ksfertc(i)=ksqu(i)
-        enddo
-        nsfertc=6
-        nsferuc=0
-        ksfertn(1)=ksqd(fsave)
-        ksfertn(2)=ksqd(fsave+3)
-        nsfertn=2
-        ksferun(1)=ksqd(fsave)
-        ksferun(2)=ksqd(fsave+3)
-        nsferun=2
-ccc
-ccc degrees of freedom and color factors
-ccc
-        gg1=3.d0
-        gg2=3.d0
-        chcol=2
-        call dsascolset(chcol)
-        cfactini=1.d0  ! set inside the routine dsasfercol
-        cfactfin=1.d0
-ccc
-        endif
-ccc
-        if(iifam(1).ne.iifam(2).and.itype(1).eq.ivtype(ku)) then
-ccc input:   \tilde{u}_1,2(i) \tilde{u}^*_1,2(j)  i.ne.j
-ccc
-ccc fermion channels:
-ccc
-        i=0
-***** down-type quark(i), down-type antiquark(i) 
-        do f=1,3
-          i=kd+2*(f-1)
-          kp3in(i)=i
-          kp4in(i)=i
-          chon(i)=.true.
-        enddo
+
+c..JE CORR following states added
 ***** up-type quark(i), up-type antiquark(j) i,j matching initial state
         i=12
-        do f1=1,3
+        do f1=1,3 ! i=13-18 filled here
         do f2=1,3
           kp3=ku+2*(f1-1)
           kp4=ku+2*(f2-1)
           if(kp3.ne.kp4) then
           i=i+1
-          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4)) then
+c          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4)) then ! JE CORR
           chon(i)=.true.
           kp3in(i)=kp3
           kp4in(i)=kp4
-          endif
+c          endif ! JE CORR
           endif         
         enddo
         enddo
+        
 ***** down-type quark(i), down-type antiquark(j) i.ne.j 
-        do f1=1,3
-        do f2=1,3
+        do f1=1,3 ! i=19-24 filled here
+        do f2=1,3 
           kp3=kd+2*(f1-1)
           kp4=kd+2*(f2-1)
           if(kp3.ne.kp4) then
@@ -369,23 +363,28 @@ ccc
           endif         
         enddo
         enddo
+
 ***** up-type quark1, up-type quark2 
-        do f1=1,3
+        do f1=1,3 ! i=25-30 filled here
         do f2=f1,3
           kp3=ku+2*(f1-1)
           kp4=ku+2*(f2-1)
           i=i+1  
-          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4).or.
-     &       iifam(1).eq.ivfam(kp4).and.iifam(2).eq.ivfam(kp3)) then
+c          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4).or. ! JE CORR
+c     &       iifam(1).eq.ivfam(kp4).and.iifam(2).eq.ivfam(kp3)) then
             chon(i)=.true.
             kp3in(i)=kp3
             kp4in(i)=kp4
-          endif
+c            fsave=f1 ! JE CORR
+c          endif
         enddo
         enddo
 ccc
-ccc only w gauge boson channels:
+ccc boson channels:
 ccc
+        gluonin=.true.
+        gammain=.true.
+        neutcurr=.true.
 ccc
 ccc t- and u-channels:
 ccc
@@ -394,8 +393,26 @@ ccc
           ksferuc(i)=ksqd(i)
         enddo
         nsferuc=6
-        nsfertn=0
-        nsferun=0
+c        ksfertn(1)=ksqu(fsave)
+c        ksfertn(2)=ksqu(fsave+3)
+c        nsfertn=2
+        nsfertn=6 ! JE CORRECTION 7 lines
+        ksfertn(1)=ksqu(1)
+        ksfertn(2)=ksqu(2)
+        ksfertn(3)=ksqu(3)
+        ksfertn(4)=ksqu(4)
+        ksfertn(5)=ksqu(5)
+        ksfertn(6)=ksqu(6)
+c        ksferun(1)=ksqu(fsave)
+c        ksferun(2)=ksqu(fsave+3)
+c        nsferun=2
+        nsferun=6 ! JE CORRECTION 7 lines
+        ksferun(1)=ksqu(1)
+        ksferun(2)=ksqu(2)
+        ksferun(3)=ksqu(3)
+        ksferun(4)=ksqu(4)
+        ksferun(5)=ksqu(5)
+        ksferun(6)=ksqu(6)
 ccc
 ccc degrees of freedom and color factors
 ccc
@@ -408,21 +425,20 @@ ccc
 ccc
         endif
 ccc
-        if(iifam(1).ne.iifam(2).and.itype(1).eq.ivtype(kd)) then
-ccc input:   \tilde{d}_1,2(i) \tilde{d}^*_1,2(j)  i.ne.j
-ccc
-ccc fermion channels:
-ccc
+c        if(iifam(1).eq.iifam(2).and.itype(1).eq.ivtype(kd)) then
+        if(itype(1).eq.ivtype(kd)) then ! JE CORR
+c============================================================
+ccc input:   \tilde{d}_1,2(i) \tilde{d}^*_1,2(j) (all i,j)
+c============================================================
         i=0
-***** up-type quark(i), up-type antiquark(i) 
-        do f=1,3
-          i=ku+2*(f-1)
-          kp3in(i)=i
-          kp4in(i)=i
+***** f fbar
+        do f=knue,kb
+          i=i+1
+          kp3in(i)=f
+          kp4in(i)=f
           chon(i)=.true.
         enddo
-***** up-type quark(i), up-type antiquark(j) i.ne.j
-        i=12
+***** up-type quark(i), up-type antiquark(j) i.ne.j 
         do f1=1,3
         do f2=1,3
           kp3=ku+2*(f1-1)
@@ -435,6 +451,8 @@ ccc
           endif         
         enddo
         enddo
+
+c...JE CORR added d_i d_j final states to be more general
 ***** down-type quark(i), down-type antiquark(j) i,j matching initial state 
         do f1=1,3
         do f2=1,3
@@ -442,31 +460,36 @@ ccc
           kp4=kd+2*(f2-1)
           if(kp3.ne.kp4) then
           i=i+1
-          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4)) then
+c          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4)) then ! JE CORR
           chon(i)=.true.
           kp3in(i)=kp3
           kp4in(i)=kp4
-          endif
+c          endif ! JE CORR
           endif         
         enddo
         enddo
+      
 ***** down-type quark1, down-type quark2 
         do f1=1,3
         do f2=f1,3
           kp3=kd+2*(f1-1)
           kp4=kd+2*(f2-1)
-          i=i+1  
-          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4).or.
-     &       iifam(1).eq.ivfam(kp4).and.iifam(2).eq.ivfam(kp3)) then
+          i=i+1
+c          if(iifam(1).eq.ivfam(kp3).and.iifam(2).eq.ivfam(kp4).or. ! JE CORR
+c     &       iifam(1).eq.ivfam(kp4).and.iifam(2).eq.ivfam(kp3)) then
             chon(i)=.true.
             kp3in(i)=kp3
             kp4in(i)=kp4
-          endif
-        enddo
+c            fsave=f1 ! JE COEE
+c          endif ! JE CORR
         enddo
+        enddo  
 ccc
-ccc only w gauge boson channels:
+ccc boson channels:
 ccc
+        gluonin=.true.
+        gammain=.true.
+        neutcurr=.true.
 ccc
 ccc t- and u-channels:
 ccc
@@ -475,8 +498,26 @@ ccc
         enddo
         nsfertc=6
         nsferuc=0
-        nsfertn=0
-        nsferun=0
+c        ksfertn(1)=ksqd(fsave)
+c        ksfertn(2)=ksqd(fsave+3)
+c        nsfertn=2
+        nsfertn=6 ! JE CORRECTION 7 lines
+        ksfertn(1)=ksqd(1)
+        ksfertn(2)=ksqd(2)
+        ksfertn(3)=ksqd(3)
+        ksfertn(4)=ksqd(4)
+        ksfertn(5)=ksqd(5)
+        ksfertn(6)=ksqd(6)
+c        ksferun(1)=ksqd(fsave)
+c        ksferun(2)=ksqd(fsave+3)
+c        nsferun=2
+        nsferun=6 ! JE CORRECTION 7 lines
+        ksferun(1)=ksqd(1)
+        ksferun(2)=ksqd(2)
+        ksferun(3)=ksqd(3)
+        ksferun(4)=ksqd(4)
+        ksferun(5)=ksqd(5)
+        ksferun(6)=ksqd(6)
 ccc
 ccc degrees of freedom and color factors
 ccc
@@ -489,10 +530,11 @@ ccc
 ccc
         endif
 ccc
+ccc
         endif
 *****
 ******************************************************* sf sf* -> f fbar
-        do i=1,12
+        do i=1,12 
           if(chon(i)) then
           kp3=kp3in(i)
           kp4=kp4in(i)
@@ -503,8 +545,28 @@ ccc
               result=result*cfactfin 
             endif
           elseif(chcol.eq.2) then
-            icase=1  
-            call dsasfercol(kp1i,kp2i,kp3,kp4,icase,result)
+             icase=1
+             call dsasfercol(kp1i,kp2i,kp3,kp4,icase,result)
+          else
+            write(*,*) 'chcol not set correctly, = ',chcol
+            stop
+          endif  
+          prtial(i)=result
+          endif
+        enddo  
+
+c...Add mixed slepton final states sl sl* -> ...
+        do i=55,66
+          if(chon(i)) then
+          kp3=kp3in(i)
+          kp4=kp4in(i)
+          if(chcol.eq.1) then
+            icase=3
+            call dsasfer(kp1i,kp2i,kp3,kp4,icase,result)
+          elseif(chcol.eq.2) then ! only for sleptons
+c             icase=1
+c             call dsasfercol(kp1i,kp2i,kp3,kp4,icase,result)
+             result=0.d0
           else
             write(*,*) 'chcol not set correctly, = ',chcol
             stop
@@ -512,12 +574,13 @@ ccc
           prtial(i)=result
           endif
         enddo  
+        
 ***************************************************** sf sf* -> q1 q2bar
 *****
 ***** for squark initial states, possible flavour mixing in the initial 
-***** state, not in the final state:
+***** state, not in the final state: (JE CORR: this is more general now)
 *****
-        if(chcol.eq.2) then  
+        if(chcol.eq.2) then  ! JE FIX ME. Do we want this for sleptons too?
         do i=13,24
           if(chon(i)) then
             kp3=kp3in(i)
@@ -530,19 +593,20 @@ ccc
         endif
 ************************************************* sl sl -> lepton lepton
         if(chcol.eq.1) then  
-          i=25
-          if(chon(i)) then
-            kp3=kp3in(i)
-            kp4=kp4in(i)
-            icase=1
-            call dsasfere(kp1i,kp2i,kp3,kp4,icase,result)
-            prtial(i)=result
-          endif
+          do i=25,30
+             if(chon(i)) then
+                kp3=kp3in(i)
+                kp4=kp4in(i)
+                icase=1
+                call dsasfere(kp1i,kp2i,kp3,kp4,icase,result)
+                prtial(i)=result
+             endif
+          enddo
         endif 
 ********************************************************* sf sf -> q1 q2
 *****
 ***** for squark initial states, possible flavour mixing in the initial 
-***** state, not in the final state:
+***** state, not in the final state: (JE CORR this is more general now)
 *****
         if(chcol.eq.2) then  
         do i=25,30
@@ -743,12 +807,12 @@ ccc
         w=w+prtial(22)           ! sf sf* -> s bbar
         w=w+prtial(23)           ! sf sf* -> b dbar
         w=w+prtial(24)           ! sf sf* -> b sbar
-        w=w+prtial(25)           ! sf sf -> lepton lepton or u u or d d
-        w=w+prtial(26)           ! sf sf -> u c  or  d s 
-        w=w+prtial(27)           ! sf sf -> u t  or  d b
-        w=w+prtial(28)           ! sf sf -> c c  or  s s
-        w=w+prtial(29)           ! sf sf -> c t  or  s b
-        w=w+prtial(30)           ! sf sf -> t t  or  b b
+        w=w+prtial(25)           ! sf sf -> lepton_1 lepton_1 or u u or d d
+        w=w+prtial(26)           ! sf sf -> lepton_1 lepton 2 or u c  or  d s 
+        w=w+prtial(27)           ! sf sf -> lepton_1 lepton 3 or u t  or  d b
+        w=w+prtial(28)           ! sf sf -> lepton_2 lepton_2 or c c  or  s s
+        w=w+prtial(29)           ! sf sf -> lepton_2 lepton_3 or  c t  or  s b
+        w=w+prtial(30)           ! sf sf -> lepton_3 lepton_3 or t t  or  b b
         w=w+prtial(31)           ! sf sf* ->  w+ w-
         w=w+prtial(32)           ! sf sf* -> z z
         w=w+prtial(33)           ! sf sf* -> z gamma
@@ -773,7 +837,24 @@ ccc
         w=w+prtial(52)           ! sf sf* -> gluon H
         w=w+prtial(53)           ! sf sf* -> gluon h
         w=w+prtial(54)           ! sf sf* -> gluon A
+        w=w+prtial(55)           ! sf sf* -> nu_e nu_mu-bar
+        w=w+prtial(56)           ! sf sf* -> nu_e nu_tau-bar
+        w=w+prtial(57)           ! sf sf* -> nu_mu nu_e-bar
+        w=w+prtial(58)           ! sf sf* -> nu_mu nu_tau-bar
+        w=w+prtial(59)           ! sf sf* -> nu_tau nu_e-bar
+        w=w+prtial(60)           ! sf sf* -> nu_tau nu_mu-bar
+        w=w+prtial(61)           ! sf sf* -> e- mu+
+        w=w+prtial(62)           ! sf sf* -> e- tau+
+        w=w+prtial(63)           ! sf sf* -> mu- e+
+        w=w+prtial(64)           ! sf sf* -> mu- tau+
+        w=w+prtial(65)           ! sf sf* -> tau- e+
+        w=w+prtial(66)           ! sf sf* -> tau- mu+
 
+c        do i=1,66 ! JE TMP
+c           write(*,'(A,I2,1x,I2,1x,I3,1x,E12.6,1x,E12.6,1x,L1)')
+c     &       'sfsf case 1: ',kp1,kp2,i,mass1,prtial(i),chon(i)
+c        enddo
+        
 c
 c check for large negative terms in the fermion final states
 c
@@ -788,6 +869,17 @@ c
             endif  
           endif  
         enddo
+
+        do i=55,66
+          if (prtial(i).lt.0.0d0) then
+            if (dabs(prtial(i)/w).gt.fertoll) then
+              wok=.false.
+            else
+              w=w-prtial(i)
+              prtial(i)=0.0d0
+            endif  
+          endif  
+        enddo
 c
 c write error message:
 c
@@ -797,7 +889,7 @@ c
           write(*,*) 'DS: large negative term in dsasdwdcossfsf'
           write(*,*) 'DS: called with kp1i=',kp1i,' kp2i=',kp2i
           write(*,*) 'DS: p=',p,' costh=',costhe,' w=',w
-          do i=1,54
+          do i=1,66
             write(*,*) 'DS: i=',i,' prtial=',prtial(i)
           enddo
         endif
@@ -805,12 +897,15 @@ c
 c
         dsasdwdcossfsf = w*0.5d0 ! 0.5d0 <- we should return weff for 
               ! sf sf ann with sf combined part. and anti-particle state
-************************************************************************
+c======================================================================
+c======================================================================
 *****
-***** 2) sneutrino + slepton in same family or
+***** 2) sneutrino + slepton or
 *****    up-type squark + down-type squark
+c======================================================================
+c======================================================================
       elseif(abs(itype(1)-itype(2)).eq.1) then
-        do i=1,33
+        do i=1,39
           prtial(i)=0.0d0
         enddo
 ccc
@@ -824,40 +919,95 @@ ccc
 ***** 
         gluonin=.false.
 ccc
+
         if(itype(1).ge.ivtype(knue).and.itype(1).le.ivtype(ktau)) then
-ccc input:   \tilde{nu}(i) \tilde{l}^*_1,2(i)
+c============================================================
+ccc input:   \tilde{nu}(i) \tilde{l}^*_1,2(j)
+c============================================================
 ccc
 ccc fermion channels: 
-ccc    neutrino(j) lepton^+(j) -- same family j \in (1,2,3)
+ccc    neutrino(j) lepton^+(j) -- all allowed 
 ccc    up-type quark(j) down-type antiquark(k) -- all allowed
 ccc
-ccc    neutrino(i) lepton^-(i) -- same family as in the initial state
-        i=13
-        do f=1,3
-          kp3=knue+2*(f-1)
-          kp4=ke+2*(f-1)
-          if(ivtype(kp3).eq.itype(1)) then
-            kp3in(i)=kp3
-            kp4in(i)=kp4
-            fsave=f
-          endif
+ccc    neutrino(i) lepton^-(j) -- all three families
+        i=12
+        do f1=1,3 ! JE CORR all families
+           kp3=knu(f1)
+           do f2=1,3
+              i=i+1
+              kp4=kl(f2)
+              kp3in(i)=kp3
+              kp4in(i)=kp4
+           enddo
         enddo
+
+c...Need to add mixed final states snu sl* -> nu' l-bar         
+        i=33
+        do f1=1,3 ! JE CORR all families
+           kp3=knu(f1)
+           do f2=1,3
+              kp4=kl(f2)
+              if ((ivfam(kp3)+1).ne.ivfam(kp4)) then ! new mixed state
+                 i=i+1
+                 kp3in(i)=kp3
+                 kp4in(i)=kp4
+              endif
+           enddo
+        enddo
+
+              
+c...Old code below
+c        do f=1,3
+c          kp3=knue+2*(f-1)
+c          kp4=ke+2*(f-1)
+c          if(ivtype(kp3).eq.itype(1)) then
+c            kp3in(i)=kp3
+c            kp4in(i)=kp4
+c            fsave=f 
+c          endif
+c        enddo
+
 ccc
 ccc gauge boson channels:
 ccc
 ccc
 ccc t- and u-channels:
 ccc
-        ksfertc(1)=ksl(fsave)
-        ksfertc(2)=ksl(fsave+3)
-        nsfertc=2
-        ksferuc(1)=ksnu(fsave)
-        nsferuc=1
-        ksfertn(1)=ksnu(fsave)
-        nsfertn=1
-        ksferun(1)=ksl(fsave)
-        ksferun(2)=ksl(fsave+3)
-        nsferun=2
+c        ksfertc(1)=ksl(fsave)
+c        ksfertc(2)=ksl(fsave+3)
+c        nsfertc=2
+        ksfertc(1)=ksl(1) ! JE CORR all 6 below
+        ksfertc(2)=ksl(2)
+        ksfertc(3)=ksl(3)
+        ksfertc(4)=ksl(4)
+        ksfertc(5)=ksl(5)
+        ksfertc(6)=ksl(6)
+        nsfertc=6
+
+c        ksferuc(1)=ksnu(fsave)
+c        nsferuc=1
+        ksferuc(1)=ksnu(1) ! JE CORR all 3 below
+        ksferuc(2)=ksnu(2)
+        ksferuc(3)=ksnu(3)
+        nsferuc=3
+
+c        ksfertn(1)=ksnu(fsave)
+c        nsfertn=1
+        ksfertn(1)=ksnu(1) ! JE CORR all 3 below
+        ksfertn(2)=ksnu(2)
+        ksfertn(3)=ksnu(3)
+        nsfertn=3
+
+c        ksferun(1)=ksl(fsave)
+c        ksferun(2)=ksl(fsave+3)
+c        nsferun=2
+        ksferun(1)=ksl(1) ! JE CORR all 6 below
+        ksferun(2)=ksl(2)
+        ksferun(3)=ksl(3)
+        ksferun(4)=ksl(4)
+        ksferun(5)=ksl(5)
+        ksferun(6)=ksl(6)
+        nsferun=6
 ccc
         gg1=1.d0 
         gg2=1.d0
@@ -867,7 +1017,9 @@ ccc
         endif
 ccc
         if(itype(1).ge.ivtype(ku).and.(iifam(2)-iifam(1)).eq.1) then
+c============================================================
 ccc input:   \tilde{u}_1,2(i) \tilde{d}^*_1,2(i)
+c============================================================
 ccc
 ccc fermion channels: 
 ccc    neutrino(j) lepton^+(j) -- same family j \in (1,2,3)
@@ -875,13 +1027,16 @@ ccc    up-type quark(j) down-type antiqu
 ccc
 ccc    up-type quark(i) down-type antiquark(i) -- same family 
 ccc       as in the initial state
-        do f=1,3
-          kp3=ku+2*(f-1) ! up-type quark
-          if(ivfam(kp3).eq.iifam(1)) then
-            fsave=f
-            f2save=f
-          endif
-        enddo
+
+c...JE CORR. No need to set fsave here           
+c        do f=1,3
+c          kp3=ku+2*(f-1) ! up-type quark
+c          if(ivfam(kp3).eq.iifam(1)) then
+c            fsave=f
+c            f2save=f
+c          endif
+c        enddo
+
 ccc
 ccc gauge boson channels:
 ccc
@@ -889,18 +1044,49 @@ ccc
 ccc
 ccc t- and u-channels:
 ccc
-        ksfertc(1)=ksqd(fsave)
-        ksfertc(2)=ksqd(fsave+3)
-        nsfertc=2
-        ksferuc(1)=ksqu(fsave)
-        ksferuc(2)=ksqu(fsave+3)
-        nsferuc=2
-        ksfertn(1)=ksqu(fsave)
-        ksfertn(2)=ksqu(fsave+3)
-        nsfertn=2
-        ksferun(1)=ksqd(fsave)
-        ksferun(2)=ksqd(fsave+3)
-        nsferun=2
+c        ksfertc(1)=ksqd(fsave)
+c        ksfertc(2)=ksqd(fsave+3)
+c        nsfertc=2
+        ksfertc(1)=ksqd(1) ! JE CORR all 6
+        ksfertc(2)=ksqd(2)
+        ksfertc(3)=ksqd(3)
+        ksfertc(4)=ksqd(4)
+        ksfertc(5)=ksqd(5)
+        ksfertc(6)=ksqd(6)
+        nsfertc=6
+
+c        ksferuc(1)=ksqu(fsave)
+c        ksferuc(2)=ksqu(fsave+3)
+c        nsferuc=2
+        ksferuc(1)=ksqu(1) ! JE CORR all 6
+        ksferuc(2)=ksqu(2)
+        ksferuc(3)=ksqu(3)
+        ksferuc(4)=ksqu(4)
+        ksferuc(5)=ksqu(5)
+        ksferuc(6)=ksqu(6)
+        nsferuc=6
+
+c        ksfertn(1)=ksqu(fsave)
+c        ksfertn(2)=ksqu(fsave+3)
+c        nsfertn=2
+        ksfertn(1)=ksqu(1) ! JE CORR all 6
+        ksfertn(2)=ksqu(2)
+        ksfertn(3)=ksqu(3)
+        ksfertn(4)=ksqu(4)
+        ksfertn(5)=ksqu(5)
+        ksfertn(6)=ksqu(6)
+        nsfertn=6
+
+c        ksferun(1)=ksqd(fsave)
+c        ksferun(2)=ksqd(fsave+3)
+c        nsferun=2
+        ksferun(1)=ksqd(1) ! JE CORR all 6
+        ksferun(2)=ksqd(2)
+        ksferun(3)=ksqd(3)
+        ksferun(4)=ksqd(4)
+        ksferun(5)=ksqd(5)
+        ksferun(6)=ksqd(6)
+        nsferun=6
 ccc
         gg1=3.d0
         gg2=3.d0
@@ -911,7 +1097,9 @@ ccc
         endif
 ccc
         if(itype(1).ge.ivtype(ku).and.(iifam(2)-iifam(1)).ne.1) then
+c============================================================
 ccc input:   \tilde{u}(i) \tilde{d}^*_1,2(j)  i.ne.j
+c============================================================
 ccc
 ccc fermion channels: 
 ccc    neutrino(j) lepton^+(j) -- same family j \in (1,2,3)
@@ -919,18 +1107,20 @@ ccc    up-type quark(j) down-type antiqu
 ccc
 ccc    up-type quark(i) down-type antiquark(i) -- same family 
 ccc       as in the initial state
-        do f1=1,3
-          kp3=ku+2*(f1-1) ! up-type quark
-          if(ivfam(kp3).eq.iifam(1)) then
-            fsave=f1
-          endif
-        enddo
-        do f2=1,3
-          kp4=kd+2*(f2-1) ! down-type quark
-          if(ivfam(kp4).eq.iifam(2)) then
-            f2save=f2
-          endif
-        enddo
+c...JE CORR. This is not needed           
+c        do f1=1,3
+c          kp3=ku+2*(f1-1) ! up-type quark
+c          if(ivfam(kp3).eq.iifam(1)) then
+c            fsave=f1
+c          endif
+c        enddo
+c        do f2=1,3
+c          kp4=kd+2*(f2-1) ! down-type quark
+c          if(ivfam(kp4).eq.iifam(2)) then
+c            f2save=f2
+c          endif
+c        enddo
+
 ccc
 ccc gauge boson channels:
 ccc
@@ -938,18 +1128,49 @@ ccc
 ccc
 ccc t- and u-channels:
 ccc
-        ksfertc(1)=ksqd(f2save)
-        ksfertc(2)=ksqd(f2save+3)
-        nsfertc=2
-        ksferuc(1)=ksqu(fsave)
-        ksferuc(2)=ksqu(fsave+3)
-        nsferuc=2
-        ksfertn(1)=ksqu(fsave)
-        ksfertn(2)=ksqu(fsave+3)
-        nsfertn=2
-        ksferun(1)=ksqd(f2save)
-        ksferun(2)=ksqd(f2save+3)
-        nsferun=2
+c        ksfertc(1)=ksqd(f2save)
+c        ksfertc(2)=ksqd(f2save+3)
+c        nsfertc=2
+        ksfertc(1)=ksqd(1) ! JE CORR all 6
+        ksfertc(2)=ksqd(2)
+        ksfertc(3)=ksqd(3)
+        ksfertc(4)=ksqd(4)
+        ksfertc(5)=ksqd(5)
+        ksfertc(6)=ksqd(6)
+        nsfertc=6
+        
+c        ksferuc(1)=ksqu(fsave)
+c        ksferuc(2)=ksqu(fsave+3)
+c        nsferuc=2
+        ksferuc(1)=ksqu(1) ! JE CORR all 6
+        ksferuc(2)=ksqu(2)
+        ksferuc(3)=ksqu(3)
+        ksferuc(4)=ksqu(4)
+        ksferuc(5)=ksqu(5)
+        ksferuc(6)=ksqu(6)
+        nsferuc=6
+        
+c        ksfertn(1)=ksqu(fsave)
+c        ksfertn(2)=ksqu(fsave+3)
+c        nsfertn=2
+        ksfertn(1)=ksqu(1) ! JE CORR all 6
+        ksfertn(2)=ksqu(2)
+        ksfertn(3)=ksqu(3)
+        ksfertn(4)=ksqu(4)
+        ksfertn(5)=ksqu(5)
+        ksfertn(6)=ksqu(6)
+        nsfertn=6
+
+c        ksferun(1)=ksqd(f2save)
+c        ksferun(2)=ksqd(f2save+3)
+c        nsferun=2
+        ksferun(1)=ksqd(1) ! JE CORR all 6
+        ksferun(2)=ksqd(2)
+        ksferun(3)=ksqd(3)
+        ksferun(4)=ksqd(4)
+        ksferun(5)=ksqd(5)
+        ksferun(6)=ksqd(6)
+        nsferun=6
 ccc
         gg1=3.d0
         gg2=3.d0
@@ -968,7 +1189,7 @@ ccc
 ***** state and in the final state; for sleptons flavour mixing for 
 ***** quarks in the final state:
 *****
-        if(chcol.eq.1) then
+        if(chcol.eq.1) then ! sleptons in initial state
 ***** first the lepton final states:
           do f=1,3
             kp3=knue+2*(f-1)
@@ -977,6 +1198,16 @@ ccc
             call dsasfer(kp1i,kp2i,kp3,kp4,icase,result)
             prtial(f)=result
           enddo
+
+c...Now the mixed ones
+          do i=34,39
+             kp3=kp3in(i)
+             kp4=kp4in(i)
+             icase=2
+             call dsasfer(kp1i,kp2i,kp3,kp4,icase,result)
+             prtial(i)=result
+          enddo
+
 ***** then the quark final states:
           i=0
           do f1=1,3
@@ -990,7 +1221,7 @@ ccc
             prtial(3+i)=result
           enddo
           enddo
-        else
+        else ! squarks in initial state
 ***** first the lepton final states:
           do f=1,3
             kp3=knue+2*(f-1)
@@ -1018,16 +1249,18 @@ ccc
 ***** state and in the final state
 *****
 ***** first the lepton final states:
-        if(chcol.eq.1) then
-          i=13
-          kp3=kp3in(i)
-          kp4=kp4in(i)
-          icase=2
-          call dsasfere(kp1i,kp2i,kp3,kp4,icase,result)
-          prtial(13)=result
+        if(chcol.eq.1) then     ! slepton initial state
+          do i=13,21
+             kp3=kp3in(i)
+             kp4=kp4in(i)
+             icase=2
+             call dsasfere(kp1i,kp2i,kp3,kp4,icase,result)
+
+             prtial(i)=result
+          enddo
 *****
 ***** then the quark final states:
-        else
+        else ! squark initial state
         i=0
         do f1=1,3
         do f2=1,3
@@ -1122,21 +1355,21 @@ ccc
         w=w+prtial(4)            ! sfu sfd* -> u dbar
         w=w+prtial(5)            ! sfu sfd* -> u sbar
         w=w+prtial(6)            ! sfu sfd* -> u bbar
-        w=w+prtial(7)            ! sfu sfd* -> c ubar
+        w=w+prtial(7)            ! sfu sfd* -> c dbar
         w=w+prtial(8)            ! sfu sfd* -> c sbar
         w=w+prtial(9)            ! sfu sfd* -> c bbar
         w=w+prtial(10)           ! sfu sfd* -> t dbar
         w=w+prtial(11)           ! sfu sfd* -> t sbar
         w=w+prtial(12)           ! sfu sfd* -> t bbar
-        w=w+prtial(13)           ! sfu sfd -> u d
-        w=w+prtial(14)           ! sfu sfd -> u s
-        w=w+prtial(15)           ! sfu sfd -> u b
-        w=w+prtial(16)           ! sfu sfd -> c d
-        w=w+prtial(17)           ! sfu sfd -> c s
-        w=w+prtial(18)           ! sfu sfd -> c b
-        w=w+prtial(19)           ! sfu sfd -> t d
-        w=w+prtial(20)           ! sfu sfd -> t s
-        w=w+prtial(21)           ! sfu sfd -> t b
+        w=w+prtial(13)           ! sfu sfd -> u d or nu_e e-
+        w=w+prtial(14)           ! sfu sfd -> u s or nu_e mu-
+        w=w+prtial(15)           ! sfu sfd -> u b or nu_e tau-
+        w=w+prtial(16)           ! sfu sfd -> c d or nu_mu e-
+        w=w+prtial(17)           ! sfu sfd -> c s or nu_mu mu-
+        w=w+prtial(18)           ! sfu sfd -> c b or nu_mu tau-
+        w=w+prtial(19)           ! sfu sfd -> t d or nu_tau e-
+        w=w+prtial(20)           ! sfu sfd -> t s or nu_tau mu-
+        w=w+prtial(21)           ! sfu sfd -> t b or nu_tau tau-
         w=w+prtial(22)           ! sfu sfd* -> w+ z
         w=w+prtial(23)           ! sfu sfd* -> w+ gamma
         w=w+prtial(24)           ! sfu sfd* -> w+ h
@@ -1149,8 +1382,20 @@ ccc
         w=w+prtial(31)           ! sfu sfd* -> h+ a
         w=w+prtial(32)           ! sfu sfd* -> W+ g
         w=w+prtial(33)           ! sfu sfd* -> g H+
-c
-c check for large negative terms in the fermion final states
+        w=w+prtial(34)           ! sfu sfd* -> nu_e mu+
+        w=w+prtial(35)           ! sfu sfd* -> nu_e tau+
+        w=w+prtial(36)           ! sfu sfd* -> nu_mu e+
+        w=w+prtial(37)           ! sfu sfd* -> nu_mu tau+
+        w=w+prtial(38)           ! sfu sfd* -> nu_tau e+
+        w=w+prtial(39)           ! sfu sfd* -> nu_tau mu+
+
+c        do i=1,39               ! JE TMP
+c           write(*,*) 'sfsf case 2: i=',i,prtial(i)
+c        enddo
+        
+        
+C
+C Check for large negative terms in the fermion final states
 c
         wok=.true.
         do i=1,21
@@ -1163,6 +1408,18 @@ c
             endif  
           endif  
         enddo
+
+        do i=34,39
+          if (prtial(i).lt.0.0d0) then
+            if (dabs(prtial(i)/w).gt.fertoll) then
+              wok=.false.
+            else
+              w=w-prtial(i)
+              prtial(i)=0.0d0
+            endif  
+          endif  
+        enddo
+
 c
 c write error message:
 c
@@ -1172,7 +1429,7 @@ c
           write(*,*) 'DS: large negative term in dsasdwdcossfsf'
           write(*,*) 'DS: called with kp1i=',kp1i,' kp2i=',kp2i
           write(*,*) 'DS: p=',p,' costh=',costhe,' w=',w
-          do i=1,33
+          do i=1,39
             write(*,*) 'DS: i=',i,' prtial=',prtial(i)
           enddo
         endif
@@ -1180,13 +1437,22 @@ c
 c
         dsasdwdcossfsf = w*0.5d0 ! 0.5d0 <- we should return weff for 
               ! sf sf ann with sf combined part. and anti-particle state
+c======================================================================
+c======================================================================
 ************************************************************************
 *****
-***** 3) 2 sleptons in different families or
-*****    one squark + one slepton
-      else   
+***** 3) one squark + one slepton
+***** JE CORR. Note. Before this case was used also for sleptons in
+***** different families, but this is handled above instead.
+***** This part is almost entirely rewritten by J. Edsjo
+c======================================================================
+c======================================================================
+      else
+c...The final state particles can be different for both the first
+c...and second outgoing particles.
+c...JE CORR. Changed 9 final states to 27.         
 c        write(*,*) 'Now in case 3...'
-        do i=1,12
+        do i=1,27
           prtial(i)=0.0d0
         enddo
 ccc
@@ -1195,29 +1461,48 @@ ccc
         if(kp1i.ne.kp1s.or.kp2i.ne.kp2s) then
         kp1s=kp1i
         kp2s=kp2i
-        do i=1,12
+        do i=1,27
           chon(i)=.false.
         enddo
 ***** identify particles in initial and final state
+c============================================================
+c=== up squark - slepton
+c============================================================        
 ***** the first only can be a up-type squark:
         if(itype(1).eq.ivtype(ku)) then
           i=0
-          do f=1,3
-            kp3=ku+2*(f-1)
-            if(iifam(1).eq.ivfam(kp3)) then
-              i=i+1
-              kp3in(i)=kp3
-              chon(i)=.true.
-              kp3in(i+3)=kp3
-              chon(i+3)=.true.
-            endif
+          do f1=1,3
+             kp3=ku+2*(f1-1) ! the different kinds of up quarks
+             do f2=1,3
+                i=i+1
+                if (itype(2).eq.ivtype(ksnue)) then ! sneutrino
+                   kp4=knu(f2)
+                else            ! charged slepton
+                   kp4=kl(f2)
+                endif
+                kp3in(i)=kp3 ! squ sl* -> u l-bar
+                kp4in(i)=kp4
+                chon(i)=.true.
+                kp3in(i+9)=kp3 ! squ sl -> u l
+                kp4in(i+9)=kp4
+                chon(i+9)=.true.
+             enddo
           enddo
-          i=6
-          do f=1,3
-            kp3=kd+2*(f-1)
-            i=i+1
-            kp3in(i)=kp3
-            chon(i)=.true.
+
+          i=18
+          do f1=1,3
+             kp3=kd+2*(f1-1)
+             do f2=1,3
+                i=i+1
+                if (itype(2).eq.ivtype(ksnue)) then ! sneutrino
+                   kp4=kl(f2)
+                else            ! charged slepton
+                   kp4=knu(f2)
+                endif
+                kp3in(i)=kp3
+                kp4in(i)=kp4
+                chon(i)=.true.
+             enddo
           enddo
           ick1=1
 ***** 1 squark and 1 slepton
@@ -1226,25 +1511,44 @@ ccc
           chcol=1
           cfactini=3.d0
           cfactfin=1.d0
+c============================================================
+c=== down squark - slepton
+c============================================================        
 ***** ... or a down-type squark:
         elseif(itype(1).eq.ivtype(kd)) then
           i=0
-          do f=1,3
-            kp3=kd+2*(f-1)
-            if(iifam(1).eq.ivfam(kp3)) then
-              i=i+1
-              kp3in(i)=kp3
-              chon(i)=.true.
-              kp3in(i+3)=kp3
-              chon(i+3)=.true.
-            endif
+          do f1=1,3
+             kp3=kd+2*(f1-1)
+             do f2=1,3
+                i=i+1
+                if (itype(2).eq.ivtype(ksnue)) then ! sneutrino
+                   kp4=knu(f2)
+                else            ! charged slepton
+                   kp4=kl(f2)
+                endif
+                kp3in(i)=kp3 ! sqd sl* -> d l-bar
+                kp4in(i)=kp4
+                chon(i)=.true.
+                kp3in(i+9)=kp3 ! sqd sl -> d l
+                kp4in(i+9)=kp4
+                chon(i+9)=.true.
+             enddo
           enddo
-          i=6
-          do f=1,3
-            kp3=ku+2*(f-1)
-            i=i+1
-            kp3in(i)=kp3
-            chon(i)=.true.
+
+          i=18
+          do f1=1,3             
+             kp3=ku+2*(f1-1)
+             do f2=1,3
+                i=i+1
+                if (itype(2).eq.ivtype(ksnue)) then ! sneutrino
+                   kp4=kl(f2)
+                else            ! charged slepton
+                   kp4=knu(f2)
+                endif
+                kp3in(i)=kp3
+                kp4in(i)=kp4
+                chon(i)=.true.
+             enddo
           enddo
           ick1=2
 ***** 1 squark and 1 slepton
@@ -1253,71 +1557,32 @@ ccc
           chcol=1
           cfactini=3.d0
           cfactfin=1.d0
-***** ... or it is slepton:
+        endif
+       
+***** identify the second slepton.
+        if (itype(2).eq.ivtype(knue)) then
+           ick2=1
         else
-          i=0
-          do f=1,3
-            if(itype(1).eq.ivtype(knue+2*(f-1))) then
-              kp3=knue+2*(f-1)
-              i=i+1
-              kp3in(i)=kp3
-              chon(i)=.true.
-              kp3in(i+3)=kp3
-              chon(i+3)=.true.
-              kp3=ke+2*(f-1)
-              kp3in(i+6)=kp3
-              chon(i+6)=.true.
-              ick1=1
-            elseif(itype(1).eq.ivtype(ke+2*(f-1))) then
-              kp3=ke+2*(f-1)
-              i=i+1
-              kp3in(i)=kp3
-              chon(i)=.true.
-              kp3in(i+3)=kp3
-              chon(i+3)=.true.
-              kp3=knue+2*(f-1)
-              kp3in(i+6)=kp3
-              chon(i+6)=.true.
-              ick1=2
-            endif
-          enddo 
-***** 2 sleptons
-          gg1=1.d0 
-          gg2=1.d0
-          chcol=1
-          cfactini=1.d0
-          cfactfin=3.d0
+           ick2=2
         endif
-***** identify the second slepton:
-        do f=1,3
-          if(itype(2).eq.ivtype(knue+2*(f-1))) then
-            kf2=knue+2*(f-1)
-            kf2o=ke+2*(f-1)
-            ick2=1
-          elseif(itype(2).eq.ivtype(ke+2*(f-1))) then
-            kf2=ke+2*(f-1)
-            kf2o=knue+2*(f-1)
-            ick2=2
-          endif
-        enddo
 ccc
         endif
 *****
 *************************************************** sf1 sf2* -> f1 f2bar
-        do i=1,3
+        do i=1,9
           if(chon(i)) then
             kp3=kp3in(i)
-            kp4=kf2
+            kp4=kp4in(i)
             icase=3
             call dsasfer(kp1i,kp2i,kp3,kp4,icase,result)
             prtial(i)=result*cfactini
           endif
         enddo  
 ******************************************************* sf1 sf2 -> f1 f2
-        do i=4,6
+        do i=10,18
           if(chon(i)) then
             kp3=kp3in(i)
-            kp4=kf2
+            kp4=kp4in(i)
             icase=3
             call dsasfere(kp1i,kp2i,kp3,kp4,icase,result)
             prtial(i)=result*cfactini
@@ -1325,11 +1590,11 @@ ccc
         enddo  
 *************************************************** sf1 sf2* -> f3 f4bar
 **************************************************** or sf1 sf2 -> f3 f4
-*****  f1 and f3 in the same doublet,  f2 and f4 in the same doublet
-        do i=6,9
+*****  f1 and f3 switched up/down, f2 and f4 switched up/down
+        do i=19,27
           if(chon(i)) then
             kp3=kp3in(i)
-            kp4=kf2o
+            kp4=kp4in(i)
             if(ick1.eq.ick2) then
               icase=3
               call dsasfer(kp1i,kp2i,kp3,kp4,icase,result)
@@ -1341,21 +1606,41 @@ ccc
           endif  
         enddo
 **************************************************** sum partial results
-        w=0.d0
-        w=w+prtial(1)            ! sq1(sl1) sl2* -> q1_1(l1) l2bar
-        w=w+prtial(2)            ! sq1 sl2* -> q1_2 l2bar
-        w=w+prtial(3)            ! sq1 sl2* -> q1_3 l2bar
-        w=w+prtial(4)            ! sq1(sl1) sl2 -> q1_1(l1) l2
-        w=w+prtial(5)            ! sq1 sl2 -> q1_2 l2
-        w=w+prtial(6)            ! sq1 sl2 -> q1_3 l2
-        w=w+prtial(7)            ! sf1(sl1) sf2*(sf2) -> f3_1(l3) f2bar(f2) 
-        w=w+prtial(8)            ! sf1 sf2*(sf2) -> f3_2 f2bar(f2) 
-        w=w+prtial(9)            ! sf1 sf2*(sf2) -> f3_3 f2bar(f2) 
+        w=0.d0 ! JE CORR, more states below (9->27)
+        w=w+prtial(1)           ! sq1 sl2* -> q1_1 lbar_1
+        w=w+prtial(2)           ! sq1 sl2* -> q1_1 lbar_2
+        w=w+prtial(3)           ! sq1 sl2* -> q1_1 lbar_3
+        w=w+prtial(4)           ! sq1 sl2* -> q1_2 lbar_1
+        w=w+prtial(5)           ! sq1 sl2* -> q1_2 lbar_2
+        w=w+prtial(6)           ! sq1 sl2* -> q1_2 lbar_3
+        w=w+prtial(7)           ! sq1 sl2* -> q1_3 lbar_1
+        w=w+prtial(8)           ! sq1 sl2* -> q1_3 lbar_2
+        w=w+prtial(9)           ! sq1 sl2* -> q1_3 lbar_3
+        w=w+prtial(10)          ! sq1 sl2 -> q1_1 l_1
+        w=w+prtial(11)          ! sq1 sl2 -> q1_1 l_2
+        w=w+prtial(12)          ! sq1 sl2 -> q1_1 l_3
+        w=w+prtial(13)          ! sq1 sl2 -> q1_2 l_1
+        w=w+prtial(14)          ! sq1 sl2 -> q1_2 l_2
+        w=w+prtial(15)          ! sq1 sl2 -> q1_2 l_3
+        w=w+prtial(16)          ! sq1 sl2 -> q1_3 l_1
+        w=w+prtial(17)          ! sq1 sl2 -> q1_3 l_2
+        w=w+prtial(18)          ! sq1 sl2 -> q1_3 l_3
+c...States with final states switched w.r.t initial state regarding up/down
+        w=w+prtial(19)          ! sq1 sl2* -> q1'_1 l'_1
+        w=w+prtial(20)          ! sq1 sl2* -> q1'_1 l'_2
+        w=w+prtial(21)          ! sq1 sl2* -> q1'_1 l'_3
+        w=w+prtial(22)          ! sq1 sl2* -> q1'_2 l'_1
+        w=w+prtial(23)          ! sq1 sl2* -> q1'_2 l'_2
+        w=w+prtial(24)          ! sq1 sl2* -> q1'_2 l'_3
+        w=w+prtial(25)          ! sq1 sl2* -> q1'_3 l'_1
+        w=w+prtial(26)          ! sq1 sl2* -> q1'_3 l'_2
+        w=w+prtial(27)          ! sq1 sl2* -> q1'_3 l'_3
+
 c
 c check for large negative terms in the fermion final states
 c
         wok=.true.
-        do i=1,9
+        do i=1,27
           if (prtial(i).lt.0.0d0) then
             if (dabs(prtial(i)/w).gt.fertoll) then
               wok=.false.
diff -rupN darksusy-5.1.3/src/as/dsasgbhb.f ../installed/darksusy/5.1.3/src/as/dsasgbhb.f
--- darksusy-5.1.3/src/as/dsasgbhb.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/as/dsasgbhb.f	2018-07-04 22:31:57.250487877 +0100
@@ -20,6 +20,9 @@
 *** added by Mia Schelke Jan 2007                          ***
 *** modified: Piero Ullio to include a new labelling of    ***
 *** states, 08-05-30                                       ***
+*** Modified: Joakim Edsjo to allow for family mixing      ***
+*** (assumptions were made on family belonging that were   ***
+*** not general enough). 2016-11-13                        ***      
 **************************************************************
 
       SUBROUTINE dsasgbhb(kp1,kp2,kp3,kp4,icase,result)
@@ -147,13 +150,14 @@ c      endif
      &          *gl(kgb,kp2,ksferuc(i))
         enddo
 ***** h^+ in s-channel ****************************************
-        if(kp1-kp2.ge.-3) then
+c        if(kp1-kp2.ge.-3) then !  JE CORR
+        ! JE CORR 161115 always include this s-channel
         khs=khc
         A1=A1-2.d0*dsasdepro(Svar,khs)*gl(khs,kp2,kp1)
      &          *gl(kgb,khb,khs)
         A2=A2-2.d0*dsasdepro(Svar,khs)*gl(khs,kp2,kp1)
      &          *gl(kgb,khb,khs)
-        endif
+c        endif ! JE CORR
 ***** W^+ in s-channel ****************************************
         kgs=kw
         Aaux=gl(kgs,kp2,kp1)*mass(kw)*gl(khb,kgb,kgs)
@@ -181,13 +185,14 @@ c      endif
         enddo
         endif
 ***** h^+ in s-channel ****************************************
-        if(kp1-kp2.ge.-3) then
+c        if(kp1-kp2.ge.-3) then ! JE CORR
+        ! JE CORR 161115 always include this s-channel
         khs=khc
         A1=A1-2.d0*dsasdepro(Svar,khs)*gl(khs,kp2,kp1)
      &          *gl(kgb,khb,khs)
         A2=A2-2.d0*dsasdepro(Svar,khs)*gl(khs,kp2,kp1)
      &          *gl(kgb,khb,khs)
-        endif
+c        endif ! JE CORR
         goto 600
       endif
 *****
@@ -202,7 +207,7 @@ c      endif
           A2=A2+2.d0*dsasdepro(Uvar,ksferuc(i))*gl(khb,kp1,ksferuc(i))
      &          *gl(kgb,ksferuc(i),kp2)       
         enddo   
-        if(abs(kp1-kp2).le.1) then
+c        if(abs(kp1-kp2).le.1) then ! JE CORR
 ***** h1 in s-channel  ****************************************
         khs=kh1
         A1=A1-2.d0*dsasdepro(Svar,khs)*gl(khs,kp2,kp1)
@@ -222,7 +227,7 @@ c      endif
      &          *gl(kgb,khb,khs)
           A2=A2-2.d0*dsasdepro(Svar,khs)*gl(khs,kp2,kp1)
      &          *gl(kgb,khb,khs)
-        endif
+c        endif ! JE CORR
         endif
         goto 600
       endif
@@ -238,7 +243,7 @@ c      endif
           A1=A1-2.d0*dsasdepro(Tvar,ksfertc(i))*gl(khb,kp2,ksfertc(i))
      &          *gl(kgb,ksfertc(i),kp1)
         enddo
-        if(abs(kp1-kp2).le.1) then
+c        if(abs(kp1-kp2).le.1) then ! JE CORR
 ***** h1 in s-channel  ****************************************
         khs=kh1
         A1=A1-2.d0*dsasdepro(Svar,khs)*gl(khs,kp2,kp1)
@@ -257,7 +262,7 @@ c      endif
      &        *gl(kgb,khb,khs)
         A2=A2-2.d0*dsasdepro(Svar,khs)*gl(khs,kp2,kp1)
      &        *gl(kgb,khb,khs)
-        endif
+c        endif ! JE CORR
         goto 600
       endif
 *****
@@ -298,7 +303,7 @@ c      endif
           A2=A2+2.d0*dsasdepro(Uvar,ksferun(i))*gl(khb,ksferun(i),kp1)
      &          *gl(kgb,kp2,ksferun(i))
         enddo
-        if(abs(kp1-kp2).le.1) then
+c        if(abs(kp1-kp2).le.1) then ! JE CORR
         if(nosneutrinov) then
 ***** (H^0_3 can not couple to a pair of sneutrinos as far as there 
 *****  are no right-handed sneutrinos)
@@ -315,7 +320,7 @@ c      endif
      &        *dsasdepro(Svar,kgs)
         A1=A1+(1.d0-(mass1**2-mass2**2)/mass(kgs)**2)*Aaux
         A2=A2+(-1.d0-(mass1**2-mass2**2)/mass(kgs)**2)*Aaux
-        endif
+c        endif ! JE CORR
         goto 600
       endif
 *****
@@ -338,7 +343,7 @@ c      endif
      &          *gl(kgb,kp2,ksferun(i))
         enddo
         endif
-        if(abs(kp1-kp2).le.1) then
+c        if(abs(kp1-kp2).le.1) then ! JE CORR
 ***** h1 in s-channel  ****************************************
         khs=kh1
         A1=A1-2.d0*dsasdepro(Svar,khs)*gl(khs,kp2,kp1)
@@ -351,7 +356,7 @@ c      endif
      &          *gl(kgb,khb,khs)
         A2=A2-2.d0*dsasdepro(Svar,khs)*gl(khs,kp2,kp1)
      &          *gl(kgb,khb,khs)
-        endif
+c        endif ! JE CORR
         goto 600
       endif
 *****
diff -rupN darksusy-5.1.3/src/dd/dsdddn1.f ../installed/darksusy/5.1.3/src/dd/dsdddn1.f
--- darksusy-5.1.3/src/dd/dsdddn1.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/dd/dsdddn1.f	2018-07-04 22:31:57.250487877 +0100
@@ -16,7 +16,12 @@ c
       delta=4.d0*mq2*ms2-(mq2+ms2-mx2)**2
       mx4=mx2*mx2
       if (abs(delta).lt.epsilon*mx4) then
-         delta=epsilon*mx4
+         if (delta.gt.0.0d0) then
+           delta=epsilon*mx4
+           if (delta.gt.(4.d0*mq2*ms2)) delta = 4.d0*mq2*ms2 ! avoid negative argument of srt, TB 2018-06-26
+         else ! added to ensure correct re-calcluation of mx2, TB 2018-06-26 
+           delta=-epsilon*mx4
+         endif
          mx2=mq2+ms2-dsqrt(4.d0*mq2*ms2-delta)
       endif
       sqrtdelta=dsqrt(dabs(delta))
diff -rupN darksusy-5.1.3/src/dd/dsdddn2.f ../installed/darksusy/5.1.3/src/dd/dsdddn2.f
--- darksusy-5.1.3/src/dd/dsdddn2.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/dd/dsdddn2.f	2018-07-04 22:31:57.250487877 +0100
@@ -16,7 +16,12 @@ c
       delta=4.d0*mq2*ms2-(mq2+ms2-mx2)**2
       mx4=mx2*mx2
       if (abs(delta).lt.epsilon*mx4) then
-         delta=epsilon*mx4
+         if (delta.gt.0.0d0) then
+           delta=epsilon*mx4
+           if (delta.gt.(4.d0*mq2*ms2)) delta = 4.d0*mq2*ms2 ! avoid negative argument of srt, TB 2018-06-26
+         else ! added to ensure correct re-calcluation of mx2, TB 2018-06-26 
+           delta=-epsilon*mx4
+         endif
          mx2=mq2+ms2-dsqrt(4.d0*mq2*ms2-delta)
       endif
       sqrtdelta=dsqrt(dabs(delta))
diff -rupN darksusy-5.1.3/src/dd/dsdddn3.f ../installed/darksusy/5.1.3/src/dd/dsdddn3.f
--- darksusy-5.1.3/src/dd/dsdddn3.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/dd/dsdddn3.f	2018-07-04 22:31:57.250487877 +0100
@@ -16,7 +16,12 @@ c
       delta=4.d0*mq2*ms2-(mq2+ms2-mx2)**2
       mx4=mx2*mx2
       if (abs(delta).lt.epsilon*mx4) then
-         delta=epsilon*mx4
+         if (delta.gt.0.0d0) then
+           delta=epsilon*mx4
+           if (delta.gt.(4.d0*mq2*ms2)) delta = 4.d0*mq2*ms2 ! avoid negative argument of srt, TB 2018-06-26
+         else ! added to ensure correct re-calcluation of mx2, TB 2018-06-26 
+           delta=-epsilon*mx4
+         endif
          mx2=mq2+ms2-dsqrt(4.d0*mq2*ms2-delta)
       endif
       sqrtdelta=dsqrt(dabs(delta))
diff -rupN darksusy-5.1.3/src/dd/dsdddn4.f ../installed/darksusy/5.1.3/src/dd/dsdddn4.f
--- darksusy-5.1.3/src/dd/dsdddn4.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/dd/dsdddn4.f	2018-07-04 22:31:57.250487877 +0100
@@ -16,7 +16,12 @@ c
       delta=4.d0*mq2*ms2-(mq2+ms2-mx2)**2
       mx4=mx2*mx2
       if (abs(delta).lt.epsilon*mx4) then
-         delta=epsilon*mx4
+         if (delta.gt.0.0d0) then
+           delta=epsilon*mx4
+           if (delta.gt.(4.d0*mq2*ms2)) delta = 4.d0*mq2*ms2 ! avoid negative argument of srt, TB 2018-06-26
+         else ! added to ensure correct re-calcluation of mx2, TB 2018-06-26 
+           delta=-epsilon*mx4
+         endif
          mx2=mq2+ms2-dsqrt(4.d0*mq2*ms2-delta)
       endif
       sqrtdelta=dsqrt(dabs(delta))
diff -rupN darksusy-5.1.3/src/dd/dsddgpgn.f ../installed/darksusy/5.1.3/src/dd/dsddgpgn.f
--- darksusy-5.1.3/src/dd/dsddgpgn.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/dd/dsddgpgn.f	2018-07-04 22:34:44.405230166 +0100
@@ -6,7 +6,7 @@ c    'dssusy.h' - file with susy common
 c  output:
 c    gps, gns : proton and neutron scalar four-fermion couplings
 c    gpa, gna : proton and neutron axial four-fermion couplings
-c    units: GeV^-4
+c    units: GeV^-2
 c  author: paolo gondolo (paolo@physics.utah.edu) 2004
 c    2008-02-16 paolo gondolo double spin-dependent squark contribution
 c    2008-02-16 paolo gondolo undo running quark masses in couplings
@@ -28,7 +28,7 @@ c=======================================
       real*8 f1q,df1q,fp,fn,aqh,aqd,aqs,fgh,fgd,fgs,agh,agd,ags
       ! fp,fn,f1q,df1q,du,dd,ds are twice those in drees-nojiri
       real*8 rmass(12) ! temporary array for lepton and quark running masses
-                       ! currently extracted from yukawa 
+                       ! currently extracted from yukawa
                        ! one day we will have rmass(k,q)
 
       kx = kn(kln)
@@ -153,78 +153,127 @@ c     u,d,s
      &           mass(kh2)**2/rmass(ks)*fts(z)
             aqd = 0.d0
             aqs = 0.d0
-            do i=1,6
-               aqd = aqd        ! squarks: u,d,s tree a^2-b^2
-     &              - 0.5d0*dreal(gl(ksqu(i),kx,ku)*
-     &              conjg(gr(ksqu(i),kx,ku)))/rmass(ku)/
-     &              (mass(ksqu(i))**2-(mx+mass(ku))**2)*ftu(z)
-     &              - 0.5d0*dreal(gl(ksqd(i),kx,kd)*
-     &              conjg(gr(ksqd(i),kx,kd)))/rmass(kd)/
-     &              (mass(ksqd(i))**2-(mx+mass(kd))**2)*ftd(z)
-     &              - 0.5d0*dreal(gl(ksqd(i),kx,ks)*
-     &              conjg(gr(ksqd(i),kx,ks)))/rmass(ks)/
-     &              (mass(ksqd(i))**2-(mx+mass(ks))**2)*fts(z)
-               aqs = aqs        ! squarks: u,d,s tree & twist-2 a^2+b^2
-     &              + 0.125*mx*(dsabsq(gl(ksqu(i),kx,ku))+
-     &              dsabsq(gr(ksqu(i),kx,ku)))/
-     &              (mass(ksqu(i))**2-(mx+mass(ku))**2)**2*(ftu(z)+
-     &              3.d0*dsddo(1,z,mass(ksqu(i))**2-(mx+mass(ku))**2))
-     &              + 0.125*mx*(dsabsq(gl(ksqd(i),kx,kd))+
-     &              dsabsq(gr(ksqd(i),kx,kd)))/
-     &              (mass(ksqd(i))**2-(mx+mass(kd))**2)**2*(ftd(z)+ 
-     &              3.d0*dsddo(2,z,mass(ksqd(i))**2-(mx+mass(kd))**2))
-     &              + 0.125*mx*(dsabsq(gl(ksqd(i),kx,ks))+
-     &              dsabsq(gr(ksqd(i),kx,ks)))/
-     &              (mass(ksqd(i))**2-(mx+mass(ks))**2)**2*(fts(z)+
-     &              3.d0*dsddo(4,z,mass(ksqu(i))**2-(mx+mass(ks))**2))
-               aqs = aqs        ! squarks: c twist-2 a^2+b^2
-     &              + 0.125*mx*(dsabsq(gl(ksqu(i),kx,kc))+
-     &              dsabsq(gr(ksqu(i),kx,kc)))/
-     &              (mass(ksqu(i))**2-(mx+mass(kc))**2)**2*
-     &              3.d0*dsddo(3,z,mass(ksqu(i))**2-(mx+mass(kc))**2)
-               tmp1 =           ! squarks: b twist-2 a^2+b^2
-     &              + 0.125*mx*(dsabsq(gl(ksqd(i),kx,kb))+
-     &              dsabsq(gr(ksqd(i),kx,kb)))/
-     &              (mass(ksqd(i))**2-(mx+mass(kb))**2)**2*
-     &              3.d0*dsddo(6,z,mass(ksqd(i))**2-(mx+mass(kb))**2)
-               tmp2 = asmb*dsddo(0,z,mass(kb)**2)/4.d0/pi*(
-     &              +0.125*mx*(dsabsq(gl(ksqd(i),kx,kb))+
-     &              dsabsq(gr(ksqd(i),kx,kb)))*
-     &              dsdddn4(mass(ksqd(i)),mass(kb),mx)
-     &              - 0.5d0*dreal(gl(ksqd(i),kx,kb)*
-     &              conjg(gr(ksqd(i),kx,kb)))/rmass(kb)*
-     &              dsdddn3(mass(ksqd(i)),mass(kb),mx))
-               if (dabs(tmp1).lt.dabs(tmp2)) then
-                  aqs = aqs + tmp1
-               else
-                  aqs = aqs + tmp2
-               endif
-               aqs = aqs        ! squarks: t twist-2 a^2+b^2
-     &              +asmt*dsddo(0,z,mass(kt)**2)/4.d0/pi*(
-     &              +0.125*mx*(dsabsq(gl(ksqu(i),kx,kt))+
-     &              dsabsq(gr(ksqu(i),kx,kt)))*
-     &              dsdddn4(mass(ksqu(i)),mass(kt),mx)
-     &              - 0.5d0*dreal(gl(ksqu(i),kx,kt)*
-     &              conjg(gr(ksqu(i),kx,kt)))/rmass(kt)*
-     &              dsdddn3(mass(ksqu(i)),mass(kt),mx))
-            enddo
+            if (ddpole.eq.1) then
+               do i=1,6
+                  aqd = aqd     ! squarks: u,d,s tree a^2-b^2
+     &                 - 0.5d0*dreal(gl(ksqu(i),kx,ku)*
+     &                 conjg(gr(ksqu(i),kx,ku)))/rmass(ku)/
+     &                 (mass(ksqu(i))**2-(mx+mass(ku))**2)*ftu(z)
+     &                 - 0.5d0*dreal(gl(ksqd(i),kx,kd)*
+     &                 conjg(gr(ksqd(i),kx,kd)))/rmass(kd)/
+     &                 (mass(ksqd(i))**2-(mx+mass(kd))**2)*ftd(z)
+     &                 - 0.5d0*dreal(gl(ksqd(i),kx,ks)*
+     &                 conjg(gr(ksqd(i),kx,ks)))/rmass(ks)/
+     &                 (mass(ksqd(i))**2-(mx+mass(ks))**2)*fts(z)
+                  aqs = aqs     ! squarks: u,d,s tree & twist-2 a^2+b^2
+     &                 + 0.125*mx*(dsabsq(gl(ksqu(i),kx,ku))+
+     &                 dsabsq(gr(ksqu(i),kx,ku)))/
+     &                 (mass(ksqu(i))**2-(mx+mass(ku))**2)**2*(ftu(z)+
+     &                 3.d0*dsddo(1,z,mass(ksqu(i))**2-(mx+mass(ku))**2))
+     &                 + 0.125*mx*(dsabsq(gl(ksqd(i),kx,kd))+
+     &                 dsabsq(gr(ksqd(i),kx,kd)))/
+     &                 (mass(ksqd(i))**2-(mx+mass(kd))**2)**2*(ftd(z)+
+     &                 3.d0*dsddo(2,z,mass(ksqd(i))**2-(mx+mass(kd))**2))
+     &                 + 0.125*mx*(dsabsq(gl(ksqd(i),kx,ks))+
+     &                 dsabsq(gr(ksqd(i),kx,ks)))/
+     &                 (mass(ksqd(i))**2-(mx+mass(ks))**2)**2*(fts(z)+
+     &                 3.d0*dsddo(4,z,mass(ksqu(i))**2-(mx+mass(ks))**2))
+                  aqs = aqs     ! squarks: c twist-2 a^2+b^2
+     &                 + 0.125*mx*(dsabsq(gl(ksqu(i),kx,kc))+
+     &                 dsabsq(gr(ksqu(i),kx,kc)))/
+     &                 (mass(ksqu(i))**2-(mx+mass(kc))**2)**2*
+     &                 3.d0*dsddo(3,z,mass(ksqu(i))**2-(mx+mass(kc))**2)
+                  tmp1 =        ! squarks: b twist-2 a^2+b^2
+     &                 + 0.125*mx*(dsabsq(gl(ksqd(i),kx,kb))+
+     &                 dsabsq(gr(ksqd(i),kx,kb)))/
+     &                 (mass(ksqd(i))**2-(mx+mass(kb))**2)**2*
+     &                 3.d0*dsddo(6,z,mass(ksqd(i))**2-(mx+mass(kb))**2)
+                  tmp2 = asmb*dsddo(0,z,mass(kb)**2)/4.d0/pi*(
+     &                 +0.125*mx*(dsabsq(gl(ksqd(i),kx,kb))+
+     &                 dsabsq(gr(ksqd(i),kx,kb)))*
+     &                 dsdddn4(mass(ksqd(i)),mass(kb),mx)
+     &                 - 0.5d0*dreal(gl(ksqd(i),kx,kb)*
+     &                 conjg(gr(ksqd(i),kx,kb)))/rmass(kb)*
+     &                 dsdddn3(mass(ksqd(i)),mass(kb),mx))
+                  if (dabs(tmp1).lt.dabs(tmp2)) then
+                     aqs = aqs + tmp1
+                  else
+                     aqs = aqs + tmp2
+                  endif
+                  aqs = aqs     ! squarks: t twist-2 a^2+b^2
+     &                 +asmt*dsddo(0,z,mass(kt)**2)/4.d0/pi*(
+     &                 +0.125*mx*(dsabsq(gl(ksqu(i),kx,kt))+
+     &                 dsabsq(gr(ksqu(i),kx,kt)))*
+     &                 dsdddn4(mass(ksqu(i)),mass(kt),mx)
+     &                 - 0.5d0*dreal(gl(ksqu(i),kx,kt)*
+     &                 conjg(gr(ksqu(i),kx,kt)))/rmass(kt)*
+     &                 dsdddn3(mass(ksqu(i)),mass(kt),mx))
+               enddo
+            else ! (ddpole=0), i.e. no poles
+               do i=1,6
+                  aqd = aqd     ! squarks: u,d,s tree a^2-b^2
+     &                 - 0.5d0*dreal(gl(ksqu(i),kx,ku)*
+     &                 conjg(gr(ksqu(i),kx,ku)))/rmass(ku)/
+     &                 (mass(ksqu(i))**2)*ftu(z)
+     &                 - 0.5d0*dreal(gl(ksqd(i),kx,kd)*
+     &                 conjg(gr(ksqd(i),kx,kd)))/rmass(kd)/
+     &                 (mass(ksqd(i))**2)*ftd(z)
+     &                 - 0.5d0*dreal(gl(ksqd(i),kx,ks)*
+     &                 conjg(gr(ksqd(i),kx,ks)))/rmass(ks)/
+     &                 (mass(ksqd(i))**2)*fts(z)
+                  aqs = aqs     ! squarks: u,d,s tree & twist-2 a^2+b^2
+     &                 + 0.125*mx*(dsabsq(gl(ksqu(i),kx,ku))+
+     &                 dsabsq(gr(ksqu(i),kx,ku)))/
+     &                 (mass(ksqu(i))**2)**2*(ftu(z)+
+     &                 3.d0*dsddo(1,z,mass(ksqu(i))**2))
+     &                 + 0.125*mx*(dsabsq(gl(ksqd(i),kx,kd))+
+     &                 dsabsq(gr(ksqd(i),kx,kd)))/
+     &                 (mass(ksqd(i))**2)**2*(ftd(z)+
+     &                 3.d0*dsddo(2,z,mass(ksqd(i))**2))
+     &                 + 0.125*mx*(dsabsq(gl(ksqd(i),kx,ks))+
+     &                 dsabsq(gr(ksqd(i),kx,ks)))/
+     &                 (mass(ksqd(i))**2)**2*(fts(z)+
+     &                 3.d0*dsddo(4,z,mass(ksqu(i))**2))
+                  aqs = aqs     ! squarks: c twist-2 a^2+b^2
+     &                 + 0.125*mx*(dsabsq(gl(ksqu(i),kx,kc))+
+     &                 dsabsq(gr(ksqu(i),kx,kc)))/
+     &                 (mass(ksqu(i))**2)**2*
+     &                 3.d0*dsddo(3,z,mass(ksqu(i))**2)
+                  aqs = aqs       ! squarks: b twist-2 a^2+b^2
+     &                 +asmb*dsddo(0,z,mass(kb)**2)/4.d0/pi*(
+     &                 +0.125*mx*(dsabsq(gl(ksqd(i),kx,kb))+
+     &                 dsabsq(gr(ksqd(i),kx,kb)))*
+     &                 dsdddn4(mass(ksqd(i)),mass(kb),mx)
+     &                 - 0.5d0*dreal(gl(ksqd(i),kx,kb)*
+     &                 conjg(gr(ksqd(i),kx,kb)))/rmass(kb)*
+     &                 dsdddn3(mass(ksqd(i)),mass(kb),mx))
+                  aqs = aqs     ! squarks: t twist-2 a^2+b^2
+     &                 +asmt*dsddo(0,z,mass(kt)**2)/4.d0/pi*(
+     &                 +0.125*mx*(dsabsq(gl(ksqu(i),kx,kt))+
+     &                 dsabsq(gr(ksqu(i),kx,kt)))*
+     &                 dsdddn4(mass(ksqu(i)),mass(kt),mx)
+     &                 - 0.5d0*dreal(gl(ksqu(i),kx,kt)*
+     &                 conjg(gr(ksqu(i),kx,kt)))/rmass(kt)*
+     &                 dsdddn3(mass(ksqu(i)),mass(kt),mx))
+               enddo
+            endif
             if (z.eq.1) then
                fp = fp + m_p * (aqh+aqd+aqs+agh+agd+ags)
-               if (prtlevel.ge.1) then
+               if (prtlevel.gt.1) then
                   write (*,*) '(p) aqh=',aqh,' aqd=',aqd, ' aqs=',aqs
                   write (*,*) '(p) agh=',agh,' agd=',agd, ' ags=',ags
                endif
             endif
             if (z.eq.2) then
                fn = fn + m_n * (aqh+aqd+aqs+agh+agd+ags)
-               if (prtlevel.ge.1) then
+               if (prtlevel.gt.1) then
                   write (*,*) '(n) aqh=',aqh,' aqd=',aqd, ' aqs=',aqs
                   write (*,*) '(n) agh=',agh,' agd=',agd, ' ags=',ags
                endif
             endif
          enddo
       else
-c     
+c
 c     without poles, without twist-2 terms
 c
          do g=1,3
@@ -284,8 +333,8 @@ c     &        (mass(ksqd(i))**2-(mx+mq)
             fn = fn + f1q*ftn(q)*(m_n/rmq)
          enddo
       endif
-      gps = fp   ! in gev^-4
-      gns = fn   ! in gev^-4
+      gps = fp   ! in gev^-2
+      gns = fn   ! in gev^-2
 
 c
 c     SPIN DEPENDENT
@@ -298,7 +347,7 @@ c
       ds = 0.5*gr(kz,kx,kx)*(gl(kz,ks,ks)-gr(kz,ks,ks))/
      &     mass(kz)**2
       do i=1,6
-        if (ddpole.eq.1.or.dddn.eq.1) then
+        if (ddpole.eq.1) then ! PS Corr 180704, removed dddn.eq.1 alternative
           du = du
      &       + 0.25*(dsabsq(gl(ksqu(i),kx,ku))+
      &                dsabsq(gr(ksqu(i),kx,ku)))/
@@ -310,7 +359,7 @@ c
           ds = ds
      &       + 0.25*(dsabsq(gl(ksqd(i),kx,ks))+
      &                dsabsq(gr(ksqd(i),kx,ks)))/
-     &         (mass(ksqu(i))**2-(mx+mass(ks))**2)
+     &         (mass(ksqd(i))**2-(mx+mass(ks))**2) ! JE Corr 171024, ksqu->ksqd
         else
           du = du
      &       + 0.25*(dsabsq(gl(ksqu(i),kx,ku))+
@@ -323,11 +372,11 @@ c
           ds = ds
      &       + 0.25*(dsabsq(gl(ksqd(i),kx,ks))+
      &                dsabsq(gr(ksqd(i),kx,ks)))/
-     &         (mass(ksqu(i))**2)
+     &         (mass(ksqd(i))**2) ! JE Corr 171024, ksqu->ksqd
          endif
       enddo
-      gpa = du*delu+dd*deld+ds*dels ! in gev^-4
-      gna = du*deld+dd*delu+ds*dels ! in gev^-4
+      gpa = du*delu+dd*deld+ds*dels ! in gev^-2
+      gna = du*deld+dd*delu+ds*dels ! in gev^-2
 
       return
       end
diff -rupN darksusy-5.1.3/src/ep/dsepmstable.f ../installed/darksusy/5.1.3/src/ep/dsepmstable.f
--- darksusy-5.1.3/src/ep/dsepmstable.f	2006-06-19 15:36:02.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/ep/dsepmstable.f	2018-07-04 22:31:57.250487877 +0100
@@ -12,7 +12,8 @@
 
       include 'dsepcom.h'
 
-      integer idxlo,idxhi
+      integer :: idxlo = 0
+      integer :: idxhi = 0
       real*8 eep,aa,bb,cc,ww,xx,yy,frac
 
       call dshunt(mselo,10,eep,idxlo)
@@ -46,6 +47,6 @@
          xx=msxtab(idxhi)+frac*(msxtab(idxhi+1)-msxtab(idxhi))
          yy=msytab(idxhi)+frac*(msytab(idxhi+1)-msytab(idxhi))
       endif
-      
+
       end
-      
+
diff -rupN darksusy-5.1.3/src/hm/dshmudfearthtab.f ../installed/darksusy/5.1.3/src/hm/dshmudfearthtab.f
--- darksusy-5.1.3/src/hm/dshmudfearthtab.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/hm/dshmudfearthtab.f	2018-07-04 22:31:57.250487877 +0100
@@ -5,12 +5,12 @@
 *** and then lines with two columns each  with u and u*DF(u).
 *** u should be in units of km/s and u*DF(u) (or f(u)/u) in units
 *** of (km/s)^(-2).
-*** 
+***
 *** The file loaded is given by the option type.
 *** Some possible types are velocity distributions as obtained from
 *** numerical simulations of WIMP propagation in the solar system
-*** including solar capture. 
-*** 
+*** including solar capture.
+***
 *** For the simulations made by Johan Lundberg, see astro-ph/0401113,
 *** available options are
 ***   type = 1, reads file <ds-root>/dat/vdfearth-sdbest.dat :
@@ -25,7 +25,7 @@
 ***   Note: tot.txt is the best estimate of the distribution at Earth
 ***   and should be used as a default
 ***
-*** There are also other options, like 
+*** There are also other options, like
 ***   type = 5, read a user-supplied file with file name given
 ***     by udfearthfile in dshmcom.h. If you change the file or
 ***     for any other reason want to reload it here, you have to
@@ -52,8 +52,9 @@
       data sdload/sdopt*.true./
       common /ntsdvel/sdu,sdf,sdn
       save /ntsdvel/,sdload
-      
-      integer i,fl,l,m
+
+      integer :: i = 0
+      integer fl,l,m
       real*8 u,upl
 
       character*200 file,scr
@@ -65,7 +66,7 @@ c...Read in velocity distribution if fir
       endif
 
 c...Read in the file if not already loaded
-      if (sdload(type).or.(type.eq.5.and.udfearthload)) then 
+      if (sdload(type).or.(type.eq.5.and.udfearthload)) then
         sdload(type)=.false.
 
         if (type.eq.1) then
@@ -120,7 +121,7 @@ c...Now interpolate in the table
 
       goto 120
 
-      write(*,*) 
+      write(*,*)
      &  'ERROR in dshmuDFearthtab: data file corrupt. Please fix ',file
       dshmuDFearthtab=0.0d0
       return
diff -rupN darksusy-5.1.3/src/hm/dshmudftab.f ../installed/darksusy/5.1.3/src/hm/dshmudftab.f
--- darksusy-5.1.3/src/hm/dshmudftab.f	2012-07-15 22:04:50.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/hm/dshmudftab.f	2018-07-04 22:31:57.250487877 +0100
@@ -5,12 +5,12 @@
 *** and then lines with two columns each  with u and u*DF(u).
 *** u should be in units of km/s and u*DF(u) (or f(u)/u) in units
 *** of (km/s)^(-2).
-*** 
+***
 *** The file loaded is given by the option type.
 *** Some possible types are velocity distributions as obtained from
 *** numerical simulations of WIMP propagation in the solar system
-*** including solar capture. 
-*** 
+*** including solar capture.
+***
 *** Available options
 ***   type = 1, read a user-supplied file with file name given
 ***     by udffile in dshmcom.h. If you change the file or
@@ -37,8 +37,9 @@
       data dfload/dfopt*.false./
       common /ntdfvel/dfu,dff,dfn
       save /ntdfvel/,dfload
-      
-      integer i,fl,l,m
+
+      integer :: i = 0
+      integer fl,l,m
       real*8 u,upl
 
       character*200 file,scr
@@ -93,7 +94,7 @@ c...Now interpolate in the table
 
       goto 120
 
-      write(*,*) 
+      write(*,*)
      &  'ERROR in dshmudftab: data file corrupt. Please fix ',file
       dshmudftab=0.0d0
       return
diff -rupN darksusy-5.1.3/src/ib/dsIBffdxdy.f ../installed/darksusy/5.1.3/src/ib/dsIBffdxdy.f
--- darksusy-5.1.3/src/ib/dsIBffdxdy.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ib/dsIBffdxdy.f	2018-07-04 22:31:57.254485877 +0100
@@ -259,14 +259,14 @@ c       endif
 
 c...check that result is positive
       if (0.gt.tmpresult) then
-        if (m0**2*tmpresult.lt.(-1D-12)
-     -     .and.(idtag.ne.memory)) then
-          write(*,*) '*****'
-          write (*,*) 'Error in dsIBffdxdy (channel:',IBch,
-     -                '): negative |M|^2 for model ',idtag,'.'
-          write (*,*) 'Setting corresponding contributions to zero...'
-          write(*,*) '*****'
-        endif
+c        if (m0**2*tmpresult.lt.(-1D-12)
+c     -     .and.(idtag.ne.memory)) then
+c          write(*,*) '*****'
+c          write (*,*) 'Error in dsIBffdxdy (channel:',IBch,
+c     -                '): negative |M|^2 for model ',idtag,'.'
+c          write (*,*) 'Setting corresponding contributions to zero...'
+c          write(*,*) '*****'
+c        endif
         return
       endif
 
diff -rupN darksusy-5.1.3/src/ib/dsIBfsrdxdy.f ../installed/darksusy/5.1.3/src/ib/dsIBfsrdxdy.f
--- darksusy-5.1.3/src/ib/dsIBfsrdxdy.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ib/dsIBfsrdxdy.f	2018-07-04 22:31:57.254485877 +0100
@@ -62,10 +62,10 @@ c... from a full analytical calculation
 
 c...check that result is positive
       if (0.gt.fsrtmp) then
-        write(*,*) '*****'
-        write (*,*) 'Error in dsIBfsrdxdy: negative |M|^2 !'
-        write (*,*) 'Setting corresponding contributions to zero...'
-        write(*,*) '*****'
+c        write(*,*) '*****'
+c        write (*,*) 'Error in dsIBfsrdxdy: negative |M|^2 !'
+c        write (*,*) 'Setting corresponding contributions to zero...'
+c        write(*,*) '*****'
         dsIBfsrdxdy=0d0
         return
       endif
diff -rupN darksusy-5.1.3/src/ib/dsIBhhdxdy.f ../installed/darksusy/5.1.3/src/ib/dsIBhhdxdy.f
--- darksusy-5.1.3/src/ib/dsIBhhdxdy.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ib/dsIBhhdxdy.f	2018-07-04 22:31:57.254485877 +0100
@@ -80,15 +80,15 @@ c...import full IB expression for |M|**2
 
 c...check that the result is positive
       if (0.gt.tmpresult) then
-        if (m0**2*tmpresult.lt.(-1D-15)
-     -     .and.(idtag.ne.memory)) then
-          write(*,*) '*****'
-          write (*,*) 'Error in dsIBhhdxdy: ',
-     -                'negative |M|^2 for model ',
-     -                 idtag,'.'
-          write (*,*) ' Setting corresponding contributions to zero...'
-          write(*,*) '*****'
-        endif
+c        if (m0**2*tmpresult.lt.(-1D-15)
+c     -     .and.(idtag.ne.memory)) then
+c          write(*,*) '*****'
+c          write (*,*) 'Error in dsIBhhdxdy: ',
+c     -                'negative |M|^2 for model ',
+c     -                 idtag,'.'
+c          write (*,*) ' Setting corresponding contributions to zero...'
+c          write(*,*) '*****'
+c        endif
         return
       endif
 
diff -rupN darksusy-5.1.3/src/ib/dsIBwhdxdy.f ../installed/darksusy/5.1.3/src/ib/dsIBwhdxdy.f
--- darksusy-5.1.3/src/ib/dsIBwhdxdy.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ib/dsIBwhdxdy.f	2018-07-04 22:31:57.254485877 +0100
@@ -205,14 +205,14 @@ c       endif
 
 c...check that result is positive
       if (0.gt.tmpresult) then
-        if (m0**2*tmpresult.lt.(-1D-10)
-     -     .and.(idtag.ne.memory)) then
-          write(*,*) '*****'
-          write (*,*) 'Error in dsIBwhdxdy: ',
-     -                'negative |M|^2 for model ',idtag,'.'
-          write (*,*) 'Setting corresponding contributions to zero...'
-          write(*,*) '*****'
-        endif
+c        if (m0**2*tmpresult.lt.(-1D-10)
+c     -     .and.(idtag.ne.memory)) then
+c          write(*,*) '*****'
+c          write (*,*) 'Error in dsIBwhdxdy: ',
+c     -                'negative |M|^2 for model ',idtag,'.'
+c          write (*,*) 'Setting corresponding contributions to zero...'
+c          write(*,*) '*****'
+c        endif
         return
       endif
 
diff -rupN darksusy-5.1.3/src/ib/dsIBwwdxdy.f ../installed/darksusy/5.1.3/src/ib/dsIBwwdxdy.f
--- darksusy-5.1.3/src/ib/dsIBwwdxdy.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ib/dsIBwwdxdy.f	2018-07-04 22:31:57.254485877 +0100
@@ -137,14 +137,14 @@ c       endif
 
 c...check that result is positive
       if (0.gt.tmpresult) then
-        if (m0**2*tmpresult.lt.(-1D-10)
-     -     .and.(idtag.ne.memory)) then
-          write(*,*) '*****'
-          write (*,*) 'Error in dsIBwwdxdy:',
-     -                ' negative |M|^2 for model ',idtag,'.'
-          write (*,*) 'Setting corresponding contributions to zero...'
-          write(*,*) '*****'
-        endif
+c        if (m0**2*tmpresult.lt.(-1D-10)
+c     -     .and.(idtag.ne.memory)) then
+c          write(*,*) '*****'
+c          write (*,*) 'Error in dsIBwwdxdy:',
+c     -                ' negative |M|^2 for model ',idtag,'.'
+c          write (*,*) 'Setting corresponding contributions to zero...'
+c          write(*,*) '*****'
+c        endif
         return
       endif
 
diff -rupN darksusy-5.1.3/src/ini/dsdirname.c.in ../installed/darksusy/5.1.3/src/ini/dsdirname.c.in
--- darksusy-5.1.3/src/ini/dsdirname.c.in	2008-02-21 16:08:34.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ini/dsdirname.c.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-/* #include "../../config.h" */
-#include <string.h>
-
-#define DSROOTNAME "@prefix@"
-
-void dsdirname(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSROOTNAME);
-  return;
-}
-
-void dsdirname_(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSROOTNAME);
-  return;
-}
-
-void dsdirname__(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSROOTNAME);
-  return;
-}
diff -rupN darksusy-5.1.3/src/ini/dsinit.f ../installed/darksusy/5.1.3/src/ini/dsinit.f
--- darksusy-5.1.3/src/ini/dsinit.f	2013-02-10 06:43:34.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ini/dsinit.f	2018-07-04 22:31:57.254485877 +0100
@@ -299,16 +299,27 @@ c... numbers are conventional, no physic
       ivtype(ksnue)=11
       ivtype(kse1)=12
       ivtype(kse2)=12
-      ivtype(knumu)=21
-      ivtype(kmu)=22
-      ivtype(ksnumu)=21
-      ivtype(ksmu1)=22
-      ivtype(ksmu2)=22
-      ivtype(knutau)=31
-      ivtype(ktau)=32
-      ivtype(ksnutau)=31
-      ivtype(kstau1)=32
-      ivtype(kstau2)=32
+c      ivtype(knumu)=21
+c      ivtype(kmu)=22
+c      ivtype(ksnumu)=21
+c      ivtype(ksmu1)=22
+c      ivtype(ksmu2)=22
+c      ivtype(knutau)=31
+c      ivtype(ktau)=32
+c      ivtype(ksnutau)=31
+c      ivtype(kstau1)=32
+c      ivtype(kstau2)=32
+      ivtype(knumu)=11 ! JE CORRECTION
+      ivtype(kmu)=12
+      ivtype(ksnumu)=11
+      ivtype(ksmu1)=12
+      ivtype(ksmu2)=12
+      ivtype(knutau)=11
+      ivtype(ktau)=12
+      ivtype(ksnutau)=11
+      ivtype(kstau1)=12
+      ivtype(kstau2)=12
+
       ivtype(ku)=41
       ivtype(kd)=42
       ivtype(ksu1)=41
diff -rupN darksusy-5.1.3/src/ini/dssetdsinstall.f ../installed/darksusy/5.1.3/src/ini/dssetdsinstall.f
--- darksusy-5.1.3/src/ini/dssetdsinstall.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ini/dssetdsinstall.f	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-      subroutine dssetdsinstall
-      implicit none
-      integer i
-      character*300 name
-      include 'dsdirver.h'
-      call dsdirname(name)
-      i=1
- 10   if (name(i:i).eq.'\000') goto 20
-      i=i+1
-      goto 10
- 20   i=i-1
-c      write (*,*) 'i=',i
-cccc      dsinstall=name(:i)//'/'
-      write (*,*) 'dssetdsinstall: cannot reset dsinstall'
-      stop
-c      write (*,*) dsinstall
-      end
diff -rupN darksusy-5.1.3/src/ini/dssetdsversion.f ../installed/darksusy/5.1.3/src/ini/dssetdsversion.f
--- darksusy-5.1.3/src/ini/dssetdsversion.f	2008-02-21 16:08:34.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ini/dssetdsversion.f	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-      subroutine dssetdsversion
-      implicit none
-      integer i
-      character*300 name
-      include 'dsdirver.h'
-      call dsvername(name)
-      i=1
- 10   if (name(i:i).eq.'\000') goto 20
-      i=i+1
-      goto 10
- 20   i=i-1
-c      write (*,*) 'i=',i
-      dsversion=name(:i)
-c      write (*,*) dsversion
-      end
diff -rupN darksusy-5.1.3/src/ini/dsvername.c.in ../installed/darksusy/5.1.3/src/ini/dsvername.c.in
--- darksusy-5.1.3/src/ini/dsvername.c.in	2008-02-21 16:08:34.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ini/dsvername.c.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-/* #include "../../config.h" */
-#include <string.h>
-
-#define DSVERNAME "@DSVERSION@@DSREV@"
-
-void dsvername(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSVERNAME);
-  return;
-}
-
-void dsvername_(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSVERNAME);
-  return;
-}
-
-void dsvername__(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSVERNAME);
-  return;
-}
diff -rupN darksusy-5.1.3/src/ini/makefile ../installed/darksusy/5.1.3/src/ini/makefile
--- darksusy-5.1.3/src/ini/makefile	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/ini/makefile	2018-07-04 22:32:03.175523959 +0100
@@ -0,0 +1,37 @@
+# Makefile for ini directory
+# Author: Joakim Edsjo, edsjo@physto.se
+# Changed by Paolo Gondolo (2011)
+# This file is automatically created by makemfpg.pl on Nov 04, 2011.
+
+# Define fortran compiler and options (set when ./configure is run
+# in the DarkSUSY root directory
+FF=/usr/bin/gfortran
+FOPT= -fPIC -ffree-line-length-none -ffixed-line-length-none -cpp -fopenmp
+
+FC=$(FF)
+FFLAGS=$(FOPT) -c -I$(DINC)
+
+# Dependencies and libraries
+DINC=../../include
+DOBJ=../../build
+
+INC_DEP = dsprep.h dsrncom.h dsmssm.h dsascom.h dsaccom.h dsio.h \
+dsandwcom.h dsnuclides.h dsidtag.h dsdirver.h dspbcom.h dshacom.h \
+dswacom.h
+
+vpath %.h $(DINC)
+
+SRC = dscval.f dsfval.f dsinit.f dsival.f dskillsp.f dslowcase.f \
+dslval.f dsreadnuclides.f dsreadpar.f
+
+OBJ = $(patsubst %.f,$(DOBJ)/%.o,$(SRC))
+
+OBJF = $(patsubst %.F,$(DOBJ)/%.o,$(SRC))
+
+all : $(OBJ) $(OBJF)
+
+$(DOBJ)/%.o : %.F $(INC_DEP)
+	$(FC) $(FFLAGS) $< -o $@
+
+$(DOBJ)/%.o : %.f $(INC_DEP)
+	$(FC) $(FFLAGS) $< -o $@
diff -rupN darksusy-5.1.3/src/ini/makefile.in ../installed/darksusy/5.1.3/src/ini/makefile.in
--- darksusy-5.1.3/src/ini/makefile.in	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/ini/makefile.in	2018-07-04 22:31:57.254485877 +0100
@@ -22,7 +22,7 @@ dswacom.h
 vpath %.h $(DINC)
 
 SRC = dscval.f dsfval.f dsinit.f dsival.f dskillsp.f dslowcase.f \
-dslval.f dsreadnuclides.f dsreadpar.f dssetdsinstall.f dssetdsversion.f
+dslval.f dsreadnuclides.f dsreadpar.f
 
 OBJ = $(patsubst %.f,$(DOBJ)/%.o,$(SRC))
 
diff -rupN darksusy-5.1.3/src/makefile.in ../installed/darksusy/5.1.3/src/makefile.in
--- darksusy-5.1.3/src/makefile.in	2015-04-07 10:23:05.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/makefile.in	2018-07-04 22:31:57.254485877 +0100
@@ -10,14 +10,16 @@
 #### DO NOT CHANGE ANYTHING BELOW THIS LINE ###
 ###############################################
 
+FF=@F77@
+FOPT=@FOPT@
+
 # Here we set where the library goes and where include files are.
 
-LIB=../lib
 INC=../include
 TSPACKDIR=@TSPACKDIR@
 BUILD=../build
 
-vpath %.a $(LIB)
+vpath %.a $(DS_LIB)
 
 DIRS = ac bsg an an1l anstu as dd ep	\
 ge ha hm hr ib ini mh wa nt pb db rd rge rn su ucmh xcern	\
@@ -32,18 +34,22 @@ all-local : make-lib
 make-lib :
 	cd ..; make dslib
 
-all : libdarksusy.a
+all : libdarksusy.a libdarksusy.so
 
 libdarksusy.a : $(DOBJ)
-	ar rS $(LIB)/libdarksusy.a $(BUILD)/*.o
-	ranlib $(LIB)/libdarksusy.a
+	ar rS $(DS_LIB)/libdarksusy.a $(BUILD)/*.o
+	ranlib $(DS_LIB)/libdarksusy.a
+
+libdarksusy.so : $(DOBJ)
+	 $(FF) $(FOPT) -shared $(BUILD)/*.o $(DS_LIB)/libFH.so $(DS_LIB)/libHB.so $(DS_LIB)/libisajet.so -o $(DS_LIB)/libdarksusy.so 
 
 $(DOBJ) : 
 	cd $(@:_obj=) ; make all
 
 .PHONY: clean distclean $(DOBJ)
 distclean : clean
-	rm $(LIB)/libdarksusy.a
+	rm $(DS_LIB)/libdarksusy.a
+	rm $(DS_LIB)/libdarksusy.so
 clean : 
 	rm -f $(BUILD)/*.o
 
diff -rupN darksusy-5.1.3/src/nt/dsntearthdens.f ../installed/darksusy/5.1.3/src/nt/dsntearthdens.f
--- darksusy-5.1.3/src/nt/dsntearthdens.f	2006-06-19 22:24:29.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/nt/dsntearthdens.f	2018-07-04 22:31:57.254485877 +0100
@@ -52,7 +52,7 @@ c      end
       include 'dsearth.h'
 
       real*8 r,dd,dpl
-      integer i,j
+      integer :: j = 0
 
       data eadepth/0.0d0,3.0d0,15.0d0,24.0d0,80.0d0,
      &  219.99d0,220.0d0,399.99d0,400.0d0,500.0d0,
diff -rupN darksusy-5.1.3/src/nt/dsntearthmass.f ../installed/darksusy/5.1.3/src/nt/dsntearthmass.f
--- darksusy-5.1.3/src/nt/dsntearthmass.f	2006-06-19 15:36:02.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/nt/dsntearthmass.f	2018-07-04 22:31:57.254485877 +0100
@@ -12,7 +12,7 @@
       implicit none
 
       real*8 radius(42),mass(42),rpl,r
-      integer i,j
+      integer :: j = 0
 
       data radius/0.0d0,7140.0d0,128140.0d0,378140.0d0,628140.0d0,
      &  878140.0d0,1128140.0d0,1228140.0d0,1228150.0d0,1378140.0d0,
diff -rupN darksusy-5.1.3/src/nt/dsntearthpot.f ../installed/darksusy/5.1.3/src/nt/dsntearthpot.f
--- darksusy-5.1.3/src/nt/dsntearthpot.f	2006-06-19 15:36:02.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/nt/dsntearthpot.f	2018-07-04 22:31:57.254485877 +0100
@@ -16,7 +16,8 @@
       real*8 radius(42),pot(42),ppl,r,gn,dsntearthmass,
      &  dsntearthpotint
       parameter(gn=6.67259d-11) ! m^3 kg^-1 s^-1
-      integer i,j
+      integer i
+      integer :: j = 0
 
       logical first
       data first/.true./
diff -rupN darksusy-5.1.3/src/nt/dsntmuonyield.f ../installed/darksusy/5.1.3/src/nt/dsntmuonyield.f
--- darksusy-5.1.3/src/nt/dsntmuonyield.f	2013-01-31 21:46:16.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/nt/dsntmuonyield.f	2018-07-04 22:31:57.258483878 +0100
@@ -78,21 +78,16 @@ c      call wirate(6,6,1)
          stop
       endif
          
-      waistat=0
-
       yield = 0.d0
       if (ptype.eq.1 .or. ptype.eq.3) then
         yield=dswayield(wamwimp,emu,theta,wh,kind,t1,istat)
-        waistat=or(waistat,istat)
       endif
 
       if (ptype.eq.2 .or. ptype.eq.3) then
         yield=yield+dswayield(wamwimp,emu,theta,wh,kind,t2,istat)
-        waistat=or(waistat,istat)
       endif
       
       dsntmuonyield=yield
-      istat=waistat
 
       end
 
diff -rupN darksusy-5.1.3/src/nt/dsntsuncdens.f ../installed/darksusy/5.1.3/src/nt/dsntsuncdens.f
--- darksusy-5.1.3/src/nt/dsntsuncdens.f	2006-06-19 22:30:05.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/nt/dsntsuncdens.f	2018-07-04 22:31:57.258483878 +0100
@@ -1,6 +1,6 @@
 ***********************************************************************
 *** This routine uses a derived column density from the BP2000 model
-*** The data in sdcens() is calculated by dsntsunread.f. 
+*** The data in sdcens() is calculated by dsntsunread.f.
 ***********************************************************************
 
 ***********************************************************************
@@ -22,12 +22,13 @@
       include 'dssun.h'
       real*8 r,rpl
       character*1 type
-      integer i,j,ti
+      integer :: j = 0
+      integer ti
 
 c...Check if data file is loaded
       call dsntsunread
 
-      if (type.eq.'N') then 
+      if (type.eq.'N') then
         ti=0
       elseif (type.eq.'p') then
         ti=1
diff -rupN darksusy-5.1.3/src/nt/dsntsundens.f ../installed/darksusy/5.1.3/src/nt/dsntsundens.f
--- darksusy-5.1.3/src/nt/dsntsundens.f	2006-06-19 22:24:29.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/nt/dsntsundens.f	2018-07-04 22:31:57.258483878 +0100
@@ -7,7 +7,7 @@
 *** ApJ 555 (2001) 990.
 *** The mass fractions for heavier elements are from N. Grevesse and
 *** A.J. Sauval, Space Science Reviews 85 (1998) 161 normalized such that
-*** their total mass fractions matches that of the heavier elements in 
+*** their total mass fractions matches that of the heavier elements in
 *** the BP2000 model.
 ***
 *** Author: Joakim Edsjo, edsjo@physto.se
@@ -19,7 +19,7 @@
 
       include 'dssun.h'
       real*8 r,rpl
-      integer i,j
+      integer :: j = 0
 
 c...Check if data file is loaded
       call dsntsunread
@@ -37,7 +37,7 @@ c...Check if data file is loaded
 
       call dshunt(sdr,sdn,r/r_sun,j)
       if (j.lt.sdn) goto 20
-      
+
       dsntsundens=0.0d0
       return
 
diff -rupN darksusy-5.1.3/src/nt/dsntsunmass.f ../installed/darksusy/5.1.3/src/nt/dsntsunmass.f
--- darksusy-5.1.3/src/nt/dsntsunmass.f	2006-06-19 15:36:02.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/nt/dsntsunmass.f	2018-07-04 22:31:57.258483878 +0100
@@ -7,7 +7,7 @@
 *** ApJ 555 (2001) 990.
 *** The mass fractions for heavier elements are from N. Grevesse and
 *** A.J. Sauval, Space Science Reviews 85 (1998) 161 normalized such that
-*** their total mass fractions matches that of the heavier elements in 
+*** their total mass fractions matches that of the heavier elements in
 *** the BP2000 model.
 ***
 *** Author: Joakim Edsjo, edsjo@physto.se
@@ -19,7 +19,7 @@
 
       include 'dssun.h'
       real*8 r,rpl
-      integer i,j
+      integer :: j = 0
 
 c...Check if data file is loaded
       call dsntsunread
diff -rupN darksusy-5.1.3/src/nt/dsntsunmfrac.f ../installed/darksusy/5.1.3/src/nt/dsntsunmfrac.f
--- darksusy-5.1.3/src/nt/dsntsunmfrac.f	2006-06-19 15:36:02.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/nt/dsntsunmfrac.f	2018-07-04 22:31:57.258483878 +0100
@@ -8,7 +8,7 @@
 *** ApJ 555 (2001) 990.
 *** The mass fractions for heavier elements are from N. Grevesse and
 *** A.J. Sauval, Space Science Reviews 85 (1998) 161 normalized such that
-*** their total mass fractions matches that of the heavier elements in 
+*** their total mass fractions matches that of the heavier elements in
 *** the BP2000 model.
 ***
 *** Author: Joakim Edsjo, edsjo@physto.se
@@ -20,7 +20,8 @@
 
       include 'dssun.h'
       real*8 r,rpl
-      integer i,j,itype
+      integer :: j = 0
+      integer itype
 
 c...Check if data file is loaded
       call dsntsunread
diff -rupN darksusy-5.1.3/src/nt/dsntsunne2x.f ../installed/darksusy/5.1.3/src/nt/dsntsunne2x.f
--- darksusy-5.1.3/src/nt/dsntsunne2x.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/nt/dsntsunne2x.f	2018-07-04 22:31:57.258483878 +0100
@@ -15,7 +15,7 @@
       include 'dsmpconst.h'
 
       real*8 ne,nepl,lne
-      integer j
+      integer :: j = 0
 
 c...Check if data file is loaded
       call dsntsunread
@@ -33,7 +33,7 @@ c...Check if data file is loaded
 
       call dshunt(sdne,sdnne,lne,j)
       if (j.lt.sdnne) goto 20
-      
+
       dsntsunne2x=0.0d0
       return
 
diff -rupN darksusy-5.1.3/src/nt/dsntsunne.f ../installed/darksusy/5.1.3/src/nt/dsntsunne.f
--- darksusy-5.1.3/src/nt/dsntsunne.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/nt/dsntsunne.f	2018-07-04 22:31:57.258483878 +0100
@@ -15,7 +15,7 @@
       include 'dsmpconst.h'
 
       real*8 r,rpl
-      integer j
+      integer :: j = 0
 
 c...Check if data file is loaded
       call dsntsunread
@@ -32,7 +32,7 @@ c...Check if data file is loaded
 
       call dshunt(sdrne,sdnne,r/r_sun,j)
       if (j.lt.sdnne) goto 20
-      
+
       dsntsunne=0.0d0
       return
 
diff -rupN darksusy-5.1.3/src/nt/dsntsunpot.f ../installed/darksusy/5.1.3/src/nt/dsntsunpot.f
--- darksusy-5.1.3/src/nt/dsntsunpot.f	2006-06-19 15:36:02.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/nt/dsntsunpot.f	2018-07-04 22:31:57.258483878 +0100
@@ -1,6 +1,6 @@
 ***********************************************************************
 *** This routine uses a derived potential from the BP2000 model
-*** The data in sdphi() is calculated by dsntsunread.f. 
+*** The data in sdphi() is calculated by dsntsunread.f.
 ***********************************************************************
 
 ***********************************************************************
@@ -12,7 +12,7 @@
 *** ApJ 555 (2001) 990.
 *** The mass fractions for heavier elements are from N. Grevesse and
 *** A.J. Sauval, Space Science Reviews 85 (1998) 161 normalized such that
-*** their total mass fractions matches that of the heavier elements in 
+*** their total mass fractions matches that of the heavier elements in
 *** the BP2000 model.
 ***
 *** Author: Joakim Edsjo, edsjo@physto.se
@@ -24,7 +24,7 @@
 
       include 'dssun.h'
       real*8 r,rpl,gn
-      integer i,j
+      integer :: j = 0
       parameter(gn=6.67259d-11) ! m^3 kg^-1 s^-1
 
 c...Check if data file is loaded
diff -rupN darksusy-5.1.3/src/nt/dsntsunx2z.f ../installed/darksusy/5.1.3/src/nt/dsntsunx2z.f
--- darksusy-5.1.3/src/nt/dsntsunx2z.f	2006-06-19 22:30:05.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/nt/dsntsunx2z.f	2018-07-04 22:31:57.258483878 +0100
@@ -29,12 +29,12 @@
       include 'dssun.h'
       real*8 x,rpl,dsntsuncdens
       character*1 type
-      integer i,j,ti
+      integer ti
 
 c...Check if data file is loaded
       call dsntsunread
 
-      if (type.eq.'N') then 
+      if (type.eq.'N') then
         ti=0
       elseif (type.eq.'p') then
         ti=1
diff -rupN darksusy-5.1.3/src/nt/dsntsunz2x.f ../installed/darksusy/5.1.3/src/nt/dsntsunz2x.f
--- darksusy-5.1.3/src/nt/dsntsunz2x.f	2006-06-19 22:30:05.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/nt/dsntsunz2x.f	2018-07-04 22:31:57.258483878 +0100
@@ -7,7 +7,7 @@
 ***        the column density is either of p or n or the total
 ***        and the totals are stored in cd_sun
 ***
-*** This routine converts from z (in p, n or total) to x 
+*** This routine converts from z (in p, n or total) to x
 ***
 *** Inputs
 ***       z =  = fraction of total column density (for chosen type) that
@@ -30,12 +30,13 @@
       include 'dssun.h'
       real*8 z,zpl,dsntsuncdens
       character*1 type
-      integer i,j,ti
+      integer :: j = 0
+      integer ti
 
 c...Check if data file is loaded
       call dsntsunread
 
-      if (type.eq.'N') then 
+      if (type.eq.'N') then
         ti=0
       elseif (type.eq.'p') then
         ti=1
@@ -59,7 +60,7 @@ c...Interpolate in table
  20   zpl=(z*cd_sun(ti)-sdcdens(j,ti))
      &  /(sdcdens(j+1,ti)-sdcdens(j,ti))
 
-      
+
       dsntsunz2x=sdr(j)*(1.0d0-zpl)+sdr(j+1)*zpl
       return
 
diff -rupN darksusy-5.1.3/src/rd/dsrdaddpt.f ../installed/darksusy/5.1.3/src/rd/dsrdaddpt.f
--- darksusy-5.1.3/src/rd/dsrdaddpt.f	2008-09-09 20:51:09.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/rd/dsrdaddpt.f	2018-07-04 22:31:57.258483878 +0100
@@ -1,10 +1,12 @@
-      subroutine dsrdaddpt(wrate,pres,deltap)
+      subroutine dsrdaddpt(wrate,pres,deltap,deltapminr)
 c_______________________________________________________________________
 c  add a point in rdrate table
 c  input:
 c    wrate - invariant annihilation rate (real, external)
 c    pres - momentum of the point to add
 c    deltap - scaling factor used in dsrdtab
+c    deltapminr - minimum delta p between existing point and new point
+c                 (in units of WIMP mass) for it to be added      
 c    pmax - maximum p used in dsrdtab (from common block)
 c  common:
 c    'dsrdcom.h' - included common blocks
@@ -18,8 +20,21 @@ c=======================================
       external wrate
       integer i,j
       real*8 pres,deltap
+      real*8 deltapminr
       logical pexist
 c-----------------------------------------------------------------------
+
+c...Check if we have exceeded time constraint
+      call CPU_TIME(rdt_end)
+      if ((rdt_end-rdt_start).gt.rdt_max) then
+         rderr=ibset(rderr,10)
+         write(*,*) 'DS ERROR in dsrdaddpt: time limit exceeded.'
+         write(*,*) '  Time spent: ',rdt_end-rdt_start,' seconds'
+         write(*,*) '  Maximum allowed time: ',rdt_max,' seconds'
+         write(*,*) '  omega calculation stopping.'
+         return
+      endif
+
       if (pres.le.0.0d0) return
 c...check if p already exists [serious bug corrected pg 01-01-31]
 c...Floating Point exception bug fixed 2008-09-09 JE
@@ -28,7 +43,9 @@ c...Floating Point exception bug fixed 2
          if (pp(i).eq.0.d0.and.pres.eq.0.d0) then
             pexist=.true.
          else if
-     &     (abs((pp(i)-pres/deltap)/max(pp(i),1.d-9)).lt.1.d-9) then
+c     &     (abs((pp(i)-pres/deltap)/max(pp(i),1.d-9)).lt.1.d-9) then
+c     &     (abs((pp(i)-pres/deltap)/max(pp(i),dpminr)).lt.dpminr) then
+     &           (abs(pp(i)-pres/deltap).lt.deltapminr) then ! JE TMP, OK?
             pexist=.true.
          endif
       enddo
diff -rupN darksusy-5.1.3/src/rd/dsrdcom.f ../installed/darksusy/5.1.3/src/rd/dsrdcom.f
--- darksusy-5.1.3/src/rd/dsrdcom.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/rd/dsrdcom.f	2018-07-04 22:31:57.258483878 +0100
@@ -14,5 +14,12 @@ c...0.996195d0 - 5 degrees, 0.999048d0 -
       data pdivr,dpres/2.0d0,0.5d0/
       data nlow,nhigh,npres,nthup,cthtest,spltest
      &  /20,10,4,4,0,1/
+c...rdt_max is the maximum time (in seconds) to spend on the relic density
+c...calculation. It is checked against before a new point is added to the
+c...W_eff tabulation, so in reality it can spend a bit longer than the limit.
+c...The time is evaluated with the function CPU_TIME meaning that it is the
+c...total CPU_TIME (not wall time) that is used. E.g. if four cores are used
+c...the CPU time is four times the wall time.      
+      data rdt_max/1.0d30/ ! max time for RD calculation (seconds)
       end
 
diff -rupN darksusy-5.1.3/src/rd/dsrdens.f ../installed/darksusy/5.1.3/src/rd/dsrdens.f
--- darksusy-5.1.3/src/rd/dsrdens.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/rd/dsrdens.f	2018-07-04 22:31:57.258483878 +0100
@@ -1,5 +1,5 @@
       subroutine dsrdens(wrate,npart,kpart,mgev,dof,nrs,rm,rw,
-     &  nt,tm,oh2,tf,ierr,iwar)
+     &  nt,tm,oh2,tf,fast,ierr,iwar)
 c_______________________________________________________________________
 c  present density in units of the critical density times the
 c    hubble constant squared.
@@ -15,6 +15,7 @@ c    rw    - width of resonances in gev
 c    nt    - number of thresholds to take special care of
 c            do not include coannihilation thresholds (that's automatic)
 c    tm    - sqrt(s) of the thresholds in gev
+c    fast - see meaning of options (1 or 2) in dsrdomega header
 c  output:
 c    oh2   - relic density parameter times h**2 (real*8)
 c    tf    - freeze-out temperature in gev (real*8)
@@ -29,6 +30,8 @@ c          6 (64) = step size smaller th
 c          7 (128) = too many steps in dsrdqrkck
 c          8 (256) = gpindp integration failed in dsrdthav
 c          9 (512) = threshold array too small. increase tharsi in dsrdcom.h
+c         10 (1024) = calculation took longer than max time in rdt_max,
+c                     calculation aborted
 c    iwar  - warning code (integer)
 c      bit 0 (1) = a difference of >5waccd in the ratio of w_spline
 c                  and w_linear is obtained due to delta_p<dpmin.
@@ -53,6 +56,7 @@ c=======================================
       real*8 wrate,dsrdwintp,mgev(npart),dof(npart),oh2,
      &   xstart,xend,yend,rm(nrs),rw(nrs),tm(nt),xf,tf
       integer kpart(npart)
+      integer fast
       external wrate,dsrdwintp
       integer k
       real*8 tstart
@@ -71,7 +75,7 @@ c---------------------------------------
       endif
 
 c      write(*,*) 'dsrdens: npart=',npart
-      
+
       call dsrdstart(npart,kpart,mgev,dof,nrs,rm,rw,nt,tm)
 
       if (rderr.ne.0) goto 999
@@ -98,7 +102,7 @@ c---------------------------------------
 
 c------------------------------------------- tabulate the invariant rate
 
-      call dsrdtab(wrate,xstart)
+      call dsrdtab(wrate,xstart,fast)
       if (rderr.ne.0) goto 999
 
 c------------------------------------------ determine integration limits
diff -rupN darksusy-5.1.3/src/rd/dsrdspline.f ../installed/darksusy/5.1.3/src/rd/dsrdspline.f
--- darksusy-5.1.3/src/rd/dsrdspline.f	2013-01-31 21:46:16.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/rd/dsrdspline.f	2018-07-04 22:31:57.262481877 +0100
@@ -57,7 +57,8 @@ c...jump out of loop
    11 continue
 
       if (iend.ne.nr) then
-        istart=iend+1 ! skip one point
+         istart=iend+1          ! skip one point
+         if ((nr-istart).le.1) return ! can't loop at 10 with only one point left
         goto 10
       endif
 
diff -rupN darksusy-5.1.3/src/rd/dsrdtab.f ../installed/darksusy/5.1.3/src/rd/dsrdtab.f
--- darksusy-5.1.3/src/rd/dsrdtab.f	2010-08-06 09:27:44.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/rd/dsrdtab.f	2018-07-04 22:31:57.262481877 +0100
@@ -1,9 +1,12 @@
-      subroutine dsrdtab(wrate,xmin)
+      subroutine dsrdtab(wrate,xmin,fast)
 c_______________________________________________________________________
 c  tabulate the invariant annihilation rate as a function of p.
 c  input:
 c    wrate - invariant annihilation rate (real*8, external)
 c    xmin - minimum mass/temperature needed (real*8)
+c    fast - options for fast tabulation (see dsrdomega header)
+c  output (hidden):
+c    rderr - error flag in common block
 c  common:
 c    'dsrdcom.h' - included common blocks
 c  uses dsrdnormlz, dsrdlny, dsrdspline.
@@ -14,14 +17,16 @@ c=======================================
       include 'dsrdcom.h'
       real*8 wrate,xmin,p
       external wrate
-      integer i,j,k,nadd
+      integer i,j,k,nadd,nrtmp,fast
       real*8 pmin,dp,dp1,dp2,x1,x2,dy1,dy2,y1,y2,
      & ymin,ymax,deltap,deltay,dsrdlny,pres,dpth,pthlow,
      & wspline,wlin,wrmax,wrmin,pwmax,pwmin,p2,
      & dpmin,dpthmin,pp1,pp2,w1,w2,w3,padd(nrmax),dsrdthclose,
-     & pthr,dsrddpmin
+     & pthr,dsrddpmin,ptmp,dpr
       real*8 c(nrmax)
 
+      call CPU_TIME(rdt_start) ! save start time of calculation
+
 cc      write (*,*) 'Entering dsrdtab'
 cc      write (*,*) 'nth=',nth
 
@@ -47,7 +52,7 @@ c========================= first tabulat
 cc      write (*,*) 'dsrdtab: start first tabulation'
 
       pmin=0.d0
-      if (wrate(0.d0).eq.0.d0) pmin=1.d-10*mco(1)
+      if (wrate(0.d0).eq.0.d0) pmin=1.d-6*mco(1)
 
       pmax=mco(1)*umax*sqrt((1.0d0+0.25d0*umax**2/xmin)/xmin)
 c...Avoid too high momenta, these are not needed except at
@@ -71,6 +76,11 @@ c...first sample low p region dense, je
 cc      write (*,*) 'dsrdtab: start low p region'
       dp=(pdivr*mco(1)-pmin)/deltap/(dble(nlow)-1.0d0)  ! je test
       do i=2,nlow
+         call CPU_TIME(rdt_end)
+         if ((rdt_end-rdt_start).gt.rdt_max) then
+            rderr=ibset(rderr,10)
+            goto 999
+         endif
         indx(i)=i
         pp(i)=pp(1)+dble(i-1)*dp
         yy(i)=dsrdlny(pp(i)*deltap,wrate)
@@ -80,6 +90,11 @@ c...then sample high p region sparse
 cc      write (*,*) 'dsrdtab: start high p region'
       dp=(pmax-pdivr*mco(1))/deltap/(dble(nhigh))  ! je test
       do i=nlow+1,nlow+nhigh
+         call CPU_TIME(rdt_end)
+         if ((rdt_end-rdt_start).gt.rdt_max) then
+            rderr=ibset(rderr,10)
+            goto 999
+         endif
         indx(i)=i
         pp(i)=pp(nlow)+dble(i-nlow)*dp
         yy(i)=dsrdlny(pp(i)*deltap,wrate)
@@ -87,7 +102,7 @@ cc      write (*,*) 'dsrdtab: start high
       nr=nlow+nhigh
 
 
-c------------------- add one point close to p=0 to insure correct point
+c------------------- add one point close to p=0 to ensure correct point
 c----------------------------- insertion at low p, je addition 96-04-09
 c
 c      call dsrdaddpt(wrate,pmin+dpmin*deltap,deltap)
@@ -100,12 +115,22 @@ cc      write (*,*) 'dsrdtab: start reso
       if (i.le.nres) then
  7      pres=sqrt(rgev(i)**2/4.0d0-mco(1)**2)
         if (pres.lt.pmax) then
+c...dpr is the momentum difference between resonance and resonance+1*width
+c...divided by a factor to be used as minimum momentum difference for
+c...dsrdaddpt
+           if (fast.eq.1) then
+              dpr=1.d-9
+           else ! more restrictive on which points to add for fast>1
+              dpr=(sqrt((rgev(i)+dpres*rwid(i))**2/4.d0-mco(1)**2) -
+     &             sqrt((rgev(i))**2/4.d0-mco(1)**2))/10.d0 ! last 10 is a fudge factor
+              dpr=dpr/mco(1)    ! should be relative
+           endif
 c...first check if important
           j=-npres
           p2=(rgev(i)+dpres*dble(j)*rwid(i))**2/4.0d0-mco(1)**2
           if (p2.gt.0.0d0) then
             pres=sqrt(p2)
-            call dsrdaddpt(wrate,pres,deltap)
+            call dsrdaddpt(wrate,pres,deltap,dpr)
             if (rderr.ne.0) goto 999 ! return
             w1=exp(yy(nr))
           else
@@ -116,7 +141,7 @@ c...first check if important
           p2=(rgev(i)+dpres*dble(j)*rwid(i))**2/4.0d0-mco(1)**2
           if (p2.gt.0.0d0) then
             pres=sqrt(p2)
-            call dsrdaddpt(wrate,pres,deltap)
+            call dsrdaddpt(wrate,pres,deltap,dpr)
             if (rderr.ne.0) goto 999 ! return
             w3=exp(yy(nr))
           else
@@ -127,7 +152,7 @@ c...first check if important
           p2=(rgev(i)+dpres*dble(j)*rwid(i))**2/4.0d0-mco(1)**2
           if (p2.gt.0.0d0) then
             pres=sqrt(p2)
-            call dsrdaddpt(wrate,pres,deltap)
+            call dsrdaddpt(wrate,pres,deltap,1.d-9) ! 1.d-9 to always add this pt
             if (rderr.ne.0) goto 999 ! return
             w2=exp(yy(nr))
           else
@@ -148,7 +173,7 @@ c...first check if important
                 p2=(rgev(i)+dpres*dble(j)*rwid(i))**2/4.0d0-mco(1)**2
                 if (p2.gt.0.0d0) then
                   pres=sqrt(p2)
-                  call dsrdaddpt(wrate,pres,deltap)
+                  call dsrdaddpt(wrate,pres,deltap,dpr)
                   if (rderr.ne.0) goto 999 ! return
                 endif
               endif
@@ -165,12 +190,19 @@ cc      write (*,*) 'dsrdtab: start thre
       if (i.le.nth) then
  17     if (pth(i).lt.pthlow) pthlow=pth(i)
         if (pth(i).lt.pmax) then
-          call dsrdaddpt(wrate,pth(i)-dpth,deltap) ! je test
-          if (rderr.ne.0) goto 999 ! return 
+          call dsrdaddpt(wrate,pth(i)-dpth,deltap,dpminr) ! je test
+          if (rderr.ne.0) goto 999 ! return
           w1=exp(yy(nr))
           do j=nthup,1,-1
-            call dsrdaddpt(wrate,pth(i)+dble(j)**2*dpth,deltap)
-            if (rderr.ne.0) goto 999 ! return 
+            ptmp=pth(i)+dble(j)**2*dpth
+            if (fast.ge.2.and.i.lt.nth) then ! check if overlapping thresholds
+               if (j.gt.1.and.ptmp.ge.pth(i+1)) goto 18 ! overlapping thr
+               if (j.eq.1.and.ptmp.ge.pth(i+1)) then
+                  ptmp=(pth(i)+pth(i+1))/2.d0
+               endif
+            endif
+            call dsrdaddpt(wrate,pth(i)+dble(j)**2*dpth,deltap,dpminr)
+            if (rderr.ne.0) goto 999 ! return
             w2=exp(yy(nr))
             if (j.eq.nthup.and.(w2-w1)/w1.lt.wdifft) then ! unimportant thr.
                incth(i)=0
@@ -182,6 +214,7 @@ c              enddo
 c              nth=nth-1
 c              if (i.le.nth) goto 17
             endif
+ 18         continue
           enddo
         endif
         goto 16
@@ -190,8 +223,8 @@ c              if (i.le.nth) goto 17
 c------------------------------------- add points below lowest threshold
       if (nth.ge.1) then
         do i=1,3
-          call dsrdaddpt(wrate,pthlow*dble(i)/4.0d0,deltap)
-          if (rderr.ne.0) goto 999 ! return 
+          call dsrdaddpt(wrate,pthlow*dble(i)/4.0d0,deltap,dpminr)
+          if (rderr.ne.0) goto 999 ! return
         enddo
       endif
 
@@ -325,6 +358,7 @@ c=======================================
 
 cc      write (*,*) 'dsrdtab: start spline setup'
  25   call dsrdspline
+c      write(*,*) 'dsrdspline called...'
 
 c-------------------------------------- check cubic spline interpolation
 c...addition by je 96-04-09
@@ -362,17 +396,19 @@ c          endif
 
         if (nadd.ge.1) then
 cc          write(*,*) 'now adding ',nadd,' points to nr = ',nr
+          nrtmp=nr
           do i=1,nr
             pp(i)=pp(i)/deltap
           enddo
           do i=1,nadd
-            call dsrdaddpt(wrate,padd(i),deltap)
-            if (rderr.ne.0) goto 999 ! return 
+            call dsrdaddpt(wrate,padd(i),deltap,dpminr)
+            if (rderr.ne.0) goto 999 ! return
           enddo
           do i=1,nr
             pp(i)=pp(i)*deltap
           enddo
           if (rderr.ne.0) goto 999 ! return
+          if (nr.eq.nrtmp) goto 500 ! no points added du to dpmin, go finalizing
           goto 25
         endif
 
@@ -394,10 +430,11 @@ c      endif
 
 c...check how bad we are doing when delta_p < dpmin
 
+ 500    continue
         wrmax=1.0d0
         wrmin=1.0d0
 
-cc        write (*,*) 'dsrdtab: ..... second loop'        
+cc        write (*,*) 'dsrdtab: ..... second loop'
         do i=1,nr-1
           pp1=pp(indx(i))
           pp2=pp(indx(i+1))
diff -rupN darksusy-5.1.3/src/rn/dsrdomega.f ../installed/darksusy/5.1.3/src/rn/dsrdomega.f
--- darksusy-5.1.3/src/rn/dsrdomega.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/rn/dsrdomega.f	2018-07-04 22:31:57.262481877 +0100
@@ -12,11 +12,25 @@
 ***            3 - include only coannihilations between sfermions
 ***                and the lightest neutralino
 ***   fast =   0 - standard accurate calculation (accuracy better than 1%)
-***            1 - faster calculation: (recommended unless extreme accuracy
-***                is needed).
-***                * requires less accuracy in tabulation of w_eff
-***            2 - quick and dirty method, i.e. expand the annihilation
+***            1 - faster calculation: sets parameters for when to add
+***                extra points less tough to avoid excessively
+***                adding extra points, expected accurarcy: 1% or better      
+***            2 - faster calculation: compared to fast=1, this option
+***                adds less points in Weff tabulation in general and      
+***                is more elaborate in deciding when to include points
+***                close to thresholds and resonances
+***                expected accuracy: around 1%      
+***            3 - even more aggressive on trying minimize the number
+***                of tabulated points
+***                expected accuracy: 5-10%      
+***            9 - superfast. This method still makes sure to include
+***                resonances and threholds, but does not attempt to sample
+***                them very well. Should give an order of magnitude estimate
+***                expected accuracy: order of magnitude      
+***           10 - quick and dirty method, i.e. expand the annihilation
 ***                cross section in x (not recommended)
+***                expected accuracy: can be orders of magnitude wrong
+***                for models with strong resonances or thresholds      
 *** output:
 ***   dsrdomega - omega h^2 for the neutralino
 ***   xf = m_WIMP / T_f where T_f is the freeze-out temperature
@@ -84,22 +98,59 @@ c...temporarily change width of h1 higgs
          first=.false.
       endif
 
-      if (fast.eq.1) then       ! fast calculation
+      if (fast.eq.1) then       ! fast=1 calculation
 c         dwopt=.true.
          waccd=0.05d0
-         dpminr=5.0d-4
+         dpminr=5d-4
          dpthr=2.5d-3
          wdiffr=0.5d0
          wdifft=0.1d0
          mcofr=1.5d0
 c         brmin=1.0d-4           ! 1.0d-3 doesn't make a big speed difference
+      elseif (fast.eq.2) then       ! fast=2 calculation
+c         dwopt=.true.
+         waccd=0.05d0
+         dpminr=1d-3
+         dpthr=2.5d-3
+         wdiffr=0.5d0
+         wdifft=0.1d0
+         mcofr=1.5d0
+c         brmin=1.0d-4           ! 1.0d-3 doesn't make a big speed difference
+      elseif (fast.eq.3) then       ! fast=3 calculation
+c         dwopt=.true.
+         waccd=0.05d0
+         dpminr=2d-3
+         dpthr=2.5d-3
+         wdiffr=0.5d0
+         wdifft=0.1d0
+         nlow=20
+         nhigh=10
+         npres=3
+         nthup=3
+         umax=10.d0
+         mcofr=1.5d0
+c         brmin=1.0d-4           ! 1.0d-3 doesn't make a big speed difference
+      elseif (fast.eq.9) then       ! fast=9 calculation
+c         dwopt=.true.
+         waccd=0.2d0
+         dpminr=1.0d-2
+         dpthr=2.5d-3
+         wdiffr=0.5d0
+         wdifft=0.1d0
+         nlow=10
+         nhigh=3
+         npres=1
+         dpres=0.85d0
+         nthup=2
+         umax=5.d0
+c         brmin=1.0d-4           ! 1.0d-3 doesn't make a big speed difference
       else
          mcofr=2.1d0
       endif
 
       if (fast.eq.0.and.fastsav.eq.1) then
          write (*,*) 'error in dsrdomega:',
-     &    ' can''t go back to fast=0 when fast=1 had been used.'
+     &    ' can''t go back to fast=0 when fast>=1 had been used.'
 c        write(*,*) 'rewrite dsrdomega if this is desired.'
          stop
       endif
@@ -274,11 +325,11 @@ c...dsrdstart (called from dsrdens).
 
       rdtag=idtag
 
-      if (fast.eq.0.or.fast.eq.1) then  ! standard accurate method
+      if (fast.ge.0.and.fast.le.9) then  ! standard accurate method
          call dsrdens(dsanwx,ncoann,kpart,mcoann,dof,nres,rm,rw,
-     &     nthr,tm,oh2,tf,ierr,iwar)
+     &     nthr,tm,oh2,tf,fast,ierr,iwar)
          nfc=nr
-      elseif (fast.eq.2) then   ! quick and dirty method
+      elseif (fast.eq.10) then   ! quick and dirty method
          call dsrdqad(dsanwx,mcoann(1),oh2,ierr)
          iwar=0
          nfc=2
diff -rupN darksusy-5.1.3/src/slha/dsfromslha.F ../installed/darksusy/5.1.3/src/slha/dsfromslha.F
--- darksusy-5.1.3/src/slha/dsfromslha.F	2013-01-31 21:46:16.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/slha/dsfromslha.F	2018-07-04 22:31:57.262481877 +0100
@@ -8,6 +8,7 @@
 ***         More options on how to treat redundant information, e.g.
 ***         should Yukawas from SLHA file be used instead of letting
 ***         DarkSUSY run them (as is currently done).
+*** Modified: 2016-11-11 Joakim Edsjo, fixed lsp setting      
 **********************************************************************
       subroutine dsfromSLHA
       implicit none
@@ -465,6 +466,12 @@ c...Block VMIX - V matrix for chargino m
          enddo
       enddo
 
+c...JE CORR 161111, make sue we set lsp correctly with SLHA read masses
+      lsp = kn(kln)
+      do i=21,48
+         if (abs(mass(i)).lt.abs(mass(lsp))) lsp = i
+      enddo
+      
 c...BLOCK alpha
       call dssetfromslha(Alpha_Alpha,alpha,0,'')
 
@@ -768,6 +775,7 @@ c...are added. In particular, we need to
 c...widths. In the future, we should read these from the SLHA file instead
 c...and only calculate here if they are not present in the file.
 
+      call dsorder_flavour ! Order flavours, still needed for IB routines
       call dsvertx
       call dshigwid
       call dsspwid
@@ -775,4 +783,3 @@ c...and only calculate here if they are
 
       return
       end
-
diff -rupN darksusy-5.1.3/src/su/dsorder_flavour.f ../installed/darksusy/5.1.3/src/su/dsorder_flavour.f
--- darksusy-5.1.3/src/su/dsorder_flavour.f	1970-01-01 01:00:00.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/su/dsorder_flavour.f	2018-07-04 22:31:57.262481877 +0100
@@ -0,0 +1,277 @@
+*******************************************************************************
+*** This routine orders all sfermions according to flavour. For sleptons,   ***
+*** e.g. this implies the following for the internal particle code ksl:     ***
+***                                                                         ***
+***       ksl(1) = kse(1) = lightest selectron-like sfermion                ***
+***       ksl(2) = ksmu(1) = lightest smuon-like sfermion                   ***
+***       ksl(3) = kstau(1) = lightest stau-like sfermion                   ***
+***       ksl(4) = kse(2) = heavier selectron-like sfermion                 ***
+***       ksl(5) = ksmu(2) = heavier smuon-like sfermion                    ***
+***       ksl(6) = kstau(2) = heavier stau-like sfermion                    ***
+***                                                                         ***
+*** Here, the two "most selectron-like" particles are defined as those that ***
+*** mix strongest with the light- and right-handed selectron, respectively. ***
+*** For squarks, the analogous applies, while for sneutrinos only the first ***
+*** 3 entries in the above table exist.                                     ***
+***                                                                         ***
+***       output: translation from new to old channel numbers (1..6) is     ***                                                                  
+***               stored in common block variables flavsortsl etc.        ***
+***                                                                         ***
+*** NB: This routine assumes that both the mixing and mass common blocks    ***
+***     have already been set, but it must be called ONCE, *before*         ***
+***     initializing the vertex rules.                                      ***
+***                                                                         ***
+*** date:   2016-11-15                                                      ***
+*** author: torsten.bringmannl@fys.uio.no,                                  ***
+*******************************************************************************
+
+      subroutine dsorder_flavour
+      implicit none
+
+      include 'dsmssm.h'
+      
+      integer i, j, ktmp, kflav(6)
+      real*8 masstmp(6), mixtmpl(6,3), mixtmpr(6,3)
+
+c...FIXME. If the re-order arrays are to be used, this routine should only
+c...be called once for each model. This is currently not checked for. The
+c...reordering will work even if the routine is called many times, but the
+c...reordering arrays will be meaningless if the routine is called many times.
+      
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+ccc re-order down-type sleptons as i -> kflav(i)
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+      do i=1,6
+        kflav(i)=1
+      enddo  
+
+      do i=2,6                                                        ! find the slepton that
+        if (abs(sldlmx(i,1)).gt.abs(sldlmx(kflav(1),1))) kflav(1) = i ! looks most like a left-
+      enddo                                                           ! handed selectron
+      do i=2,6                                               
+        if ((i.ne.kflav(1)).and.                           ! find the (remaining!) slepton 
+     &      (abs(sldrmx(i,1)).gt.abs(sldrmx(kflav(4),1)))) ! that looks most like a right- 
+     &      kflav(4) = i                                   ! handed selectron
+      enddo                                                          
+
+      do i=2,6 ! now repeat this for smuons
+        if ((i.ne.kflav(1).and.i.ne.kflav(4)).and.                         
+     &     (abs(sldlmx(i,2)).gt.abs(sldlmx(kflav(2),2)))) kflav(2) = i 
+      enddo                                                           
+      do i=2,6                                               
+        if ((i.ne.kflav(1).and.i.ne.kflav(4).and.i.ne.kflav(2)).and.                            
+     &      (abs(sldrmx(i,2)).gt.abs(sldrmx(kflav(5),2)))) kflav(5) = i                                   
+      enddo                                                          
+
+      i=0 ! the remaining ones must be stau-like... 
+ 10   i = i+1
+      if (i.eq.kflav(1).or.i.eq.kflav(2).or.i.eq.kflav(4).or.
+     &      i.eq.kflav(5)) goto 10
+      kflav(3) = i
+ 20   i = i+1
+      if (i.eq.kflav(1).or.i.eq.kflav(2).or.i.eq.kflav(3).or.
+     &      i.eq.kflav(4).or.i.eq.kflav(5)) goto 20 
+      kflav(6) = i     
+
+      do i=1,3 ! change mass order if necessary
+        if (mass(ksl(kflav(i+3))).lt.mass(ksl(kflav(i)))) then 
+          ktmp = kflav(i)
+          kflav(i) = kflav(i+3)
+          kflav(i+3) = ktmp
+        endif
+      enddo
+
+c... we write this translation from old to new ordering to common blocks
+      do i=1,6
+        flavsortsl(i) = kflav(i)
+      enddo
+ 
+c... now we have to update the masses and mixing matrices to these new conventions:
+      do i=1,6
+        masstmp(i) = mass(ksl(i)) 
+        do j=1,3
+          mixtmpl(i,j) = sldlmx(i,j)
+          mixtmpr(i,j) = sldrmx(i,j)
+        enddo
+      enddo
+      do i=1,6         
+        mass(ksl(i)) = masstmp(kflav(i))
+        do j=1,3
+          sldlmx(i,j) = mixtmpl(kflav(i),j)
+          sldrmx(i,j) = mixtmpr(kflav(i),j)
+        enddo
+      enddo
+  
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+ccc re-order sneutrinos as i -> kflav(i)
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+      do i=1,3
+        kflav(i)=1
+      enddo  
+
+      do i=2,3 ! find the sneutrino that looks most like a snu_e
+        if (abs(slulmx(i,1)).gt.abs(slulmx(kflav(1),1))) kflav(1) = i
+      enddo  
+      do i=2,3 ! find the sneutrino that looks most like a snu_mu
+        if ((i.ne.kflav(1)).and.                         
+     &     (abs(slulmx(i,2)).gt.abs(slulmx(kflav(2),2)))) kflav(2) = i 
+      enddo                                                           
+      do i=2,3 ! find the sneutrino that looks most like a snu_tau 
+        if (i.ne.kflav(1).and.i.ne.kflav(2)) kflav(3) = i  
+      enddo
+c... we write this translation from old to new ordering to common blocks
+      do i=1,3
+        flavsortsnu(i) = kflav(i)
+      enddo
+c... now we have to update the masses and mixing matrices to these new conventions:
+      do i=1,3
+        masstmp(i) = mass(ksnu(i)) 
+        do j=1,3
+          mixtmpl(i,j) = slulmx(i,j)
+        enddo
+      enddo
+      do i=1,3         
+        mass(ksnu(i)) = masstmp(kflav(i))
+        do j=1,3
+          slulmx(i,j) = mixtmpl(kflav(i),j)
+        enddo
+      enddo
+
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+ccc re-order down-type squarks as i -> kflav(i)
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+      do i=1,6
+        kflav(i)=1
+      enddo  
+
+      do i=2,6                                                        ! find the squark that
+        if (abs(sqdlmx(i,1)).gt.abs(sqdlmx(kflav(1),1))) kflav(1) = i ! looks most like a left-
+      enddo                                                           ! handed down-squark
+      do i=2,6                                               
+        if ((i.ne.kflav(1)).and.                           ! find the (remaining!) squark 
+     &      (abs(sqdrmx(i,1)).gt.abs(sqdrmx(kflav(4),1)))) ! that looks most like a right- 
+     &      kflav(4) = i                                   ! handed down-squark
+      enddo                                                          
+
+      do i=2,6 ! now repeat this for s-strange
+        if ((i.ne.kflav(1).and.i.ne.kflav(4)).and.                         
+     &     (abs(sqdlmx(i,2)).gt.abs(sqdlmx(kflav(2),2)))) kflav(2) = i 
+      enddo                                                           
+      do i=2,6                                               
+        if ((i.ne.kflav(1).and.i.ne.kflav(4).and.i.ne.kflav(2)).and.                            
+     &      (abs(sqdrmx(i,2)).gt.abs(sqdrmx(kflav(5),2)))) kflav(5) = i                                   
+      enddo                                                          
+
+      i=0 ! the remaining ones must be sbottom-like...  
+ 30   i = i+1
+      if (i.eq.kflav(1).or.i.eq.kflav(2).or.i.eq.kflav(4).or.
+     &      i.eq.kflav(5)) goto 30
+      kflav(3) = i
+ 40   i = i+1
+      if (i.eq.kflav(1).or.i.eq.kflav(2).or.i.eq.kflav(3).or.
+     &      i.eq.kflav(4).or.i.eq.kflav(5)) goto 40 
+      kflav(6) = i     
+
+      do i=1,3 ! change mass order if necessary
+        if (mass(ksqd(kflav(i+3))).lt.mass(ksqd(kflav(i)))) then 
+          ktmp = kflav(i)
+          kflav(i) = kflav(i+3)
+          kflav(i+3) = ktmp
+        endif
+      enddo
+ 
+c... we write this translation from old to new ordering to common blocks
+      do i=1,6
+        flavsortsqd(i) = kflav(i)
+      enddo
+
+c... now we have to update the masses and mixing matrices to these new conventions:
+      do i=1,6
+        masstmp(i) = mass(ksqd(i)) 
+        do j=1,3
+          mixtmpl(i,j) = sqdlmx(i,j)
+          mixtmpr(i,j) = sqdrmx(i,j)
+        enddo
+      enddo
+      do i=1,6         
+        mass(ksqd(i)) = masstmp(kflav(i))
+        do j=1,3
+          sqdlmx(i,j) = mixtmpl(kflav(i),j)
+          sqdrmx(i,j) = mixtmpr(kflav(i),j)
+        enddo
+      enddo
+  
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+ccc re-order up-type squarks as i -> kflav(i)
+ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
+      do i=1,6
+        kflav(i)=1
+      enddo  
+
+      do i=2,6                                                        ! find the squark that
+        if (abs(squlmx(i,1)).gt.abs(squlmx(kflav(1),1))) kflav(1) = i ! looks most like a left-
+      enddo                                                           ! handed up-squark
+      do i=2,6                                               
+        if ((i.ne.kflav(1)).and.                           ! find the (remaining!) squark 
+     &      (abs(squrmx(i,1)).gt.abs(squrmx(kflav(4),1)))) ! that looks most like a right- 
+     &      kflav(4) = i                                   ! handed up-squark
+      enddo                                                          
+
+      do i=2,6 ! now repeat this for charm-squark
+        if ((i.ne.kflav(1).and.i.ne.kflav(4)).and.                         
+     &     (abs(squlmx(i,2)).gt.abs(squlmx(kflav(2),2)))) kflav(2) = i 
+      enddo                                                           
+      do i=2,6                                               
+        if ((i.ne.kflav(1).and.i.ne.kflav(4).and.i.ne.kflav(2)).and.                            
+     &      (abs(squrmx(i,2)).gt.abs(squrmx(kflav(5),2)))) kflav(5) = i                                   
+      enddo                                                          
+
+      i=0 ! the remaining ones must be stau-like...  
+ 50   i = i+1
+      if (i.eq.kflav(1).or.i.eq.kflav(2).or.i.eq.kflav(4).or.
+     &      i.eq.kflav(5)) goto 50
+      kflav(3) = i
+ 60   i = i+1
+      if (i.eq.kflav(1).or.i.eq.kflav(2).or.i.eq.kflav(3).or.
+     &      i.eq.kflav(4).or.i.eq.kflav(5)) goto 60 
+      kflav(6) = i     
+
+      do i=1,3 ! change mass order if necessary
+        if (mass(ksqu(kflav(i+3))).lt.mass(ksqu(kflav(i)))) then 
+          ktmp = kflav(i)
+          kflav(i) = kflav(i+3)
+          kflav(i+3) = ktmp
+        endif
+      enddo
+ 
+c... we write this translation from old to new ordering to common blocks
+      do i=1,6
+        flavsortsqu(i) = kflav(i)
+      enddo
+
+c... now we have to update the masses and mixing matrices to these new conventions:
+      do i=1,6
+        masstmp(i) = mass(ksqu(i)) 
+        do j=1,3
+          mixtmpl(i,j) = squlmx(i,j)
+          mixtmpr(i,j) = squrmx(i,j)
+        enddo
+      enddo
+      do i=1,6         
+        mass(ksqu(i)) = masstmp(kflav(i))
+        do j=1,3
+          squlmx(i,j) = mixtmpl(kflav(i),j)
+          squrmx(i,j) = mixtmpr(kflav(i),j)
+        enddo
+      enddo
+  
+
+      return
+      end
+
+
+
+
+
+        
+
diff -rupN darksusy-5.1.3/src/su/dssuconst_yukawa_running.f ../installed/darksusy/5.1.3/src/su/dssuconst_yukawa_running.f
--- darksusy-5.1.3/src/su/dssuconst_yukawa_running.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/su/dssuconst_yukawa_running.f	2018-07-04 22:31:57.262481877 +0100
@@ -20,6 +20,9 @@ c=======================================
       mscale=2.d0*mass(lsp)
       alph3=dsralph3(mscale)
       g3stro=sqrt(4.d0*pi*alph3)
+c      write(*,*) 'lsp = ',lsp
+c      write(*,*) 'mass(lsp) = ',mass(lsp)
+c      write(*,*) 'mscale=',mscale
 c      write(*,*) 'alpha3=',alph3,' alph3mz=',alph3mz
       aux = g2weak/dsqrt(2.d0)/mass(kw)
       yukawa(ktau)= aux*dsrmq(mscale,ktau)/cosbe
diff -rupN darksusy-5.1.3/src/su/dsvertx1.f ../installed/darksusy/5.1.3/src/su/dsvertx1.f
--- darksusy-5.1.3/src/su/dsvertx1.f	2011-11-04 23:48:05.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/su/dsvertx1.f	2018-07-04 22:31:57.262481877 +0100
@@ -616,11 +616,11 @@ c       neutrinos
           gjll=-(g2weak*neunmx(j,2)-gyweak*neunmx(j,1))/sqrt(2.0d0)
           do k=1,3
             gl(ksnu(k),kn(j),knu(g))=conjg(gjll)*slulmx(k,g)
-            gl(kn(j),ksnu(g),knu(g))=gl(ksnu(g),kn(j),knu(g))
-            gl(kn(j),knu(g),ksnu(g))=gl(ksnu(g),kn(j),knu(g))
+            gl(kn(j),ksnu(k),knu(g))=gl(ksnu(k),kn(j),knu(g)) !JE corr 161030
+            gl(kn(j),knu(g),ksnu(k))=gl(ksnu(k),kn(j),knu(g)) !JE corr 161030
             gr(ksnu(k),knu(g),kn(j))=conjg(gl(ksnu(k),kn(j),knu(g)))
-            gr(knu(g),ksnu(g),kn(j))=gr(ksnu(g),knu(g),kn(j))
-            gr(knu(g),kn(j),ksnu(g))=gr(ksnu(g),knu(g),kn(j))
+            gr(knu(g),ksnu(k),kn(j))=gr(ksnu(k),knu(g),kn(j)) !JE corr 161030
+            gr(knu(g),kn(j),ksnu(k))=gr(ksnu(k),knu(g),kn(j)) !JE corr 161030
           enddo
 
 c       charged leptons
diff -rupN darksusy-5.1.3/src/su/makefile.in ../installed/darksusy/5.1.3/src/su/makefile.in
--- darksusy-5.1.3/src/su/makefile.in	2013-01-31 21:46:16.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/su/makefile.in	2018-07-04 22:31:57.262481877 +0100
@@ -32,7 +32,7 @@ dsrmq4loop.f dssfesct.f dsspectrum.f dss
 dssuconst_ckm.f dssuconst_couplings.f dssuconst_higgs.f \
 dssuconst_yukawa.f dssuconst_yukawa_running.f dssusy.f dsvertx.f \
 dsvertx1.f dsvertx3.f dswhwarn.f dswspectrum.f dswunph.f dswvertx.f \
-dswwidth.f g4p.f dsgive_model25.f
+dswwidth.f g4p.f dsgive_model25.f dsorder_flavour.f
 
 OBJ = $(patsubst %.f,$(DOBJ)/%.o,$(SRC))
 
diff -rupN darksusy-5.1.3/src/ucmh/dspbh_limits.f ../installed/darksusy/5.1.3/src/ucmh/dspbh_limits.f
--- darksusy-5.1.3/src/ucmh/dspbh_limits.f	2015-04-05 02:53:52.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/ucmh/dspbh_limits.f	2018-07-04 22:31:57.262481877 +0100
@@ -8,15 +8,15 @@
 !Output:    betamax   maximum allowed value of beta
 
       double precision function dspbh_limits(k)
-      
+
       implicit none
 
       include 'dsucmh.h'
       include 'dsmpconst.h'
- 
+
       double precision :: k, logM
-      double precision, parameter :: const = 1.d0/(3.**3*2.) 
-      integer :: lowerindx
+      double precision, parameter :: const = 1.d0/(3.**3*2.)
+      integer :: lowerindx = 0
 
       logM = log10(sqrt(const) * (keq/k)**2 * (106.75/3.36)**0.5 * (106.75/3.91)**(-2./3.) * Mhzeq * SolarMass)
       if (logM .lt. minval(PBH_masses) .or. logM .gt. maxval(PBH_masses)) then
@@ -24,7 +24,7 @@
       else
         call dshunt(PBH_masses,PBHfileLen,logM,lowerindx)
         dspbh_limits = 10.d0**(((logM-PBH_masses(lowerindx))*PBH_betamaxes(lowerindx+1) +
-     &                 (PBH_masses(lowerindx+1)-logM)*PBH_betamaxes(lowerindx)) / 
+     &                 (PBH_masses(lowerindx+1)-logM)*PBH_betamaxes(lowerindx)) /
      &                 (PBH_masses(lowerindx+1)-PBH_masses(lowerindx)))
       endif
 
diff -rupN darksusy-5.1.3/src/ucmh/dsucmh_aontsq.f ../installed/darksusy/5.1.3/src/ucmh/dsucmh_aontsq.f
--- darksusy-5.1.3/src/ucmh/dsucmh_aontsq.f	2015-04-07 14:12:14.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/ucmh/dsucmh_aontsq.f	2018-07-04 22:31:57.266479878 +0100
@@ -6,37 +6,42 @@
 !Date: 2011
 !
 !Input:   z       redshift    (dimensionless)
-!Output:  aontsq  a^2/(ct)^2  (Mpc^-2)	
+!Output:  aontsq  a^2/(ct)^2  (Mpc^-2)
 
       double precision function dsucmh_aontsq(z)
 
       implicit none
-      
+
       include 'dsmpconst.h'
 
       double precision, intent(IN) :: z
+      integer, parameter :: nz = 7
       double precision, parameter ::
-     &     zs(7) = (/50.d0, 100.d0, 130.d0, 150.d0, 200.d0,
+     &     zs(nz) = (/50.d0, 100.d0, 130.d0, 150.d0, 200.d0,
      &     500.d0, 1000.d0/)
       double precision, parameter ::
-     &     aontsqs(7) = (/1.78826666d-6, 3.6648633d-6,
+     &     aontsqs(nz) = (/1.78826666d-6, 3.6648633d-6,
      &     4.84663373d-6, 5.65783754d-6, 7.816d-6, 2.274d-5, 5.57d-5/)
       double precision :: weight
-      integer :: zlow_index
+      integer :: zlow_index = 0
 
       !Less accurate at high z.
-      !double precision :: ct, dsageatz 
+      !double precision :: ct, dsageatz
       !ct = dsageatz(z) * c_light / mperkpc ! Mpc
       !dsucmh_aontsq = (ct*(z+1.d0))**(-2)
 
       !More accurate for high z.
-      if (z .lt. zs(1) .or. z .gt. zs(7)) then
+      if (z .lt. zs(1) .or. z .gt. zs(nz)) then
         write(*,*) 'z_c = ', z, ' outside permitted range in dsumch_aontsq.'
         stop
       endif
-      call dshunt(zs,7,z,zlow_index)
-      weight = (zs(zlow_index+1) - z) / (zs(zlow_index+1) - zs(zlow_index))
-      dsucmh_aontsq = exp(weight*log(aontsqs(zlow_index)) + (1.d0 - weight)*log(aontsqs(zlow_index+1)))
+      call dshunt(zs,nz,z,zlow_index)
+      if (zlow_index .eq. nz) then
+        dsucmh_aontsq = aontsqs(nz)
+      else
+        weight = (zs(zlow_index+1) - z) / (zs(zlow_index+1) - zs(zlow_index))
+        dsucmh_aontsq = exp(weight*log(aontsqs(zlow_index)) + (1.d0 - weight)*log(aontsqs(zlow_index+1)))
+      endif
 
       end function dsucmh_aontsq
 
diff -rupN darksusy-5.1.3/src/wa/dswadydth.f ../installed/darksusy/5.1.3/src/wa/dswadydth.f
--- darksusy-5.1.3/src/wa/dswadydth.f	2015-12-20 21:43:06.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/wa/dswadydth.f	2018-07-04 22:31:57.266479878 +0100
@@ -8,7 +8,6 @@
       real*8 function dswadydth(cth, phim0,phim1,phim2,phie0,phieth,phithm,
      & phichi,phiwh,phifk,phifv)
       implicit none
-      include 'dswacom.h'
 
 c------------------------ variables ------------------------------------
 
diff -rupN darksusy-5.1.3/src/wa/dswaemean.f ../installed/darksusy/5.1.3/src/wa/dswaemean.f
--- darksusy-5.1.3/src/wa/dswaemean.f	2009-03-30 13:08:08.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/wa/dswaemean.f	2018-07-04 22:31:57.266479878 +0100
@@ -8,8 +8,6 @@
 
       real*8 function dswaemean(e0,m0,m1,m2)
       implicit none
-      include 'dswacom.h'
-      include 'dsidtag.h'
 
 c------------------------ variables ------------------------------------
 
diff -rupN darksusy-5.1.3/src/wa/dswaifind.f ../installed/darksusy/5.1.3/src/wa/dswaifind.f
--- darksusy-5.1.3/src/wa/dswaifind.f	2008-04-07 22:27:47.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/wa/dswaifind.f	2018-07-04 22:31:57.266479878 +0100
@@ -6,7 +6,6 @@
       subroutine dswaifind(value,array,ipl,ii,imin,imax)
       implicit none
 
-      include 'dswacom.h'
       include 'dsidtag.h'
 
       integer imin,imax,i,inew,imint,imaxt,iold,ii
diff -rupN darksusy-5.1.3/src/wa/dswainit.f ../installed/darksusy/5.1.3/src/wa/dswainit.f
--- darksusy-5.1.3/src/wa/dswainit.f	2013-01-27 15:37:53.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/wa/dswainit.f	2018-07-04 22:31:57.266479878 +0100
@@ -271,9 +271,9 @@ c     &            k,mfi
 
 c...Create mixed tables, differential in energy, integrated in theta
                 do l=0,zn-1
-                  tmpy=0.d0
+                  tmpy=0.e0
                   do m=0,thn
-                     tmpy=tmpy+phidiff(m,l,k,j,i,yli)*dth(m)
+                     tmpy=tmpy+phidiff(m,l,k,j,i,yli)*real(dth(m))
                      phimixed(m,l,k,j,i,yli)=tmpy
                   enddo
                 enddo
@@ -338,7 +338,6 @@ c     &   10.0d0,80.3d0,91.2d0,5*10.d0/
      &  1500.0d0,2000.0d0,3000.0d0,5000.0d0,7500.0d0,10000.0d0/
 c...Lowest mass index for the 14 channels chi
       data milow/1,1,1,1,4,16,1,12,13,1,1,1,1,1/
-      data waerr/0/
       data waftype/'b'/
 c      data wabase/'we-res-b-full'/
 c      data wabase/'we-res-may2012'/
diff -rupN darksusy-5.1.3/src/wa/dswayield.f ../installed/darksusy/5.1.3/src/wa/dswayield.f
--- darksusy-5.1.3/src/wa/dswayield.f	2011-05-24 09:54:48.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/wa/dswayield.f	2018-07-04 22:31:57.266479878 +0100
@@ -59,8 +59,6 @@
       real*8 function dswayield(mneu,e,theta,wh,kind,type,istat)
       implicit none
       include 'dswacom.h'
-      include 'dsidtag.h'
-      include 'dsio.h'
 
 c------------------------ variables ------------------------------------
 
diff -rupN darksusy-5.1.3/src/wa/dswayieldf.f ../installed/darksusy/5.1.3/src/wa/dswayieldf.f
--- darksusy-5.1.3/src/wa/dswayieldf.f	2015-12-20 21:43:06.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/wa/dswayieldf.f	2018-07-04 22:31:57.266479878 +0100
@@ -52,11 +52,13 @@
 
       real*8 function dswayieldf(mwimp,e,theta,chi,wh,kind,
      &  type,istat)
+      use omp_lib
       implicit none
       include 'dswacom.h'
       include 'dsidtag.h'
       include 'dsio.h'
 
+
 c------------------------ variables ------------------------------------
 
       real*8 mwimp,e,theta,phi1,phi2,mp1,mp2,zpl,thpl,mn,z,th,
@@ -64,7 +66,7 @@ c------------------------ variables ----
       integer chi,istat,zi,thi,m1i,m2i,whi,kind,type,yli,chii,ii
       character*2 wh
       logical wb
-      external dswacom, slog ! set up common block variables
+      external slog
 
 c-----------------------------------------------------------------------
 
@@ -73,8 +75,11 @@ c---------------------------------------
 
 c...Safecheck
       if (yli.eq.0) then
-         call dswainit(kind,type)
-         yli=yload(kind,type)
+        if (omp_get_thread_num() .eq. 0) then
+          call dswainit(kind,type)
+        endif
+!$omp barrier
+        yli=yload(kind,type)
       endif
 
       dswayieldf=0.0d0
diff -rupN darksusy-5.1.3/src/wa/dswayieldfth.f ../installed/darksusy/5.1.3/src/wa/dswayieldfth.f
--- darksusy-5.1.3/src/wa/dswayieldfth.f	2015-12-20 21:43:06.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/wa/dswayieldfth.f	2018-07-04 22:31:57.266479878 +0100
@@ -6,7 +6,7 @@
 *****************************************************************************
 
       real*8 function dswayieldfth(e0,m0,mp1,mp2,emuthr,thmax,chi,wh,
-     &  kind,type,istat)
+     &  kind,type,istat,waerror)
       implicit none
       include 'dswacom.h'
       include 'dsidtag.h'
@@ -16,7 +16,7 @@ c------------------------ variables ----
 
       real*8 e0,m0,mp1,mp2,emuthr,thmax,m00,e00,thu
       real*8 mp1t,mp2t
-      integer chi,istat,kind,type
+      integer chi,istat,kind,type,waerror
       character*2 wh
 
       real*8 sum,emax,emin,e1cm,pi
@@ -149,9 +149,9 @@ c          endif
 
       if (wb) then
         if (wh.eq.'su'.or.wh.eq.'SU') then
-          sum=dswayield_int(dswadydth,cos(thu),1.0d0,chi,1,m00,mp1t,mp2t,e00,emuthr,thmax,kind,type)
+          sum=dswayield_int(dswadydth,cos(thu),1.0d0,chi,1,m00,mp1t,mp2t,e00,emuthr,thmax,kind,type,waerror)
         else
-          sum=dswayield_int(dswadydth,cos(thu),1.0d0,chi,2,m00,mp1t,mp2t,e00,emuthr,thmax,kind,type)
+          sum=dswayield_int(dswadydth,cos(thu),1.0d0,chi,2,m00,mp1t,mp2t,e00,emuthr,thmax,kind,type,waerror)
         endif
         dswayieldfth=sum*1.0d-15
       endif
diff -rupN darksusy-5.1.3/src/wa/dswayield_int.f ../installed/darksusy/5.1.3/src/wa/dswayield_int.f
--- darksusy-5.1.3/src/wa/dswayield_int.f	2015-12-20 21:43:06.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/wa/dswayield_int.f	2018-07-04 22:31:57.266479878 +0100
@@ -1,5 +1,5 @@
       real*8 function dswayield_int(f,a,b,phichi,phiwh,phim0,phim1,phim2,
-     & phie0,phieth,phithm,phifk,phifv)        
+     & phie0,phieth,phithm,phifk,phifv,waerror)
 
 c_______________________________________________________________________
 c  integrate function f between a and b
@@ -10,14 +10,13 @@ c  author: joakim edsjo (edsjo@physto.se
 c  based on paolo gondolos wxint.f routine.
 c=======================================================================
       implicit none
-      include 'dswacom.h'
-      real*8 f,a,b,tot,eps,st,os,ost,del,sum,x
+      real*8 f,a,b,tot,epsabs,eps,st,os,ost,del,sum,x
       real*8 phim0,phim1,phim2,phie0,phieth,phithm
       integer phichi,phiwh,phifk,phifv   ! phiwh=1 - sun, 2 - earth
-      integer jmax,it,l,j,nfcn,jdid
+      integer jmax,it,l,j,nfcn,jdid,waerror
       external f
 c      parameter (a=-1.0,b=1.0,eps=1.0d-4,jmax=20)
-      parameter (eps=1.0d-2,jmax=30)  ! je change in eps ps change in jmax
+      parameter (epsabs=1d5, eps=1.0d-2, jmax=20)  ! je change in eps, ps added epsabs
       dswayield_int=0.d0
       del=b-a
       ost=0.5*del*(f(a,phim0,phim1,phim2,phie0,phieth,phithm,phichi,phiwh,phifk,phifv)+
@@ -41,7 +40,7 @@ c      parameter (a=-1.0,b=1.0,eps=1.0d-
         st=0.5*(st+del*sum)
         tot=(4.0*st-ost)/3.0
         jdid=j
-        if (abs(tot-os).le.eps*abs(os)) then
+        if (abs(tot-os).le.eps*abs(os) .or. abs(tot).le.epsabs) then
            dswayield_int=tot
            return
         endif
@@ -50,8 +49,11 @@ c      parameter (a=-1.0,b=1.0,eps=1.0d-
 c        type *,'jdid',jdid,' os',os, 'ost',ost
       enddo
 
+!$omp critical (stdout)
       write(*,*) 'DS WARNING: too many steps in dswayield_int.'
-      waerr=1
+!$omp end critical (stdout)
+
+      waerror=1
       dswayield_int=0.0d0
 
       end
diff -rupN darksusy-5.1.3/src/wa/dswayieldone.f ../installed/darksusy/5.1.3/src/wa/dswayieldone.f
--- darksusy-5.1.3/src/wa/dswayieldone.f	2013-01-31 21:46:16.000000000 +0000
+++ ../installed/darksusy/5.1.3/src/wa/dswayieldone.f	2018-07-04 22:31:57.266479878 +0100
@@ -105,16 +105,16 @@
 *****************************************************************************
 
       real*8 function dswayieldone(mneu,e,theta,ch,wh,kind,type,istat)
+      use omp_lib
       implicit none
       include 'dswacom.h'
       include 'dsidtag.h'
-      include 'dsio.h'
 
 c------------------------ variables ------------------------------------
 
       real*8 mneu,e,theta,flx
       real*8 mp1,mp2,e1,e2
-      integer ch,chi,istat,i,kind,type
+      integer ch,chi,istat,waerror,i,kind,type
       character*2 wh
 
       logical chok
@@ -134,7 +134,7 @@ c---------------------------------------
 c      write(*,*) 'dswayieldone called with ',kind,type
 
       istat=0
-      waerr=0
+      waerror=0
       mp1=0.d0
       mp2=0.d0
 
@@ -142,19 +142,24 @@ c      write(*,*) 'dswayieldone called w
 
 c--------------------------------------- if first call, load yield tables
 
-
       if (first) then
-        do i=1,26
-           yload(1,i)=0
-           yload(2,i)=0
-        enddo
-        walast(1)=0 ! last index for integrated yields stored in memory
-        walast(2)=0 ! last index for differential yields stored in memory
-        first=.false.
+        if (omp_get_thread_num() .eq. 0) then
+          do i=1,26
+             yload(1,i)=0
+             yload(2,i)=0
+          enddo
+          walast(1)=0 ! last index for integrated yields stored in memory
+          walast(2)=0 ! last index for differential yields stored in memory
+          first=.false.
+        endif
+!$omp barrier
       endif
 
       if (yload(kind2ki(kind),type).eq.0) then
-        call dswainit(kind,type)
+        if (omp_get_thread_num() .eq. 0) then
+          call dswainit(kind,type)
+        endif
+!$omp barrier
       endif
 
 c-----------------------------------------------------------------------
@@ -233,59 +238,59 @@ c...check different annihilation channel
 
 c---------- S10 S10 channel ----------
           if (ch.eq.1) then
-            flx=flx+2.d0*dswayields(e1,e,theta,1,wh,kind,type,istat)
+            flx=flx+2.d0*dswayields(e1,e,theta,1,wh,kind,type,istat,waerror)
 
 c---------- S10 S20 channel ----------
           elseif (ch.eq.2) then
-            flx=flx+dswayields(e1,e,theta,1,wh,kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,2,wh,kind,type,istat)
+            flx=flx+dswayields(e1,e,theta,1,wh,kind,type,istat,waerror)
+            flx=flx+dswayields(e2,e,theta,2,wh,kind,type,istat,waerror)
 
 c---------- S20 S20 channel ----------
           elseif (ch.eq.3) then
-            flx=flx+2.d0*dswayields(e1,e,theta,2,wh,kind,type,istat)
+            flx=flx+2.d0*dswayields(e1,e,theta,2,wh,kind,type,istat,waerror)
 
 c---------- S30 S30 channel ----------
           elseif (ch.eq.4) then
-            flx=flx+2.d0*dswayields(e1,e,theta,3,wh,kind,type,istat)
+            flx=flx+2.d0*dswayields(e1,e,theta,3,wh,kind,type,istat,waerror)
 
 c---------- S10 S30 channel ----------
           elseif (ch.eq.5) then
-            flx=flx+dswayields(e1,e,theta,1,wh,kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat)
+            flx=flx+dswayields(e1,e,theta,1,wh,kind,type,istat,waerror)
+            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat,waerror)
 
 c---------- S20 S30 channel ----------
           elseif (ch.eq.6) then
-            flx=flx+dswayields(e1,e,theta,2,wh,kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat)
+            flx=flx+dswayields(e1,e,theta,2,wh,kind,type,istat,waerror)
+            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat,waerror)
 
 c---------- S+ S- channel ----------
           elseif (ch.eq.7) then
-            flx=flx+2.d0*dswayields(e1,e,theta,4,wh,kind,type,istat)
+            flx=flx+2.d0*dswayields(e1,e,theta,4,wh,kind,type,istat,waerror)
 
 c---------- Z0 S10 channel ----------
           elseif (ch.eq.8) then
             flx=flx+0.5d0*dswayieldf(e1,e,theta,9,wh,
      &        kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,1,wh,kind,type,istat)
+            flx=flx+dswayields(e2,e,theta,1,wh,kind,type,istat,waerror)
 
 c---------- Z0 S20 channel ----------
           elseif (ch.eq.9) then
             flx=flx+0.5d0*dswayieldf(e1,e,theta,9,wh,
      &        kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,2,wh,kind,type,istat)
+            flx=flx+dswayields(e2,e,theta,2,wh,kind,type,istat,waerror)
 
 c---------- Z0 S30 channel ----------
           elseif (ch.eq.10) then
             flx=flx+0.5d0*dswayieldf(e1,e,theta,9,wh,
      &        kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat)
+            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat,waerror)
 
 c---------- w+h- w-h+ channel ----------
 c...this calculation gives a mean of the two channels w+h- & w-h+
           elseif (ch.eq.11) then
             flx=flx+0.5d0*dswayieldf(e1,e,theta,8,wh,
      &        kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,4,wh,kind,type,istat)
+            flx=flx+dswayields(e2,e,theta,4,wh,kind,type,istat,waerror)
 
 c---------- z0 gamma channel ----------
           elseif (ch.eq.29) then
@@ -307,14 +312,15 @@ c          endif
 
       endif
 
-      if (waerr.gt.0) then
+      if (waerror.gt.0) then
+!$omp critical (stdout)
         write(*,*) 'DS WARNING in dswayieldone for model ',idtag,
      &    ', yield type ',type,' and channel ',ch
         write(*,*) '  the integration over scalar decay angles ran',
      &    ' into numerical problems.'
         write(*,*) '  The results can only be trusted as a lower',
      &    'bound.'
-        waistat=ibset(waistat,2)
+!$omp end critical (stdout)
         istat=ibset(istat,2)
       endif
 
diff -rupN darksusy-5.1.3/src/wa/dswayields2.f ../installed/darksusy/5.1.3/src/wa/dswayields2.f
--- darksusy-5.1.3/src/wa/dswayields2.f	2009-05-08 09:54:47.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/wa/dswayields2.f	2018-07-04 22:31:57.266479878 +0100
@@ -8,14 +8,14 @@
 *****************************************************************************
 
       real*8 function dswayields2(eh,emuth,thmax,hno,wh,kind,
-     &  type,istat)
+     &  type,istat,waerror)
       implicit none
       include 'dswacom.h'
 
 c------------------------ variables ------------------------------------
 
       real*8 eh,emuth,thmax
-      integer hno,istat,kind,type,chi
+      integer hno,istat,waerror,kind,type,chi
       character*2 wh
 
       real*8 e1,e2,yield
@@ -39,7 +39,7 @@ c..."fundamental" channels
           if (was0br(chi2ch(chi),hno).gt.0.0d0) then
             yield=yield+was0br(chi2ch(chi),hno)*2.0d0*
      &        dswayieldfth(eh,was0m(hno),map(chi),map(chi),emuth,thmax,
-     &          chi,wh,kind,type,istat)
+     &          chi,wh,kind,type,istat,waerror)
           endif
   100   continue
 
@@ -47,95 +47,95 @@ c..."complex" channels
         if (was0br(1,hno).gt.0.0d0) then    ! S10 S10 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(1))
           yield=yield+2.0*was0br(1,hno)*dswayields3(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(2,hno).gt.0.0d0) then    ! S10 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(2))
           yield=yield+was0br(2,hno)*dswayields3(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(2),was0m(1))
           yield=yield+was0br(2,hno)*dswayields3(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(3,hno).gt.0.0d0) then    ! S20 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(2))
           yield=yield+2.0*was0br(3,hno)*dswayields3(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(4,hno).gt.0.0d0) then    ! S30 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(3),was0m(3))
           yield=yield+2.0*was0br(4,hno)*dswayields3(e1,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(5,hno).gt.0.0d0) then    ! S10 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(3))
           yield=yield+was0br(5,hno)*dswayields3(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(1))
           yield=yield+was0br(5,hno)*dswayields3(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(6,hno).gt.0.0d0) then    ! S20 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(3))
           yield=yield+was0br(6,hno)*dswayields3(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(2))
           yield=yield+was0br(6,hno)*dswayields3(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(7,hno).gt.0.0d0) then    ! S+ S- channel
           e1=dswaemean(eh,was0m(hno),wascm,wascm)
           yield=yield+2.0*
      &      was0br(7,hno)*dswayields3(e1,emuth,thmax,4,wh,
-     &        kind,type,istat)
+     &        kind,type,istat,waerror)
         endif
 
         if (was0br(8,hno).gt.0.0d0) then    ! z0 S10 channel
           e2=dswaemean(eh,was0m(hno),was0m(1),map(9))
           yield=yield+was0br(8,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(1),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(8,hno)*dswayields3(e2,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(9,hno).gt.0.0d0) then    ! z0 S20 channel
           e2=dswaemean(eh,was0m(hno),was0m(2),map(9))
           yield=yield+was0br(9,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(2),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(9,hno)*dswayields3(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(10,hno).gt.0.0d0) then    ! z0 S30 channel
           e2=dswaemean(eh,was0m(hno),was0m(3),map(9))
           yield=yield+was0br(10,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(3),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(10,hno)*dswayields3(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(11,hno).gt.0.0d0) then    ! w-S+ w+S- channel
           e2=dswaemean(eh,was0m(hno),wascm,map(8))
           yield=yield+was0br(11,hno)*
      +    dswayieldfth(eh,was0m(hno),map(8),wascm,emuth,thmax,
-     &      8,wh,kind,type,istat)
+     &      8,wh,kind,type,istat,waerror)
           yield=yield+was0br(11,hno)*dswayields3(e2,emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(29,hno).gt.0.0d0) then    ! Z0 gamma
           yield=yield+was0br(29,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),0.0d0,emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
         endif
 
 c---------- charged scalar bosons ----------
@@ -144,118 +144,118 @@ c---------- charged scalar bosons ------
         if (wascbr(1).gt.0.0d0) then ! u d-bar
            yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(1),map(2),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(2),map(1),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(2).gt.0.0d0) then ! u s-bar
            yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(3),map(2),emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
           yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(2),map(3),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(3).gt.0.0d0) then ! u b-bar
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(5),map(2),emuth,thmax,
-     &      5,wh,kind,type,istat)
+     &      5,wh,kind,type,istat,waerror)
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(2),map(5),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(4).gt.0.0d0) then ! c d-bar
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(4),map(1),emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(1),map(4),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(5).gt.0.0d0) then ! c s-bar
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(4),map(3),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(3),map(4),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(6).gt.0.0d0) then ! c b-bar
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(4),map(5),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(5),map(4),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(7).gt.0.0d0) then ! t d-bar
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(6),map(1),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(1),map(6),emuth,thmax,
-     &    1,wh,kind,type,istat)
+     &    1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(8).gt.0.0d0) then ! t s-bar
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(6),map(3),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(3),map(6),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(9).gt.0.0d0) then ! t b-bar
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(6),map(5),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(5),map(6),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(12).gt.0.0d0) then ! tau nu_tau
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(11),map(14),emuth,thmax,
-     &    11,wh,kind,type,istat)
+     &    11,wh,kind,type,istat,waerror)
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(14),map(11),emuth,thmax,
-     &    14,wh,kind,type,istat)
+     &    14,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(13).gt.0.0d0) then ! w+ h1
           yield=yield+wascbr(13)*
      &    dswayieldfth(eh,wascm,map(8),was0m(1),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(1),map(8))
           yield=yield+wascbr(13)*
-     &      dswayields3(e2,emuth,thmax,1,wh,kind,type,istat)
+     &      dswayields3(e2,emuth,thmax,1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(14).gt.0.0d0) then ! w+ h2
           yield=yield+wascbr(14)*
      &    dswayieldfth(eh,wascm,map(8),was0m(2),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(2),map(8))
           yield=yield+wascbr(14)*
-     &      dswayields3(e2,emuth,thmax,2,wh,kind,type,istat)
+     &      dswayields3(e2,emuth,thmax,2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(15).gt.0.0d0) then ! w+ h3
           yield=yield+wascbr(15)*
      &    dswayieldfth(eh,wascm,map(8),was0m(3),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(3),map(8))
           yield=yield+wascbr(15)*
-     &      dswayields3(e2,emuth,thmax,3,wh,kind,type,istat)
+     &      dswayields3(e2,emuth,thmax,3,wh,kind,type,istat,waerror)
         endif
 
       endif
diff -rupN darksusy-5.1.3/src/wa/dswayields3.f ../installed/darksusy/5.1.3/src/wa/dswayields3.f
--- darksusy-5.1.3/src/wa/dswayields3.f	2009-05-08 09:54:47.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/wa/dswayields3.f	2018-07-04 22:31:57.270477878 +0100
@@ -8,14 +8,14 @@
 *****************************************************************************
 
       real*8 function dswayields3(eh,emuth,thmax,hno,wh,kind,
-     &  type,istat)
+     &  type,istat,waerror)
       implicit none
       include 'dswacom.h'
 
 c------------------------ variables ------------------------------------
 
       real*8 eh,emuth,thmax
-      integer hno,istat,kind,type,chi
+      integer hno,istat,waerror,kind,type,chi
       character*2 wh
 
       real*8 e1,e2,yield
@@ -39,7 +39,7 @@ c..."fundamental" channels
           if (was0br(chi2ch(chi),hno).gt.0.0d0) then
             yield=yield+was0br(chi2ch(chi),hno)*2.0d0*
      &        dswayieldfth(eh,was0m(hno),map(chi),map(chi),emuth,thmax,
-     &          chi,wh,kind,type,istat)
+     &          chi,wh,kind,type,istat,waerror)
           endif
   100   continue
 
@@ -47,95 +47,95 @@ c..."complex" channels
         if (was0br(1,hno).gt.0.0d0) then    ! S10 S10 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(1))
           yield=yield+2.0*was0br(1,hno)*dswayields4(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(2,hno).gt.0.0d0) then    ! S10 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(2))
           yield=yield+was0br(2,hno)*dswayields4(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(2),was0m(1))
           yield=yield+was0br(2,hno)*dswayields4(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(3,hno).gt.0.0d0) then    ! S20 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(2))
           yield=yield+2.0*was0br(3,hno)*dswayields4(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(4,hno).gt.0.0d0) then    ! S30 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(3),was0m(3))
           yield=yield+2.0*was0br(4,hno)*dswayields4(e1,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(5,hno).gt.0.0d0) then    ! S10 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(3))
           yield=yield+was0br(5,hno)*dswayields4(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(1))
           yield=yield+was0br(5,hno)*dswayields4(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(6,hno).gt.0.0d0) then    ! S20 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(3))
           yield=yield+was0br(6,hno)*dswayields4(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(2))
           yield=yield+was0br(6,hno)*dswayields4(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(7,hno).gt.0.0d0) then    ! S+ S- channel
           e1=dswaemean(eh,was0m(hno),wascm,wascm)
           yield=yield+2.0*
      &      was0br(7,hno)*dswayields4(e1,emuth,thmax,4,wh,
-     &        kind,type,istat)
+     &        kind,type,istat,waerror)
         endif
 
         if (was0br(8,hno).gt.0.0d0) then    ! z0 S10 channel
           e2=dswaemean(eh,was0m(hno),was0m(1),map(9))
           yield=yield+was0br(8,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(1),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(8,hno)*dswayields4(e2,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(9,hno).gt.0.0d0) then    ! z0 S20 channel
           e2=dswaemean(eh,was0m(hno),was0m(2),map(9))
           yield=yield+was0br(9,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(2),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(9,hno)*dswayields4(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(10,hno).gt.0.0d0) then    ! z0 S30 channel
           e2=dswaemean(eh,was0m(hno),was0m(3),map(9))
           yield=yield+was0br(10,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(3),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(10,hno)*dswayields4(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(11,hno).gt.0.0d0) then    ! w-S+ w+S- channel
           e2=dswaemean(eh,was0m(hno),wascm,map(8))
           yield=yield+was0br(11,hno)*
      +    dswayieldfth(eh,was0m(hno),map(8),wascm,emuth,thmax,
-     &      8,wh,kind,type,istat)
+     &      8,wh,kind,type,istat,waerror)
           yield=yield+was0br(11,hno)*dswayields4(e2,emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(29,hno).gt.0.0d0) then    ! Z0 gamma
           yield=yield+was0br(29,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),0.0d0,emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
         endif
 
 c---------- charged scalar bosons ----------
@@ -144,118 +144,118 @@ c---------- charged scalar bosons ------
         if (wascbr(1).gt.0.0d0) then ! u d-bar
            yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(1),map(2),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(2),map(1),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(2).gt.0.0d0) then ! u s-bar
            yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(3),map(2),emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
           yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(2),map(3),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(3).gt.0.0d0) then ! u b-bar
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(5),map(2),emuth,thmax,
-     &      5,wh,kind,type,istat)
+     &      5,wh,kind,type,istat,waerror)
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(2),map(5),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(4).gt.0.0d0) then ! c d-bar
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(4),map(1),emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(1),map(4),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(5).gt.0.0d0) then ! c s-bar
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(4),map(3),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(3),map(4),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(6).gt.0.0d0) then ! c b-bar
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(4),map(5),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(5),map(4),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(7).gt.0.0d0) then ! t d-bar
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(6),map(1),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(1),map(6),emuth,thmax,
-     &    1,wh,kind,type,istat)
+     &    1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(8).gt.0.0d0) then ! t s-bar
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(6),map(3),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(3),map(6),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(9).gt.0.0d0) then ! t b-bar
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(6),map(5),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(5),map(6),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(12).gt.0.0d0) then ! tau nu_tau
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(11),map(14),emuth,thmax,
-     &    11,wh,kind,type,istat)
+     &    11,wh,kind,type,istat,waerror)
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(14),map(11),emuth,thmax,
-     &    14,wh,kind,type,istat)
+     &    14,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(13).gt.0.0d0) then ! w+ h1
           yield=yield+wascbr(13)*
      &    dswayieldfth(eh,wascm,map(8),was0m(1),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(1),map(8))
           yield=yield+wascbr(13)*
-     &      dswayields4(e2,emuth,thmax,1,wh,kind,type,istat)
+     &      dswayields4(e2,emuth,thmax,1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(14).gt.0.0d0) then ! w+ h2
           yield=yield+wascbr(14)*
      &    dswayieldfth(eh,wascm,map(8),was0m(2),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(2),map(8))
           yield=yield+wascbr(14)*
-     &      dswayields4(e2,emuth,thmax,2,wh,kind,type,istat)
+     &      dswayields4(e2,emuth,thmax,2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(15).gt.0.0d0) then ! w+ h3
           yield=yield+wascbr(15)*
      &    dswayieldfth(eh,wascm,map(8),was0m(3),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(3),map(8))
           yield=yield+wascbr(15)*
-     &      dswayields4(e2,emuth,thmax,3,wh,kind,type,istat)
+     &      dswayields4(e2,emuth,thmax,3,wh,kind,type,istat,waerror)
         endif
 
       endif
diff -rupN darksusy-5.1.3/src/wa/dswayields4.f ../installed/darksusy/5.1.3/src/wa/dswayields4.f
--- darksusy-5.1.3/src/wa/dswayields4.f	2009-05-08 09:54:47.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/wa/dswayields4.f	2018-07-04 22:31:57.270477878 +0100
@@ -8,7 +8,7 @@
 *****************************************************************************
 
       real*8 function dswayields4(eh,emuth,thmax,hno,wh,
-     &  kind,type,istat)
+     &  kind,type,istat,waerror)
       implicit none
       include 'dswacom.h'
       include 'dsidtag.h'
@@ -16,7 +16,7 @@
 c------------------------ variables ------------------------------------
 
       real*8 eh,emuth,thmax
-      integer hno,istat,kind,type
+      integer hno,istat,waerror,kind,type
       character*2 wh
 
       real*8 yield
@@ -40,7 +40,7 @@ c..."fundamental" channels
           if (was0br(chi2ch(chi),hno).gt.0.0d0) then
             yield=yield+was0br(chi2ch(chi),hno)*2.0d0*
      &        dswayieldfth(eh,was0m(hno),map(chi),map(chi),emuth,thmax,
-     &          chi,wh,kind,type,istat)
+     &          chi,wh,kind,type,istat,waerror)
           endif
   100   continue
 
@@ -51,91 +51,91 @@ c---------- charged scalar bosons ------
         if (wascbr(1).gt.0.0d0) then ! u d-bar
            yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(1),map(2),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(2),map(1),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(2).gt.0.0d0) then ! u s-bar
            yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(3),map(2),emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
           yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(2),map(3),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(3).gt.0.0d0) then ! u b-bar
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(5),map(2),emuth,thmax,
-     &      5,wh,kind,type,istat)
+     &      5,wh,kind,type,istat,waerror)
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(2),map(5),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(4).gt.0.0d0) then ! c d-bar
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(4),map(1),emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(1),map(4),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(5).gt.0.0d0) then ! c s-bar
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(4),map(3),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(3),map(4),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(6).gt.0.0d0) then ! c b-bar
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(4),map(5),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(5),map(4),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(7).gt.0.0d0) then ! t d-bar
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(6),map(1),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(1),map(6),emuth,thmax,
-     &    1,wh,kind,type,istat)
+     &    1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(8).gt.0.0d0) then ! t s-bar
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(6),map(3),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(3),map(6),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(9).gt.0.0d0) then ! t b-bar
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(6),map(5),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(5),map(6),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(12).gt.0.0d0) then ! tau nu_tau
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(11),map(14),emuth,thmax,
-     &    11,wh,kind,type,istat)
+     &    11,wh,kind,type,istat,waerror)
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(14),map(11),emuth,thmax,
-     &    14,wh,kind,type,istat)
+     &    14,wh,kind,type,istat,waerror)
         endif
 
       endif
diff -rupN darksusy-5.1.3/src/wa/dswayields.f ../installed/darksusy/5.1.3/src/wa/dswayields.f
--- darksusy-5.1.3/src/wa/dswayields.f	2009-05-08 09:54:47.000000000 +0100
+++ ../installed/darksusy/5.1.3/src/wa/dswayields.f	2018-07-04 22:31:57.270477878 +0100
@@ -8,14 +8,14 @@
 *****************************************************************************
 
       real*8 function dswayields(eh,emuth,thmax,hno,wh,kind,
-     &  type,istat)
+     &  type,istat,waerror)
       implicit none
       include 'dswacom.h'
 
 c------------------------ variables ------------------------------------
 
       real*8 eh,emuth,thmax
-      integer hno,istat,kind,type,chi
+      integer hno,istat,waerror,kind,type,chi
       character*2 wh
 
       real*8 e1,e2,yield
@@ -38,7 +38,7 @@ c..."fundamental" channels
           if (was0br(chi2ch(chi),hno).gt.0.0d0) then
             yield=yield+was0br(chi2ch(chi),hno)*2.0d0*
      &        dswayieldfth(eh,was0m(hno),map(chi),map(chi),emuth,thmax,
-     &          chi,wh,kind,type,istat)
+     &          chi,wh,kind,type,istat,waerror)
           endif
   100   continue
 
@@ -46,95 +46,95 @@ c..."complex" channels
         if (was0br(1,hno).gt.0.0d0) then    ! S10 S10 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(1))
           yield=yield+2.0*was0br(1,hno)*dswayields2(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(2,hno).gt.0.0d0) then    ! S10 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(2))
           yield=yield+was0br(2,hno)*dswayields2(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(2),was0m(1))
           yield=yield+was0br(2,hno)*dswayields2(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(3,hno).gt.0.0d0) then    ! S20 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(2))
           yield=yield+2.0*was0br(3,hno)*dswayields2(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(4,hno).gt.0.0d0) then    ! S30 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(3),was0m(3))
           yield=yield+2.0*was0br(4,hno)*dswayields2(e1,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(5,hno).gt.0.0d0) then    ! S10 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(3))
           yield=yield+was0br(5,hno)*dswayields2(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(1))
           yield=yield+was0br(5,hno)*dswayields2(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(6,hno).gt.0.0d0) then    ! S20 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(3))
           yield=yield+was0br(6,hno)*dswayields2(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(2))
           yield=yield+was0br(6,hno)*dswayields2(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(7,hno).gt.0.0d0) then    ! S+ S- channel
           e1=dswaemean(eh,was0m(hno),wascm,wascm)
           yield=yield+2.0*
      &      was0br(7,hno)*dswayields2(e1,emuth,thmax,4,wh,
-     &        kind,type,istat)
+     &        kind,type,istat,waerror)
         endif
 
         if (was0br(8,hno).gt.0.0d0) then    ! z0 S10 channel
           e2=dswaemean(eh,was0m(hno),was0m(1),map(9))
           yield=yield+was0br(8,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(1),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(8,hno)*dswayields2(e2,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(9,hno).gt.0.0d0) then    ! z0 S20 channel
           e2=dswaemean(eh,was0m(hno),was0m(2),map(9))
           yield=yield+was0br(9,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(2),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(9,hno)*dswayields2(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(10,hno).gt.0.0d0) then    ! z0 S30 channel
           e2=dswaemean(eh,was0m(hno),was0m(3),map(9))
           yield=yield+was0br(10,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(3),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(10,hno)*dswayields2(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(11,hno).gt.0.0d0) then    ! w-S+ w+S- channel
           e2=dswaemean(eh,was0m(hno),wascm,map(8))
           yield=yield+was0br(11,hno)*
      +    dswayieldfth(eh,was0m(hno),map(8),wascm,emuth,thmax,
-     &      8,wh,kind,type,istat)
+     &      8,wh,kind,type,istat,waerror)
           yield=yield+was0br(11,hno)*dswayields2(e2,emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(29,hno).gt.0.0d0) then    ! Z0 gamma
           yield=yield+was0br(29,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),0.0d0,emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
         endif
 c        write(*,*) '   ...after complex: ',yield
 
@@ -144,118 +144,118 @@ c---------- charged scalar bosons ------
         if (wascbr(1).gt.0.0d0) then ! u d-bar
            yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(1),map(2),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(2),map(1),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(2).gt.0.0d0) then ! u s-bar
            yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(3),map(2),emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
           yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(2),map(3),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(3).gt.0.0d0) then ! u b-bar
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(5),map(2),emuth,thmax,
-     &      5,wh,kind,type,istat)
+     &      5,wh,kind,type,istat,waerror)
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(2),map(5),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(4).gt.0.0d0) then ! c d-bar
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(4),map(1),emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(1),map(4),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(5).gt.0.0d0) then ! c s-bar
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(4),map(3),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(3),map(4),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(6).gt.0.0d0) then ! c b-bar
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(4),map(5),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(5),map(4),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(7).gt.0.0d0) then ! t d-bar
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(6),map(1),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(1),map(6),emuth,thmax,
-     &    1,wh,kind,type,istat)
+     &    1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(8).gt.0.0d0) then ! t s-bar
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(6),map(3),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(3),map(6),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(9).gt.0.0d0) then ! t b-bar
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(6),map(5),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(5),map(6),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(12).gt.0.0d0) then ! tau nu_tau
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(11),map(14),emuth,thmax,
-     &    11,wh,kind,type,istat)
+     &    11,wh,kind,type,istat,waerror)
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(14),map(11),emuth,thmax,
-     &    14,wh,kind,type,istat)
+     &    14,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(13).gt.0.0d0) then ! w+ h1
           yield=yield+wascbr(13)*
      &    dswayieldfth(eh,wascm,map(8),was0m(1),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(1),map(8))
           yield=yield+wascbr(13)*
-     &      dswayields2(e2,emuth,thmax,1,wh,kind,type,istat)
+     &      dswayields2(e2,emuth,thmax,1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(14).gt.0.0d0) then ! w+ h2
           yield=yield+wascbr(14)*
      &    dswayieldfth(eh,wascm,map(8),was0m(2),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(2),map(8))
           yield=yield+wascbr(14)*
-     &      dswayields2(e2,emuth,thmax,2,wh,kind,type,istat)
+     &      dswayields2(e2,emuth,thmax,2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(15).gt.0.0d0) then ! w+ h3
           yield=yield+wascbr(15)*
      &    dswayieldfth(eh,wascm,map(8),was0m(3),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(3),map(8))
           yield=yield+wascbr(15)*
-     &      dswayields2(e2,emuth,thmax,3,wh,kind,type,istat)
+     &      dswayields2(e2,emuth,thmax,3,wh,kind,type,istat,waerror)
         endif
 
       endif
